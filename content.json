{"pages":[{"title":"About","date":"2021-10-25T10:00:52.042Z","path":"about/index.html","text":"hello world"},{"title":"Tags","date":"2021-10-25T08:46:51.302Z","path":"tags/index.html","text":""},{"title":"Categories","date":"2021-10-25T08:46:44.318Z","path":"categories/index.html","text":""}],"posts":[{"title":"TensorFlow2笔记-LeNet(经典卷积网络)","date":"2021-11-01T02:11:58.082Z","path":"wiki/机器学习/Tensorflow笔记/经典卷积网络/","text":"介绍这里主要介绍卷积神经网络的经典网络，然后通过tensorflow进行实现（以上章的卷积神经网络实现代码为基础，进行实现）。 统计卷积网络神经网络层数一般只统计卷积计算层和全连接计算层。 ImageNet ImageNet 是一个计算机视觉系统识别项目,是目前世界上图像识别最大的数据库。是美国斯坦福的计算机科学家，模拟人类的识别系统建立的。能够从图片识别物体。ImageNet是一个非常有前景的研究项目，未来用在机器人身上，就可以直接辨认物品和人了。 经典卷积网络12graph LR A(LeNet 1998) --&gt; B(AlexNet 2012) --&gt; C(VGGNet 2014) --&gt; D(Inception Net 2014) --&gt; E(ResNet 2015) LeNet由Yann LeCun于1998年提出，卷积网络开篇之作。通过共享卷积核减少了网络的参数。LeNet如下所示(C5画错了是F5) LeNet提出的时候还没提出BN和Dropout层，所以LeNet网络不具有BN和Dropout层。 根据上图实现LeNet代码如下： 12345678910111213141516171819202122232425class MyLeNet(Model): def __init__(self): super(MyLeNet, self).__init__() self.c1 = Conv2D(filters=6,kernel_size=(5,5),activation=&#x27;sigmoid&#x27;) self.p1 = MaxPool2D(pool_size=(2,2),strides=2) self.c2 = Conv2D(filters=16,kernel_size=(5,5),activation=&#x27;sigmoid&#x27;) self.p2 = MaxPool2D(pool_size=(2,2),strides=2) self.flatten = Flatten() self.f1 = Dense(120,activation=&#x27;sigmoid&#x27;) self.f2 = Dense(84,activation=&#x27;sigmoid&#x27;) self.f3 = Dense(10,activation=&#x27;softmax&#x27;) def call(self,x): x = self.c1(x) x = self.p1(x) x = self.c2(x) x = self.p2(x) # 提取的特征作为神经网络的输入特征 x = self.flatten(x) x = self.f1(x) x = self.f2(x) y = self.f3(x) return y AlexNetAlexNet网络诞生于2012年，是Hinton代表作之一。使用relu激活函数，提升训练速度，使用Dropout缓解过拟合。AlexNet实现代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class AlexNet(Model): def __init__(self): super(AlexNet, self).__init__() # 第一层 self.c1 = Conv2D(filters=96,kernel_size=(3,3)) self.b1 = BatchNormalization() self.a1 = Activation(&#x27;relu&#x27;) self.p1 = MaxPool2D(pool_size=(3,3),strides=2) #第二层 self.c2 = Conv2D(filters=256,kernel_size=(3,3)) self.b2 = BatchNormalization() self.a2 = Activation(&#x27;relu&#x27;) self.p2 = MaxPool2D(pool_size=(3,3),strides=2) #第三层 self.c3 = Conv2D(filters=384,kernel_size=(3,3),padding=&#x27;same&#x27;,activation=&#x27;relu&#x27;) #第四层 self.c4 = Conv2D(filters=384,kernel_size=(3,3),padding=&#x27;same&#x27;,activation=&#x27;relu&#x27;) #第五层 self.c5 = Conv2D(filters=256,kernel_size=(3,3),padding=&#x27;same&#x27;,activation=&#x27;relu&#x27;) self.p3 = MaxPool2D(pool_size=(3,3),strides=2) #神经网络计算层 self.flatten = Flatten() self.f1 = Dense(2048,activation=&#x27;relu&#x27;) self.d1 = Dropout(0.5) self.f2 = Dense(84,activation=&#x27;relu&#x27;) self.d1 = Dropout(0.5) self.f3 = Dense(10,activation=&#x27;softmax&#x27;) def call(self,x): x = self.c1(x) x = self.b1(x) x = self.a1(x) x = self.p1(x) x = self.c2(x) x = self.b2(x) x = self.a2(x) x = self.p2(x) x = self.c3(x) x = self.c4(x) x = self.c5(x) x = self.p3(x) # 提取的特征作为神经网络的输入特征 x = self.flatten(x) x = self.f1(x) x = self.d1(x) x = self.f2(x) x = self.d2(x) y = self.f3(x) return y VGGNetCGGNet诞生于2014年，当年ImageNet竞赛的亚军。使用小尺寸卷积核，在减少的参数的同时，提高了识别准确率。VGGNet网络结构框图如下所示。 VGGNet的网络结构是：两次CBA，CBAPD，三次CBA , CBA,CBAPD。 Inception NetResNet","tags":[{"name":"TensorFlow2","slug":"TensorFlow2","permalink":"http://example.com/tags/TensorFlow2/"},{"name":"CNN","slug":"CNN","permalink":"http://example.com/tags/CNN/"}],"categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"TensorFlow2","slug":"深度学习/TensorFlow2","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/TensorFlow2/"}]},{"title":"TensorFlow2笔记-NN(全连接)","date":"2021-10-29T06:05:38.694Z","path":"wiki/机器学习/Tensorflow笔记/NN/","text":"介绍全连接NN：每个神经元与前后相邻层的每一个神经元都有连接关系，输入是特征，输出为预测的结果。（可以类比于满射，前后层神经元之间都有联系） 参数个数 参数个数=$\\displaystyle \\sum^{}_{各层}{前层*后层(w)+后层(b)}$","tags":[{"name":"TensorFlow2","slug":"TensorFlow2","permalink":"http://example.com/tags/TensorFlow2/"},{"name":"CNN","slug":"CNN","permalink":"http://example.com/tags/CNN/"}],"categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"TensorFlow2","slug":"深度学习/TensorFlow2","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/TensorFlow2/"}]},{"title":"TensorFlow2笔记-第四讲(网络八股扩展)","date":"2021-10-29T06:00:43.670Z","path":"wiki/机器学习/Tensorflow笔记/第四讲-网络八股扩展/","text":"","tags":[{"name":"TensorFlow2","slug":"TensorFlow2","permalink":"http://example.com/tags/TensorFlow2/"}],"categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"TensorFlow2","slug":"深度学习/TensorFlow2","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/TensorFlow2/"}]},{"title":"TensorFlow2笔记-CNN(卷积神经网络)","date":"2021-10-29T04:44:21.509Z","path":"wiki/机器学习/Tensorflow笔记/CNN/","text":"问题介绍如果仅仅依靠全连接神经网络来训练模型，则在实际应用中，输入特征会非常多，参数十分复杂，让训练变得非常庞大。所以在实际应用时，会对原始图像进行特征提取再把提取到的特征送给全连接网络。流程如下所示： 123graph LR 原始图片 --&gt; 若干层特征提取 若干层特征提取 --&gt; 全连接网络 卷积计算是一种提取图片特征的有效方法。 卷积计算过程 单通道卷积计算 从上图可以看出,卷积神经网络计算的过程实际上就是将大的数据，根据区域提取其相关特征，减少了特征数目。从 5x5x1 的参数，经过 3x3x1的卷积核卷积计算后，转化为3x3x1的参数网络。 多通道卷积计算从图中可以看出，对于输入特征是多通道的，每个通道都通过卷积层计算相应的调整值。从图片看从5×5×3经过3×3×3的卷积核计算，对每个通道的重合区域，经过对应通道 的卷积核计算的结果作为输出调整图中的一个像素点。 总结对于卷积神经网络的计算过程，就是从左到右，从上到下，根据卷积核重叠的区域，依次计算结果，作为输出特征图的一个像素点。 用CNN实现离散数据的分类(以图像分类为例)1. 感受野(Receptive Field)感受野：卷积神经网络各输出特征图中的每个像素点，在原始输入图片上映射区域的大小。 这里可以参考一下卷积神经网络的计算过程中，5×5×1 经过 3×3×1 卷积后得到一张3×3的特征图，那么最终3×3特征图中的一个像素点所对应在5×5×1输入特征图的区域大小，（大小只取正方形区域边的大小），称之为感受野，从图上可以看出对应的感受野为3。 如果输出特征图的感受野都是一样的,但是选取的卷积核不一样（如刚刚的5×5×1的输入特征可以经过两层3×3×1的卷积核得到1的输出特征图，同样可以经过一层5×5×1的卷积核得到1的输出特征图，二者的感受野都是5）。 这里就需要考虑选取不同的卷积核所带来的计算代价，计算越少越好。 对计算量的计算步骤，以两层3×3×1为例，对于输入特征图经过第一层卷积核的计算量-&gt;首先每次计算共有9次乘法运算，卷积核总共扫描的区域数很容易得出为(x-3+1)(x-3+1),总的计算数为9×(x-2)×(x-2)。同理经过第一层卷积核的输出特征图经过第二个卷积核的计算量为9×(x-2-3+1)×(x-2-3+1)。将两个卷积核计算量相加得到总的计算量：18$x^2$-108x+180 2. 全零填充(Padding)为了保证输入特征图的尺寸不变，通过0进行填充，在输入特征图周围填充0，如原来的5×5×1经过3×3×1后仍然还是5×5×1。 填充公式(卷积输出特征图维度计算公式) $$padding = \\left{\\begin{aligned}SAME(全0填充)\\frac{入长}{步长} &amp; ,(向上取整) \\ VALID(不全0填充) \\frac{入长-核长+1}{步长}&amp;,(向上取整)\\end{aligned}\\right.$$ TF描述全0填充，用参数padding=’SAME’或padding=’VALID’表示。 3. Tensorflow2描述卷积层12345678910111213141516171819### TF描述卷积层的代码# tf.keras.layers.Conv2D(# filters=卷积核个数,# kernel_size=卷积核尺寸,#正方形写核长整数,或（核高h,核宽w）# strides = 滑动步长,#横纵向相同写步长整数，或（纵向步长h，横向步长w）,默认1# padding = &quot;same&quot; or &quot;valid&quot;,#使用全0填充是same，不使用是valid(默认)# activation=&quot;relu&quot;or&quot;sigmoid&quot;or&quot;tanh&quot;or&quot;softmax&quot;等,#如有BN此处不写# input_shape=(高，宽，通道数) #输入特征图维度，可省略# )model = tf.keras.models.Sequential([ Conv2D(6,5,padding=&#x27;valid&#x27;,activation=&#x27;sigmoid&#x27;), MaxPool2D(2,2), Conv2D(6,(5,5),padding=&#x27;valid&#x27;,activation=&#x27;sigmoid&#x27;), MaxPool2D(2,(2,2)), Conv2D(filters=6,kernel_size=(5,5),padding=&#x27;valid&#x27;,activation=&#x27;sigmoid&#x27;), MaxPool2D(pool_size=(2,2),strides=2), Flatten(), Dense(10,activation=&#x27;softmax&#x27;)]) 4. 批标准化(Batch Normalization , BN)神经网络对0附件的数据更敏感。 标准化：使数据符合0均值，1为标准差的分布批标准化：对一小批数据（batch），做标准化处理。批标准化，第K个卷积核的输出特征图(feature map)中第i个像素点。 $H_{i}^{‘k}$ = $\\frac{H_{i}^{k}-u_{batch}^{k}} {\\sigma_{batch}^{k}}$$H_{i}^{k}$：批标准化前，第K个卷积核，输出特征图中第i个像素点。$u_{batch}^{k}$：批量化前，第k个卷积核，batch张输出特征图中所有像素点平均值。 $u_{batch}^{k}$ = $\\frac{1}{m}\\displaystyle \\sum^{m}{i=1}H{i}^{k}$ $\\sigma_{batch}^{k}$：批标准化前，第k个卷积核，batch张输出特征图中所有像素点标准差。 $\\sigma_{batch}^{k}$ = $\\sqrt{\\delta+\\frac{1}{m}\\displaystyle \\sum^m_{i = 1}(H_i^k-u_{batch}^k)^2}$ 通过BN操作，将数据标准化到0均值。如下图所示： 通过标准化使得输入特征的微小变化也能使得激活函数有明显的变化，提升激活函数对输入数据的区分力。 从图中可以看出，经过标准化的Sigmoid函数，特征数据$H_i^{‘k}$集中在0附近，但是从图中可以看出，Sigmoid函数在0区域附近的曲线接近线性函数，所以这样会导致激活函数的非线性特性丧失。为了解决这个问题，需要为每个卷积核引入可训练参数$\\gamma$（缩放因子）和$\\beta$（偏移因子）,用于调整归一化的力度,优化特征数据分布的宽窄和偏移量，保证了网络的非线性表达力。调整后的数据$x_i^k$ = $\\gamma_{k}H_{i}^{‘k}+\\beta_k$。 从上面可以看出，BN层用于对数据的标准化处理，所以BN层位于卷积层之后，激活层之前。 TensorFlow描述批标准化的代码如下 12345678910&quot;&quot;&quot; TF通过tf.keras.layers.BatchhNormalization()描述BN层&quot;&quot;&quot;model = tf.keras.models.Sequential([ Conv2D(padding=&#x27;same&#x27;,kernel_size=(5,5),filters=6), BatchNormalization(),#BN层 Activation(&#x27;relu&#x27;),#激活层 MaxPool2D(pool_size=(2,2),strides=2,padding=&#x27;same&#x27;), Dropout(0.2),#droupt层]) 5. 池化(Pooling)池化用于减少特征数据量。池化包含最大值池化和均值池化。最大值池化可以提取图片纹理，均值池化可以保留背景特征。 两种池化的计算如下图所示。用池大小为2×2，步长为2的池进行处理。从图中可以看出二者的计算过程。 最大值池化 选择被池包含区域内最大的特征值作为输出结果。 均值池化 选择被池包含区域内特征值的平均值作为输出结果。 TensorFlow描述池化的代码如下 12345678910111213141516171819 &quot;&quot;&quot; tf.keras.MaxPool2D( pool_size=池化核尺寸,#正方形写核长整数，或用元组给出核的高和宽(核高h,核宽w) strides=池化步长,#步长整数，或(纵向步长h，横向步长w),默认为pool_size padding=&#x27;valid&#x27;or&#x27;same&#x27;#q全0填充是same,否则是&#x27;valid ) tf.keras.AveragePooling2D( pool_size=池化核尺寸,#正方形写核长整数，或用元组给出核的高和宽(核高h,核宽w) strides=池化步长,#步长整数，或(纵向步长h，横向步长w),默认为pool_size padding=&#x27;valid&#x27;or&#x27;same&#x27;#q全0填充是same,否则是&#x27;valid ) &quot;&quot;&quot; model = tf.keras.models.Sequential([ Conv2D(padding=&#x27;same&#x27;,kernel_size=(5,5),filters=6),#卷积层 BatchNormalization(),#BN层 Activation(&#x27;relu&#x27;),#激活层 MaxPool2D(pool_size=(2,2),strides=2,padding=&#x27;same&#x27;),#池化层 Dropout(0.2),#droupt层]) 6. 舍弃（Dropout）舍弃是为了缓解神经网络过拟合。舍弃也就是在神经网络训练的过程中，将一部分神经元按照一定概率从神经网络中暂时舍弃。神经网络使用时，被舍弃的神经元恢复链接。（也就是说在神经网络训练的过程中，一些神经元会被暂时踢出训练，等最后在加入到神经网络中。）。舍弃过程如图所示： 在训练的过程中，将一部分神经元暂时舍弃(类似于神经元死亡，也就是神经元的参数不再更新)。 TensorFlow描述舍弃（Dropout） 12345678910&quot;&quot;&quot; tf描述舍弃：tf.keras.layers.Dropout(舍弃的概率)&quot;&quot;&quot; model = tf.keras.models.Sequential([ Conv2D(padding=&#x27;same&#x27;,kernel_size=(5,5),filters=6),#卷积层 BatchNormalization(),#BN层 Activation(&#x27;relu&#x27;),#激活层 MaxPool2D(pool_size=(2,2),strides=2,padding=&#x27;same&#x27;),#池化层 Dropout(0.2),#droupt层，随机舍弃掉20%的神经元 ]) 7. 总结从上面介绍可以看出，卷积的过程就是对特征值的特征进行提取，来减少特征值的数量（卷积，池化）。通过用一个输出像素点来反映一块区域内像素点的特征。通过这样的方式有效的减少了特征值的数量。 卷积神经网络的主要组成模块,卷积层，BN层，激活层，池化层,舍弃层(dropout层)，全连接层（Fully Connected）。卷积层，BN层，激活层，池化层这四层用于对输入特征进行特征提取。 123graph LR A(卷积&amp;#40Convolutional&amp;#41) --&gt; B(批标准化&amp;#40B&amp;#41) --&gt;C(激活&amp;#40Activation&amp;#41) --&gt; D(池化&amp;#40Pooling&amp;#41) --&gt;F(舍弃层&amp;#40Dropout&amp;#41)--&gt;E(全连接&amp;#40FC&amp;#41) 卷积是什么？ 卷积就是特征提取器,就是CBAPD(D表示的是舍弃，Dropout)","tags":[{"name":"TensorFlow2","slug":"TensorFlow2","permalink":"http://example.com/tags/TensorFlow2/"},{"name":"CNN","slug":"CNN","permalink":"http://example.com/tags/CNN/"}],"categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"TensorFlow2","slug":"深度学习/TensorFlow2","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/TensorFlow2/"}]},{"title":"KMP算法","date":"2021-10-28T09:15:08.580Z","path":"wiki/算法/Leetcode/字符串/KMP/","text":"1. 问题描述 2. 解题思路 1. 问题描述今天的问题很简单，就是给定两个字符串text和pattern，让你找出在text中是否存在一个序列等于pattern,如果存在就返回true,如果不存在就返回false 。 2. 解题思路从题目描述上来看，很容易看出这题目是关于字符串匹配的问题，也就是从一段文本中，找出某个模式的全部出现位置的问题。 $\\sum{3x^n}$","tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"经典算法","slug":"算法/经典算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"}]},{"title":"48.旋转数组","date":"2021-10-28T08:36:32.058Z","path":"wiki/算法/Leetcode/链表/19.删除链表的倒数第N个结点/","text":"题目介绍给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。(进阶：你能尝试使用一趟扫描实现吗？) 示例 1： 输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 示例 2： 输入：head = [1], n = 1 输出：[] 示例 3： 输入：head = [1,2], n = 1 输出：[1] 解法思路从题目分析，我们需要删除链表的倒数第N个结点，那么我们就必须知道哪个结点是倒数第N个结点。确定一个结点在列表中的位置大概有如下几种方法。 方法一 先确定整个列表的长度，然后就能够确定结点所在的位置(可以通过堆栈或者数组存放数据元素，通过数组有利于操作)。示例代码如下： 1234567891011121314151617181920 class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ArrayList&lt;ListNode&gt; listNodes = new ArrayList&lt;&gt;() ; int len = 0 ; if(head.next==null) return null ; while(head!=null)&#123; len++ ; listNodes.add(head) ; head = head.next ; &#125; listNodes.add(head) ; if(len-n-1&lt;0 )&#123; return listNodes.get(1) ; &#125;else &#123; listNodes.get(len-n-1).next = listNodes.get(len-n).next ; return listNodes.get(0) ; &#125; &#125;&#125; 方法二 通过快慢指针法，让一个指针永远比当前指针快n个元素，那么当快指针到达末尾的时候，就能够确定倒数第N个元素。示例代码如下所示： 12345678910111213141516171819202122class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode p , q , pre ; int i = 0; p = head ; // 快指针 q = head ;// 慢指针 pre = q ; //用于记录q的前一个元素，有利于元素的删除 for(i = 0; i&lt; n ; i++) //让p比q快n个元素 p = p.next ; while(p!=null)&#123; p = p.next ; pre = q ; q = q.next ; &#125; if(pre == q)&#123; // 判断删除元素是否为头 return q.next; &#125;else&#123; pre.next = q.next ; return head ; &#125; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"}],"categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"算法/Leetcode","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/Leetcode/"},{"name":"链表","slug":"算法/Leetcode/链表","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/Leetcode/%E9%93%BE%E8%A1%A8/"}]},{"title":"3. Java控制流程","date":"2021-10-27T03:07:05.097Z","path":"wiki/JavaSE/第三章-Java基本程序结构/java controll followe/","text":"程序的控制流程一般包含，选择结构，循环结构，顺序结构。 顺序结构 顺序结构很简单，程序都具有顺序结构，依次按顺序执行。Java的语法，不允许在嵌套的两个块(块一般是指，通过{}包含的代码区域，称为块)中，声明同名变量。示例代码如下： 12345678public static void main(String[] args)&#123; int n; &#123; int k; int n; // Error can&#x27;t redefine n in inner block &#125;&#125; 选择结构选择结构也就是 if-else结构，通过条件语句来选择需要执行的语句。else与最近的if构成匹配。示例代码如下： 12345678910public static void ifElseTemplemate()&#123; int a = 1 ,b = 2 ; if(a &gt; b) System.out.println(&quot;a大于b&quot;); else if(a == b) System.out.println(&quot;a 等于 b&quot;); else System.out.println(&quot;a 小于 b&quot;);&#125; 如果有多个选择情况，可以通过Switch-case语句进行实现。代码如下: 12345678910111213141516171819public static void ifElseTemplemate()&#123; int a = 1 ,b = 2 ; if(a &gt; b) System.out.println(&quot;a大于b&quot;); else if(a == b) System.out.println(&quot;a 等于 b&quot;); else System.out.println(&quot;a 小于 b&quot;); switch (a)&#123; case 1: System.out.println(a);break ; case 2: System.out.println(a); break ; default: System.out.println(a);break ; &#125; &#125; switch语句将从与选项值相匹配的case标签处开始执行直到遇到 break 语句，或者执行到switch i吾句的结束处为止。如果没有相匹配的case标签,而有default子句,就执行这个子句。case 标签可以是： •类型为 char、byte、 short 或 int 的常量表达式。 •枚举常量。 •从 Java SE 7开始， case 标签还可以是字符串字面量。 循环结构循环执行某个代码块。一般包含for循环和while循环，do-while循环。示例代码如下： 12345678910111213141516171819202122public static void forWhileStatement()&#123; // 计算1-100的和 int sum = 0 , i = 0 ; for(i = 0 ; i &lt;= 100 ; i++)&#123; sum +=i; &#125; System.out.println(sum); i = 0 ; sum = 0 ; while(i&lt;=100)&#123; sum+=i; i++; &#125; System.out.println(sum); i = 0 ; sum = 0 ; do&#123; sum+=i; i++; &#125;while(i&lt;=100) ; System.out.println(sum); &#125; 还有一种循环方式为for-each循环，参考数组的循环。 如果想跳出循环可以使用break;，如果想要跳出某个执行过程可以用continue。Java也支持类似于goto的语法，通过break 标签来结束循环。示例代码如下： 12345678910public static void forWhileStatement()&#123; int i = 0, j ; lables: for(i = 0 ; i &lt; 10 ; i++)&#123; for(j=0;j&lt;10;j++)&#123; System.out.println(&quot;in&quot;); break lables;//跳出指定的循环 &#125; &#125; &#125;","tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://example.com/tags/JAVASE/"}],"categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/categories/JavaSE/"}]},{"title":"2. Java基本语法","date":"2021-10-26T09:21:11.459Z","path":"wiki/JavaSE/第三章-Java基本程序结构/java basic statment/","text":"1. Java注释2. Java数据类型3. Java变量4. Java运算符5. Java字符串6. Java输入流7. Java数组8. 大数值一般我们在学习一门语言的时候，总是从hello world入门，所以我们也是从hello world开始入门。 1234567public class FirstSample&#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello World!&quot;); &#125;&#125; 如果你想运行一个java程序，那么需要在类里面加上main方法，作为程序的入口让程序运行起来。格式如下。 1234567public class ClassName&#123; public static void main(String口 args) &#123; program statements &#125;&#125; 1. 注释注释一般用于书写一些关于程序或者变量，算法的说明。用于辅助他人阅读你的程序代码，增加代码的可读性。 Java的注释可以分成三种注释。 以双反斜杠标记的注释 // &nbsp;&nbsp;&nbsp;&nbsp;如下代码所示，通过//注释对变量进行解释说明。 1234567public class ClassName&#123; public static void main(String口 args) &#123; int i , j ; // i和j为临时变量 &#125;&#125; 2, 以/* TO-DO */,将一段内容进行注释。 &nbsp;&nbsp;&nbsp;&nbsp;这个注释和//注释的区别在于。//是单行注释，而/…./可以表示多行注释。示例如下。 1234567891011public class ClassName&#123; public static void main(String口 args) &#123; /* 这是多行注释。 可以注释多行。 */ int i , j ; &#125;&#125; 第三种是/** */注释，称为文档注释，用于生成程序说明文档。一般在类上或者方法上进行注释。 &nbsp;&nbsp;&nbsp;&nbsp;示例如下：通过文档注释，标明了类创建的时间。关于文档注释的其它声明，可以查阅相关资料。 1234567891011/** * @date: 2021-10-26 19:44 **/public class Java基本数据类型 &#123; public static void main(String args[]) &#123; System.out.println(&quot;hello world&quot;); // 如果想要程序在执行中间退出，则通过System.exit()退出程序 System.exit(1); System.out.println(&quot;程序中止返回&quot;); &#125;&#125; 2. 数据类型Java是一种强类型语言，Java的变量在使用前，都需要进行变量的声明。Java有8种基本数据类型。分别为4种整型，2种浮点型，1种字符型，1种布尔型(boolean). 1, 整型 整型也就是常说的整数。用于表示数据为整数。 类型 字长 取值 byte 1 -128-127 short 2 -2^15-(2^15-1) int 4 -2^31-(2^31-1) long 8 -2^63-(2^63-1) 示例代码如下： 1234567891011public static void basicType()&#123; byte a ; short b ; int c; long d ; d = 10000000L ; //通过L表示为长整型数据 c = 0x123 ; //通过0x表示为十六进制 c = 0b1001 ; //通过0b表示二进制数据 c = 010 ; //通过0开头，表示为八进制数据。 &#125; 浮点类型 浮点类型的数据也就是我们常说的小数。 类型 字长 取值 float 4 大约 ± 3.402 823 47E+38F (有效位数为 6 ~ 7 位） double 8 大约 ± 1.797 693 134 862 315 70E+308 (有效位数为 15 位) double 表示这种类型的数值精度是 float 类型的两倍（有人称之为双精度数值)。绝大部分应用程序都采用 double 类型。float 类型的数值有一个后缀 F 或 f (例如，3.14F。) 没有后缀 F 的浮点数值（如 3.14 ) 默认为double 类型。当然，也可以在浮点数值后面添加后缀 D 或 d (例如，3.14D)。 字符类型字符类型char采用unicode编码格式。char 类型的字面量值要用单引号括起来。, char 类型的值可以表示为十六进制值，其范围从 \\u0000 到 \\Uffff。例如：W2122 表示注册符号 ( ), \\u03C0 表示希腊字母 it。在Java中，char类型占用两个字节（采用16位的Unicode字符集）。示例代码如下，用于输出显示两个特殊的字符。 1234567public static void basicType()&#123; char g = &#x27;\\u2122&#x27;; //注册符号 Tm System.out.println(g); g = &#x27;\\u03C0&#x27; ; System.out.println(g); &#125; Boolean类型boolean(布尔)类型一般有两个值:true和false,用来判定逻辑条件。在Java中整型不能替代布尔类型(这在C/c++却是可以的。) 对于数据类型，我们可以在不同的数据类型之间进行转化(强制类型转换)。 3. 变量变量的声明在前面数据类型也可以看到。一般格式为：数据类型 变量名; 变量名的命名格式 变量名必须是一个以字母开头并由字母或数字构成的序列。需要注意，与大多数程序设计语言相比，Java 中“ 字母” 和“ 数字” 的范围更大。字母包括“A’Z”、“az”、或在某种语言中表示字母的任何 Unicode 字符。 变量的初始化和赋值操作 初始化一般是在变量的声明时候，给变量一个初始值(这是一个好的编程习惯)。变量的赋值一般通过=对变量进行赋值操作。示例代码如下所示。 1234public static void bytes()&#123; int a = 30 , b ; //对变量进行初始化 b = 20 ; //对变量进行赋值 &#125; 常量 常量也就是一直不变的量，只能被赋值一次。一般我们通过final来指示常量(一般用纯大写作为变量名，下划线进行分割)。示例代码如下: 12345public static void bytes()&#123; int a = 30 , b ; //对变量进行初始化 b = 20 ; //对变量进行赋值 final double PI = 3.1415962 ; &#125; 对于类常量，一般是作为类的成员变量，并且访问修饰符为static。可以理解为，加了sttic外部就能直接引用该变量。 123public class test&#123; public static final double PI = 3.1415926 ; &#125; 4. 运算符运算符一般就是加减乘除这些运算符，以及一些特殊操作。+,-,*./,%(取余)。 对于取余有一个技巧，保证不取负数。通过（(position +adjustment) % 12 + 12) % 12。公式进行取余操作，就保证了余数在0-11之间，不出现负数的情况。 还有一些运算符属于双目运算符，如 +=,-=,*=…。这写运算符和前面的运算符类似只不过，多了赋值操作。a += b; 等价于 a = a+b 。可以编程进行验证。 自增运算符：++和–, x++也就等价于 x += 1; 关系运算符：主要是用于比较数值的大小，如&gt;=,&lt;=,&gt;,&lt;，!= 等关系运算。简单的例子就是：a&gt;b ,比较a和b的大小。 逻辑运算符：也就是与，或，非三个运算。&amp;&amp; 表示与， || 表示或，！表示非。一般用于条件表达式表示多条件的情况。如表示 a&gt; b 且 a&gt; c的情况,可以写成 a&gt;b &amp;&amp; a&gt;c 三元操作符?: 用法 a&gt;b?a:b 。如果a&gt;b则执行a,反之执行b 位运算符：&amp;,|,^（异或）,~(非)。一般用于对整数各个位(二进制)进行位运算。&gt;&gt;和&lt;&lt;运算符，用于将数据左移和右移。需要建立位模式来完成位掩码时， 这两个运算符会很方便。&gt;&gt;&gt;会用0填充高位，而&gt;&gt;则是用符号位填充高位。移位运算符的右操作数要完成模 32 的运算（除非左操作数是 long 类型， 在这种情况下需要对右操作數模 64 )。例如， 1 «35 的值等同于 1 «3 或 8。也就是最多不会超过int类型，如果超过那么就等同于模32后再右移动。 运算符优先级运算符优先级也就是运算符的优先执行顺序。如果不确定优先级，我们可以用括号包含起来。运算符优先级 单目运算(!,~,++,new,强制类型转换) &gt; (*，/,%) &gt; (+,-) &gt; (&lt;&lt;, &gt;&gt; , &gt;&gt;&gt;) &gt; (&lt; , &gt; , &gt;= , instanceof) &gt; (==,!=) &gt; (&amp;) &gt; (^) &gt;(|) &gt; (&amp;&amp;) &gt; (||) &gt; (?) &gt; (=,+=,-=……)。 枚举类型通过enum 进行枚举类型的声明，包括有限个命名的值。示例代码如下: 1234567891011121314151617181920public enum 枚举类型 &#123; SMALL(1,&quot;小号&quot;), MEDIUM(2,&quot;中号&quot;),; private int code ; private String message ; 枚举类型(int code , String message)&#123; this.code = code ; this.message = message ; &#125; public static int getCode(String define)&#123; // 返回枚举类型的code,根据Message return 枚举类型.valueOf(define).code ; &#125; public static String getMessage(String define)&#123; return 枚举类型.valueOf(define).message ; &#125;&#125; 5. 字符串字符串也就是一串字符，通常用””包含。一般我们使用String表示字符类型。示例: String str = “hello world” ; , 字串则是字符串的一串连续的字符，如”worl”就是str的一个字串。如果需要拼接字符，可以通过+号进行拼接。如果需要拼接多个，可以通过定界符(，)分割，然后用静态join方法拼接。如:String str = String.join(“h”,”ello”,”w”,”rold”) ; Java如果要修改某个字符，一般需要创建新的字符常量对象。Java的String类似于指针，指向字串常量在存储池（堆）的相应位置。如果指向相同的字符常量， 则这两个变量是相同的。可以运行如下代码: 123456789public static void byteString()&#123; String a = &quot;123&quot;; String b = &quot;123&quot; ; String c = new String(&quot;123&quot;) ; System.out.println(a == b); System.out.println(a.equals(b)); System.out.println(a == c); System.out.println(a.equals(c));&#125; 上面的代码中两个变量 a == b 比较的是两个变量是否相同(类比于比较地址是否相同)，a.equeals(b)检测的是两个字符串是否相等。检查一个字符串既不是 null 也不为空串，这种情况下就需要使用以下条件：if (str != null &amp;&amp; str.length()!= 0),先检测变量是否为空，在判断长度是否为空。 StringBuffer和StringBuilder的区别 StringBuilder支持单线程，StringBuffer支持多线程。就效率而言,StringBuilder快于StringBuffer，所以在单线程程序中采用StringBuilder较好，多线程程序采用StringBuffer。 6. 输入输出流java输入输出流，通过Scanner对象和标准输入流（System.in）相关联进行获取。 1234567891011 public static void ioStream()&#123; // Java构建输入流，通过Scanner对象和标准输入流Sytem.in对象关联。 Scanner in = new Scanner(System.in) ; System.out.print(&quot;输入字符：&quot;); String text = in.nextLine() ; System.out.println(text);&#125; 因为输入是可见的， 所以 Scanner 类不适用于从控制台读取密码。Java SE 6 特别引入了 Console 类实现这个目的。要想读取一个密码， 可以采用下列代码： Console cons = System.console(); String username = cons.readLine(&quot;User name: &quot;)； char [] passwd = cons.readPassword(&quot;Password:&quot;); 为了安全起见， 返回的密码存放在一维字符数组中， 而不是字符串中。在对密码进行处理之后，应该马上用一个填充值覆盖数组元素（数组处理将在 3.10 节介绍）。采用 Console 对象处理输入不如采用 Scanner 方便。每次只能读取一行输入， 而没有能够读取一个单词或一个数值的方法。 格式化输出最简单的方法是采用C语言的方法进行输出System.printf就可以通过C语言的printf输出方式进行输出。 文件输入与输出通过File对象构建Scanner对象进行文件的读取，通过PrintWriter进行文件的输出。示例代码如下所： 12345678910111213141516171819public static void fileIO() throws IOException &#123; //文件输入流 , get路径为文件路径 Scanner in = new Scanner(Paths.get(&quot;javase/src/main/java/Java核心技术/第三章Java的基本程序设计/myfile.txt&quot;),&quot;UTF-8&quot;) ; while(in.hasNext())&#123; System.out.println(in.next()); &#125; in.close(); System.out.println(); in = new Scanner(new File(&quot;javase/src/main/java/Java核心技术/第三章Java的基本程序设计/myfile.txt&quot;)) ; while(in.hasNextLine())&#123; System.out.println(in.nextLine()); &#125; in.close(); //文件输出流，路径填写文件路径 PrintWriter out = new PrintWriter(new File(&quot;javase/src/main/java/Java核心技术/第三章Java的基本程序设计/myfile.txt&quot;) ) ; out.write(&quot;this is a test two&quot;); out.close(); &#125; 7.数组数组存储了一串连续地址的元素，通过元素下标可以访问到数组元素。数组有如下几种声明方式。 int[] a ; int[] a = new int[100] ; int a[] ; int[] a = &#123;1,2,3,4,5&#125; ; new int[] &#123;17,19,23,29&#125; ; //匿名数组 数组的迭代方法 for，while循环通过遍历数组下标来遍历数组的元素 for-each循环通过for-each遍历数组的每一个元素。for-each的一般形式为：for (variable : collection) statement。如果要遍历集合，那么对应的集合必须是数组或者实现了Iterable接口的类对象。 123456789101112public static void array()&#123; int i ; int[] a = &#123;1,2,3,4,5&#125; ; //for循环遍历 for(i = 0 ; i &lt; a.length ; i++)&#123; System.out.println(a[i]); &#125; //for-each循环 for(int temp : a)&#123; System.out.println(temp); &#125;&#125; 打印数组通过Arrays类的toString方法，可以打印一个数组。 1234567891011121314public static void array()&#123; int i ; int[] a = &#123;1,2,3,4,5&#125; ; //for循环遍历 for(i = 0 ; i &lt; a.length ; i++)&#123; System.out.println(a[i]); &#125; //for-each循环 for(int temp : a)&#123; System.out.println(temp); &#125; //打印数组 System.out.println(Arrays.toString(a) );; &#125; 数组拷贝简单的数组赋值，只是浅拷贝，二者指向的还是一个堆栈空间。如果需要进行数值拷贝，则通过Arrays.copyOf进行数据的拷贝。 123456int[] a = &#123;1,2,3,4&#125; ; int[] b ; b = a ; //这是简单的赋值，浅拷贝b[1] = 10 ;// 则a[1]也变为10 b = Arrays.copyOf(a,a.length) ; //b[1] = 2 ; //则a[1] 还是为10并不影响。 Arrays包含许多关于数组的操作,包括数组的打印，数组的拷贝，排序等功能。 数组排序通过Arrays.sort（a），可以对数组a进行排序（无返回值）。该排序方法使用了优化的快速排序算法(可以阅读源码，理解排序方法)。 数组填充通过Arrays.fill（a,value），用数据填充数组。 多维数组多维数组的初始化方法： double[][] balances ; balances = new double[NYEARS] [NRATES]; int[][] magicSquare = { {16, 3, 2, 13}， {5, 10, 11, 8}, (9, 6, 7, 12}, {4, 15, 14, 1} };多维数组的迭代for循环迭代，只需要通过下标进行迭代即可。for-each迭代格式如下： for (doubleG row : a) for (double value : row) do something with value 多维数组的打印通过Arrays.deepToString进行多为数组的打印。 不规则的数组不规则数组一般是多维的维数可能不一致。如果需要创建多维数组，必须先分配具有所含行数的数组，然后再分配行数组的长度。 8. 大数值如果基本的整数和浮点数精度不能够满足需求， 那么可以使用jaVa.math 包中的两个很有用的类：Biglnteger 和 BigDecimaL 这两个类可以处理包含任意长度数字序列的数值。Biglnteger 类实现了任意精度的整数运算， BigDecimal 实现了任意精度的浮点数运算。 123456public static void bigData()&#123; //通过BigInter和BigDecimal可以实现大数的运算,需要将数据转化为大数对象，再进行运算。 BigInteger a = BigInteger.valueOf(1) ; a = a.add(BigInteger.valueOf(Long.MAX_VALUE)); System.out.println(a.toString());&#125;","tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://example.com/tags/JAVASE/"}],"categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/categories/JavaSE/"}]},{"title":"1. Java介绍","date":"2021-10-26T06:59:14.834Z","path":"wiki/JavaSE/第三章-Java基本程序结构/java introduce/","text":"1. Java语言的特性2. JAVA8新特性1. Java语言的特性1 ) 简单性 Java语法相对于C++而言，少了很多复杂与语法，如头文件，指针运算，结构，联合，操作符重载，虚基类等。 2 ) 面向对象 面向对象是一种程序设计技术，与之相对应的技术为面向过程。面向对象的程序设计在设计方法上着重于事物的属性和行为的设计，而不是具体的过程上进行设计。 3 ) 分布式 分布式也就是将一个任务分到多个服务器进行解决。Java提供了丰富的例程库，用于处理TCP/IP协议。 4 ) 健壮性 Java在对程序错误的检测包括，编译时错误和运行时错误，消除了容易出错的情况。并且对于Java采用的指针模型，可以消除重写内存和损坏数据的可能性。 5 ) 安全性 从一开始，Java 就设计成能够防范各种攻击，其中包括： •运行时堆栈溢出。 如蠕虫和病毒常用的攻击手段。 •破坏自己的进程空间之外的内存。 •未经授权读写文件 Java 浏览器插件不再信任远程代码，除非代码有数字签名而且用户同意执行这个代码 6 ) 体系结构中立 编译器生成字节码文件(类似于用一个新语言进行解释),只要有java运行环境，就能够在计算机上运行程序。虚拟机可以将执行最频繁的字节码序列翻译成机器码(即时编译)，加快运行速度。(字节码的解释程序由C语言进行实现。) Java源程序-编译器&gt;生成字节码文件(出现频繁的字节码序列会被翻译成机器码)-java虚拟机&gt;运行字节码文件，运行Java程序。 7 ) 可移植性 Java中的int永远为32位的整数，与平台无关。字符数据通过Unicode格式存储。 8 ) 解释型 Java 解释器可以在任何移植了解释器的机器上执行 Java 字节码。Java是解释型语言。 9 ) 高性能 即时编译器可以监控经常执行哪些代码并优化这些代码以提高速度。更为复杂的优化是消除函数调用（即“ 内联”）。即时编译器知道哪些类已经加载。基于当前加载的类集， 如果特定的函数不会被覆盖，就可以使用内联。必要时，还可以撤销优化。 10 ) 多线程 多线程可以带来更好的交互响应和实时行为。 11 ) 动态性 从各种角度看， Java 与 C 或 C++ 相比更加具有动态性。它能够适应不断发展的环境库中可以自由地添加新方法和实例变量， 而对客户端却没有任何影响。在Java 中找出运行时类型信息十分简单。当需要将某些代码添加到正在运行的程序中时， 动态性将是一个非常重要的特性。 总结Java特性：Java采用字节码文件作为编译后的文件，通过JVM生成字节码文件，并且对于常用出现的字节码序列会转化为机器码(即时编译器))，加快程序编译运行速度。并且Java与平台无关，拥有丰富的库，能够支持分布式，动态式，多线程。并且很安全。 2. JAVA8新特性Lambda表达式，包含默认方法的接口，流和时间/日期库 JAVA开发环境 一些Java环境术语 JDK（Java Development Kit）: 编写Java程序的程序员使用的软件。在Java 1.2-1.4版本被称为Java SDK (软件开发包,Software Development Kit)。我们现在经常看到关于JDK1.8,以及Java8，那么二者之间是什么关系呢？Java早期发布版本是直接增加小数点后面的数值。例如1.3，1.4，1.5等。而在2006年后版本号进行简化，开始次啊用Java SE6,Java SE 7 ,Java SE 8 作为版本号，这就是我们常熟悉的版本号。但是对于其内部的版本号，分别是1.6.0，1.7.0，1.8.0。对于版本号为1.8.0_31（Java SE 8u31）表示的是对Java SE 8 的第31次修改后的版本。 JRE（Java Runtime Enviroment）:运行Java程序的用户使用的软件。 SE(Standard Edition): 用于桌面或简单服务器应用的Java平台。 EE(Enterprise Edition):用于复杂服务器应用的Java平台。 ME(Micro Edition):用于手机和其它小型设备的Java平台。 命令行操作 通过命令行命令查看Java版本号 1javac -version 通过命令行运行Java程序 通过javac编译java源程序，通过java程序启动java虚拟机，虚拟机执行编译器放在class文件的字节码。 12javac xxxx.javajava xxxx","tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://example.com/tags/JAVASE/"}],"categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/categories/JavaSE/"}]},{"title":"48.旋转数组","date":"2021-10-26T04:21:45.745Z","path":"wiki/算法/Leetcode/数组/48.旋转数组/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445// 通过辅助数组进行实现 public void rotate(int[][] matrix) &#123; int[][] totataMatrix = new int[matrix.length][matrix.length] ; int i = 0 , j = 0 , len = matrix.length; for(i = 0 ; i &lt; len ; i++)&#123; for(j = 0 ; j &lt; len ; j++)&#123; totataMatrix[j][len-i-1] = matrix[i][j]; &#125; &#125; for(i = 0 ; i &lt; len ; i++)&#123; for(j = 0 ; j &lt; len ; j++)&#123; matrix[i][j] = totataMatrix[i][j]; &#125; &#125; &#125; // 如果需要原地旋转，那就必须需要考虑数组下标之间的关系，然后进行旋转操作 public void rotateTwo(int[][] matrix) &#123; int i = 0 , j = 0 , len = matrix.length; for(i = 0 ; i &lt; len / 2; i++)&#123; for(j = 0 ; j &lt; (len+1) /2 ; j++)&#123; int temp = matrix[i][j] ; matrix[i][j] = matrix[len-j-1][i] ; matrix[len-j-1][i] = matrix[len-i-1][len-j-1] ; matrix[len-i-1][len-j-1] = matrix[j][len-i-1] ; matrix[j][len-i-1] = temp ; &#125; &#125; &#125; // 数组选择90度又可以转换为数组翻转问题，首先进行上下翻转，然后再根据主对角线进行翻转。 public void rotateThree(int[][] matrix) &#123; int i = 0 , j = 0 , len = matrix.length; for(i = 0 ; i &lt; len / 2; i++)&#123; for(j = 0 ; j &lt; (len+1) /2 ; j++)&#123; int temp = matrix[i][j] ; matrix[i][j] = matrix[len-j-1][i] ; matrix[len-j-1][i] = matrix[len-i-1][len-j-1] ; matrix[len-i-1][len-j-1] = matrix[j][len-i-1] ; matrix[j][len-i-1] = temp ; &#125; &#125; &#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"}],"categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"算法/Leetcode","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/Leetcode/"},{"name":"数组","slug":"算法/Leetcode/数组","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"}]},{"title":"36.有效数独","date":"2021-10-26T02:09:42.061Z","path":"wiki/算法/Leetcode/数组/36.有效数独/","text":"1234567891011121314151617181920212223242526272829303132333435public boolean isValidSudokuTwo(char[][] board) &#123; int i = 0 , j = 0 , k = 0 , l = 0 , idx ; HashMap&lt;Integer, HashSet&lt;Character&gt;&gt; area = new HashMap&lt;Integer, HashSet&lt;Character&gt;&gt;() ; //判断行列是否符合数独条件 for(i = 0 ; i &lt; board.length ; i++)&#123; HashMap&lt;Character, Integer&gt; row = new HashMap&lt;Character, Integer&gt;() ; HashMap&lt;Character, Integer&gt; col = new HashMap&lt;Character, Integer&gt;() ; for(j = 0 ; j &lt; board.length ; j++)&#123; if(board[i][j] != &#x27;.&#x27;)&#123; if(row.containsKey(board[i][j]))&#123; return false; &#125;else&#123; row.put(board[i][j],1) ; &#125; &#125; if(board[j][i] != &#x27;.&#x27;)&#123; if(col.containsKey(board[j][i]))&#123; return false; &#125;else&#123; col.put(board[j][i],1) ; &#125; &#125; idx = (i/3)*3 + j/3 ; if(!area.containsKey(idx))&#123; area.put(idx,new HashSet&lt;Character&gt;()) ; &#125; if(area.get(idx).contains(board[i][j]))&#123; return false; &#125;else&#123; area.get(idx).add(board[i][j]) ; &#125; &#125; &#125; return true ; &#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"}],"categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"算法/Leetcode","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/Leetcode/"},{"name":"数组","slug":"算法/Leetcode/数组","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"}]},{"title":"Git常见的问题及解决方案","date":"2021-10-25T11:43:34.168Z","path":"wiki/程序技术/Git/问题/","text":"1. 当能够正常运行的项目突然无法运行，出现找不到资源文件错误的时候。首先，能运行就标明项目本身并没有问题。对于资源文件找不到，可能就和系统的缓存加载有关。 所以这个时候，可以对项目的依赖文件进行重新的审查，如果没有问题，再查看依赖是否有问题。对于Maven项目的依赖问题，可以重新clean被依赖的工程，再重新install被依赖的工程。重新加载资源文件。 2. git提交代码到Github时候，出现fatal: unable to access ‘https://github.com/zzcpage/zzcpage.github.io.git/&#39;: OpenSSL SSL_read: Connection was reset, errno 10054产生的原因：一般是这是因为服务器的SSL证书没有经过第三方机构的签署，所以才报错。 解决方法：解除ssl验证后，再次git即可。 通过git config –global http.sslVerify “false”命令进行解除SSL验证，解除完之后，再次Git即可提交成功。","tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"},{"name":"Bug解决方案","slug":"Bug解决方案","permalink":"http://example.com/tags/Bug%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}],"categories":[{"name":"程序技术","slug":"程序技术","permalink":"http://example.com/categories/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/"},{"name":"Git","slug":"程序技术/Git","permalink":"http://example.com/categories/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/Git/"}]},{"title":"Hello World","date":"2021-10-25T08:23:20.423Z","path":"wiki/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[],"categories":[]}]}