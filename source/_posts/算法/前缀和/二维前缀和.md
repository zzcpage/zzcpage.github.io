---
title: 前缀和-二维前缀和
categories:
    - 算法
tags:
    - 算法
---

二维前缀和解决的是二维矩阵中的矩形区域求和问题。

二维前缀和数组中的每一个格子记录的是「以当前位置为区域的右下角（区域左上角恒定为原数组的左上角）的区域和」

![二维前缀和](/images/二维前缀和.png)

简单的理解二维矩阵的前缀和，就是在一维的基础上，减去一些重复部分的矩阵。通常我们会对二维前缀和矩阵增加哨兵进行处理，这样就不用处理 i = 0 的情况。所以在计算前缀和的时候，从 i = 1 开始处理。

简单推理一下二维前缀和的计算公式。以sum(i,j)为例。sum(i,j)是计算（i,j）与(0,0)围成的区域大小。而已知的只有比(i,j)更小坐标围成区域的和，以及position(i,j)的值。如果要计算sum(i,j),可以通过绘图得出如下等式：
sum(i,j) = sum(i-1,j) + sum(i,j-1) - sum(i-1,j-1) + position(i,j) 。

所以在计算二维前缀和的时候，就可以根据上面的等式进行推导。

示例代码如下所示：
```java

class NumMatrix {
    int[][] sum;
    public NumMatrix(int[][] matrix) {
        int n = matrix.length, m = n == 0 ? 0 : matrix[0].length;
        // 与「一维前缀和」一样，前缀和数组下标从 1 开始，因此设定矩阵形状为 [n + 1][m + 1]（模板部分）
        sum = new int[n + 1][m + 1];
        // 预处理除前缀和数组（模板部分）
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + matrix[i - 1][j - 1];
            }
        }
    }

    public int sumRegion(int x1, int y1, int x2, int y2) {
        // 求某一段区域和 [i, j] 的模板是 sum[x2][y2] - sum[x1 - 1][y2] - sum[x2][y1 - 1] + sum[x1 - 1][y1 - 1];（模板部分）
        // 但由于我们源数组下标从 0 开始，因此要在模板的基础上进行 + 1
        x1++; y1++; x2++; y2++;
        return sum[x2][y2] - sum[x1 - 1][y2] - sum[x2][y1 - 1] + sum[x1 - 1][y1 - 1];
    }
}
```