---
title: 48.旋转数组
categories: 
    - 算法
    - Leetcode
    - 链表
tags: 
    - 算法
    - 链表
---
### 题目介绍

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。(进阶：你能尝试使用一趟扫描实现吗？)

>示例 1：

    输入：head = [1,2,3,4,5], n = 2
    输出：[1,2,3,5]

>示例 2：

    输入：head = [1], n = 1
    输出：[]

>示例 3：

    输入：head = [1,2], n = 1
    输出：[1]

### 解法思路
从题目分析，我们需要删除链表的倒数第N个结点，那么我们就必须知道哪个结点是倒数第N个结点。确定一个结点在列表中的位置大概有如下几种方法。
>方法一

先确定整个列表的长度，然后就能够确定结点所在的位置(可以通过堆栈或者数组存放数据元素，通过数组有利于操作)。示例代码如下：

```java
    class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ArrayList<ListNode> listNodes = new ArrayList<>()  ;
        int len = 0 ;
        if(head.next==null)
            return null ;
        while(head!=null){
            len++ ;
            listNodes.add(head) ;
            head = head.next ;
        }
        listNodes.add(head) ; 
        if(len-n-1<0 ){
            return listNodes.get(1) ;
        }else {
            listNodes.get(len-n-1).next = listNodes.get(len-n).next ;
            return listNodes.get(0) ;
        }
    }
}
```

>方法二

通过快慢指针法，让一个指针永远比当前指针快n个元素，那么当快指针到达末尾的时候，就能够确定倒数第N个元素。示例代码如下所示：

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode p , q , pre ;
        int i = 0;
        p = head ; // 快指针
        q = head ;// 慢指针
        pre = q ; //用于记录q的前一个元素，有利于元素的删除
        for(i = 0; i< n ; i++) //让p比q快n个元素
            p = p.next ;
        while(p!=null){
            p = p.next ;
            pre = q ;
            q = q.next ;
        }
        if(pre == q){       // 判断删除元素是否为头
            return q.next;
        }else{
            pre.next = q.next ;
            return head ; 
        }
    }
}
```
