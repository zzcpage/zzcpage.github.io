---
title: 区间问题-树状数组
categories:
    - 算法
    - 区间问题
    - 树状数组
tags:
    - 算法
---


树状数组和线段树解决的问题一般都是对数据的区间操作，也就是求一段区间内的数据操作。

树状数组比较适合于单点修改的问题。线段树则使用较广。

#### lowbit的含义

lowbit的定义如下所示，通过lowbit可以找到x的二进制数的最后一个1所表示的2进制。lowbit(x) = $$2^k$$

>注意: x不能等于0, 否则会进入死循环, 所以树状数组通常使用的下标会执行+1操作
```java
private int lowbit(int x) {
    return x & (-x);
}

```

#### 区间求和问题

  区间求和可以通过计算前缀和来计算区间【l,r】的和。sum(l,r) = preSum(r) - preSum(l-1) ; 所以区间求和问题转化为求索引x的前缀和问题。

<h4>定义树状数组</h4>

​    通过如下图片可以了解树状数组如何存储数据。假设树状数组为sums，我们可以通过sums来计算前缀和，例如求preSum[3] = sums[4] + sums[6] + sums[7].

​     很容易定义sums的计算公式sums[i] =$\sum_{j=i-lowbit(i)+1}^{n=i}a[j]$，

![image-20220404232156224](/images/algorithm/image-20220404232156224.png)

   <h4>更新\查询树状数组</h4>

  	更新树状数组的时候，通过x+=lowbit(x)来寻找被影响的数组下标。（规律在于+1，+10，+100依次类推，通过这个规律可以看见其中的一些规律）。

![image-20220404234254953](/images/algorithm/image-20220404234254953.png)

​	查询树状数组的时候，使用x-=lowBit(x)来寻找小于x的下一区间。也就是查询前缀数组和的时候，通过x -= lowBit(x)。由于sums[i] = $\sum_{j=i-lowbit(i)+1}^{n=i}a[j]$,则可以看出，对于当前x,sums[x]计算的是，a[x-lowbit(i)+1] -> a[x] 的和。如果要计算a[0] ->a[x]区间内的和。那么还需要计算a[0]->a[x-lowbit(i)]的值。而$sums[x-lowbtt(i)] = \sum_{j=i-lowbit(x-lowbit)+1}^{n=i}a[j]$,不断重复这个操作，就可以找到所有的前缀和。直到x<1则查询完毕。

![image-20220404235223429](/images/algorithm/image-20220404235223429.png)

<h4>实现代码</h4>

```java
class NmArray{
    int[] sums ; //累加和
    int[] nums ;//更新后的数组
    public NumArray(int[] nums){
        //原数组长度+1,避免因为x=0,lowbit(x)进入死循环。
    	sums = new int[nums.length + 1];
        this.nums = nums ;
        for(int i = 0 ; i < nums.length ; i++){
            //初始化，累加数组
            insert(i,nums[i]) ; 
        }
    }
    /*
    	lowBit用于返回最后一位1所在的位置。
    */
    public int lowBit(int x){
        return x&(-x);
    }
    
    /*
    用于初始化树状数组，很简单的方法，只需要找到所有的 x ,更新值即可。
    x = x + lowbit(x)进行更新。
    */
    public void insert(int i , int val){
        //一直寻找 x += lowbit(i) 
        int x = i + 1 ; //新数组从1开始
      	while(x < sums.length){
            sums[x] = sums[x] + val ;
            x += lowBit(x) ; 
        }
    }
    
    //更新数组以及累加和
    //只需要在插入的基础上，进行修改即可
    public void update(int index , int val){
        int change = this.nums[index] - val ; 
        int x = index + 1 ; 
        while(x < sums.length){
            sums[x] = sums[x] - change ; 
            x = x + lowBit(x) ;
        }
    }
    
    //计算[left,right]的和
    public int sumRange(int left , int right){
        return query(right+1) - query(left) ; //pre[right]-pre[left-1]计算的是[left,right]的区间和
    }
    /*查询树状数组*/
    public int query(int x){
        //查询只需要向前计算各个位置的和即可
        int sum = 0 ;
        while(x >= 1){
            sum += sums[x] ; 
            x = x - lowBit(x) ; 
        }
        return sum; 
    }
    
}


```



