---
title: 区间问题-线段树
categories:
    - 算法
    - 区间问题
    - 线段树
tags:
    - 算法
---


<h4>线段树</h4>

​	线段树常用于维护区间信息，可以在O（lon N ）的时间复杂度内实现单点修改，区间修改，区间查询(区间求和，求区间最大值，求区间最小值)等操作。

<h4>线段树的基本结构与建树</h4>

​	线段树将每个长度不为1 的区间划分成左右两个区间递归求解，把整个线段划分为一个树形结构，通过合并左右两区间信息来求得该区间的信息。这种数据结构可以方便的进行大部分的区间操作。

​	以数组a={10,11,12,13,14}为例，转化为线段树，做法如下所示：设线段树的根节点编号为 1，用数组 $d$来保存我们的线段树$d_i$， 用来保存线段树上编号为$i$ 的节点的值（这里每个节点所维护的值就是这个节点所表示的区间总和）。

​	从下图可以看出，线段树实际上类似于一个数组二叉树，即根节点表示[l,r]的区间和，左孩子表示[l,mid]的区间和，右孩子表示[mid+1,right]的区间和。不断重复上述操作，就可以构成一个线段树。并且对于$d_i$的左孩子等于$d_{2i}$，右孩子等于$d_{2i+1}$。

​	假设$d_i$表示的区间是[s,t]，则左孩子表示的区间是[s,$\frac{s+t}{2}$]，右孩子表示的区间是[$\frac{s+t}{2}$+1,t]

![image-20220404232156224](/images/algorithm/image-20220405121030619.png)

 
<h5>建树方法</h5>

​	设当前的根节点为 p，如果根节点管辖的区间长度已经是1 ，则可以直接根据a数组上相应位置的值初始化该节点。否则我们将该区间从中点处分割为两个子区间，分别进入左右子节点递归建树，最后合并两个子节点的信息。

```java
public void build(int s , int t , int p){
    if(s == t){
        d[p] = a[s] ; //如果s==t,则直接是该位置的值
    	return ; 
    }
    int mid = s + ((t-s) >> 1) ; //计算中间坐标
    //构建左右树 , 根据前面的性质，根节点和左右孩子坐标的关系是两倍的关系
    build(s,mid,2*p) ;
    build(mid+1,t,2*p+1) ; 
    d[p] = d[2 * p] + d[2 * p + 1]  ;//通过左右孩子，确定根节点
    
}
```

<h4>查询方法</h4>

区间查询，比如求区间[l,r]的总和、求区间最大值/最小值等操作。

![[image-20220405205229810](/images/algorithm/image-20220405205229810.png)

 

查询区间和的关键在于，确定有哪几个参与运算。例如求[1-5]，只需要返回d[1]即可，而求d[2-5]则需要返回d[9]+d[5]+d[3] ,最多可以拆分成log(n)个极大区间。

```java
//l和r代表需要求的区间
//s和t代表d[p]所表示的区间
int getSum(int l , int r , int s , int t , int p){
	//如果[s,t]的区间在[l,r]之间的话，则返回dp[i]
	if(s >= l && t <= r){
		return dp[p] ; //直接返回当前值
	}
    int mid =  s + ((t-s) >> 1) , sum = 0 ; 
    //进一步缩小范围
    if(l <= mid){
        sum += getSum(l,r,s,mid,2*p) ; 
    }
    
    if(r > mid){
        sum += getSum(l,r,m+1,t,2*p+1) ; 
    }
    return sum ; 
    
}
```

<h4>线段树的区间修改和懒惰标记</h4>

​	如果要修改区间[l,r]的元素，则需要把所有包含区间[l,r]的节点遍历一遍，修改一遍，这样做很费时间，通常我们会引入一个懒惰标记。

​	懒惰标记的作用：延迟对节点信息的修改，进而减少不必要的操作次数。我们通过懒惰标记来标明节点是否被更改，但是不更新该节点的子节点的信息，实质性的修改在下次访问带有标记的节点的时候才进行。

​	如图下所示：增加了数组t，用于作为元素的懒惰标记。


![[image-20220405220242365](/images/algorithm/image-20220405220242365.png)


​		假如给区间[3,5]的每个数都加上5，那么只需要找到[3,5]的极大区间，可以得出包含[3,5]的极大区间[3,3],[4,5] 。下面给出的是区间加上某个值的代码，如果要改成区间减去某个值，只需要把 += 改为 -= ， 如果要改成区间等于某个值，只需要把 += 改成 = 即可，以此类比。

```java
public void update(int l , int r , int c , int s , int t, int p){
    // [l, r] 为修改区间, c 为被修改的元素的变化量, [s, t] 为当前节点包含的区间, p
  // 为当前节点的编号
  if (l <= s && t <= r) {
    d[p] += (t - s + 1) * c, b[p] += c;
    return;
  }  // 当前区间为修改区间的子集时直接修改当前节点的值,然后打标记,结束修改
  int m = s + ((t - s) >> 1);
  if (b[p] != 0  && s != t) {
    // 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值
    d[p * 2] += b[p] * (m - s + 1), d[p * 2 + 1] += b[p] * (t - m);
    b[p * 2] += b[p], b[p * 2 + 1] += b[p];  // 将标记下传给子节点
    b[p] = 0;                                // 清空当前节点的标记
  }
  if (l <= m) update(l, r, c, s, m, p * 2); //继续寻找极大区间间
  if (r > m) update(l, r, c, m + 1, t, p * 2 + 1); // 继续寻找极大区间
  d[p] = d[p * 2] + d[p * 2 + 1];
}
```

<h4>区间查询(区间求和)</h4>

```java
public int getSum(int l , int r , int s, int t , int p){
     // 当前区间为询问区间的子集时直接返回当前区间的和
    if(l <= s && r >= t){
        return d[p] ; 
    }
    
    int m = s + ((t - s) >> 1) ; 
    //检查惰性标记
    if(b[p] != 0){
        //如果当前节点懒标记非空，则更新当前节点的两个子节点的值和懒惰标记
        d[p * 2] += b[p] * (m - s + 1) ,d[p * 2 + 1] += b[p] * (t - m) ;
        b[p * 2] += b[p],b[p * 2 + 1] += b[p] ;
        b[p] = 0 ;
    }
    int sum = 0 ;
    if( l <= m){
        sum = getSum(l,r,s,m,p * 2);
    }
    if(r > m){
        sum += getSum(l,r,m+1,t,p * 2 + 1)
    }
    return sum ; 
}
```

