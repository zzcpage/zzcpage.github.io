#### 统计x中二进制为0的个数

如果要统计x二进制为0的个数，有两种方法可以解决，一种是通过求每个位置的二进制，如果是1则加1 。另一种通过lowBit方法，只要x不为0就加1。

>方法1

方法1的局限性在于，需要确定x的范围,这里x的位数最多32位

```java
public int bitCount(int x){
    int count = 0  ; 
    int temp = 1 ; 
    for(int i = 0 ; i < 32 ; i++){
        if((x & temp) != 0){
            count++;
        }
        temp = temp << 1 ; 
    }
    return count ;
}
```

>方法2

lowBit函数的作用是返回x末尾为1的位置。例如 4(100),则lowBit(4)=3 ，这样只需要不断取出末尾为1，直到x为0，结束操作
```java
public int lowBit(int x){
    return x & (-x) ; 
}

public int bitCount(int x){
    int count = 0 ; 
    while(x != 0){
        count++ ;
        x = x >> lowBit(x) ; 
    }
    return count ; 
}

```



#### 如何通过位操作，建立掩码

有时候，通过位运算的性质，可以构建一个掩码来加快运算和判断。例如，如果要判定一个数是否为质数，假设该数不超过 20 。20以内的二进制有2,3,5,7,11,13,17,19。那么我们可以构建掩码来判断这个数是不是质数，假设当前数为C，通过20内的二进制，构建一个数，这个数对应质数位置为1，其余位为0，记作mask ，那么通过$2^C&mask$可以快速判断这个数是不是质数，如果为0则是质数，反之不是。