<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-11-25T09:06:37.133Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>ZZC</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>selenium+Chrome(79版本以上)反爬</title>
    <link href="http://example.com/wiki/%E7%88%AC%E8%99%AB/selenium%E5%8F%8D%E7%88%AC/"/>
    <id>http://example.com/wiki/爬虫/selenium反爬/</id>
    <published>2021-11-25T08:16:51.544Z</published>
    <updated>2021-11-25T09:06:37.133Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><font size=2>&nbsp;&nbsp;&nbsp;最近在学习爬虫的过程中碰到一个奇怪的现象，当我在正常的浏览器页面访问网站的时候，能够正常访问到网页的数据。然而，当我通过selenium进行爬取网页数据的时候，出现服务器异常的提醒。正常访问能够访问，而通过selenium访问的时候却报错，这是为什么呢？通过查阅相关资料，可以得出，碰上反爬虫了。</font><blockquote><p>分析</p></blockquote><font size=2>为什么可以得出碰上反爬虫了呢？通常我们通过selenium进行爬取网页的时候，可以通过 window.navigator.webdriver检测是否使用了webdriver。我们可以试一下。在正常访问的网页中输入 window.navigator.webdriver，通常返回的是false或undifine，而当我们通过selenium访问浏览器的时候，在网页控制台输入 window.navigator.webdriver，会返回true。假如我是网页的设计者，我就会先在网页加载的时候写下这么一行代码 :</font><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.navigator.webdriver)&#123;</span><br><span class="line">    alert(<span class="string">&quot;爬虫爬的好，牢饭吃到饱&quot;</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;正常页面&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font size=2>所以，当我们爬取网页出现上述情况的时候，很大可能浏览器存在反selenium。下面介绍一下如何解决反爬，常见的反反爬方案包含：设置参数 excludeSwitches、mitmproxy 拦截过滤、cdp 命令。</font><h3 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;要想解决上述的问题，我们可以让window.navigator.webdriver返回false即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">options.add_experimental_option(<span class="string">&#x27;excludeSwitches&#x27;</span>, [<span class="string">&#x27;enable-automation&#x27;</span>])</span><br><span class="line">driver = webdriver.Chrome(executable_path=<span class="string">&#x27;E:\codeEverment\python\chromedriver.exe&#x27;</span>, options=options) <span class="comment"># chrome驱动 </span></span><br><span class="line">                                 </span><br><span class="line"></span><br><span class="line">script = <span class="string">&quot;Object.defineProperty(navigator, &#x27;webdriver&#x27;, &#123; get: () =&gt; undefined&#125;)&quot;</span></span><br><span class="line">    </span><br><span class="line">driver.execute_cdp_cmd(<span class="string">&quot;Page.addScriptToEvaluateOnNewDocument&quot;</span>, &#123;<span class="string">&quot;source&quot;</span>: script&#125;)</span><br></pre></td></tr></table></figure><br>要见检查是否避免浏览器对webdriver的检测，可以通过selenium访问<a href="https://intoli.com/blog/not-possible-to-block-chrome-headless/chrome-headless-test.html">https://intoli.com/blog/not-possible-to-block-chrome-headless/chrome-headless-test.html</a>,如果页面显示全绿，那么就表明避免成功，反之失败。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;font size=2&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;最近在学习爬虫的过程中碰到一个奇怪的现象，当我在正常的浏览器页面访问网站的时候，能够
      
    
    </summary>
    
      <category term="爬虫" scheme="http://example.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="http://example.com/tags/Python/"/>
    
      <category term="爬虫" scheme="http://example.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫-中级偏</title>
    <link href="http://example.com/wiki/%E7%88%AC%E8%99%AB/Python%E7%88%AC%E8%99%AB-%E4%B8%AD%E7%BA%A7/"/>
    <id>http://example.com/wiki/爬虫/Python爬虫-中级/</id>
    <published>2021-11-22T06:44:03.511Z</published>
    <updated>2021-11-24T03:20:41.636Z</updated>
    
    <content type="html"><![CDATA[<h6 id="1-数据存储"><a href="#1-数据存储" class="headerlink" title="1. 数据存储"></a>1. 数据存储</h6><blockquote><p>前面介绍了关于数据存储的csv,txt,json方式，这里介绍如何采用数据库保存数据，主要是了解两个数据库，关系数据库和分布式数据库。<br>即MySQL和MongoDB。</p></blockquote><h6 id="1-1-MySQL"><a href="#1-1-MySQL" class="headerlink" title="1.1 MySQL"></a>1.1 MySQL</h6><blockquote><p>Python对MySQL的操作通过pymsql模块支持。<br>Python操作MySQL的代码如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Python对MySQL的操作主要是由pymysql模块进行支持。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 主机ip(host),用户名(user),密码(passwd),数据库名称(db),端口(port),编码(charset)</span></span><br><span class="line"><span class="comment"># 打开数据库， pymysql.connect(host=,user=,passwd=,db=,port=,charset=)</span></span><br><span class="line">db = pymysql.connect(</span><br><span class="line">    host=<span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    user=<span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">    passwd=<span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">    db=<span class="string">&#x27;votemsy&#x27;</span>,</span><br><span class="line">    charset=<span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接数据库成功后就可以操作数据库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个游标对象</span></span><br><span class="line"><span class="comment"># 游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果</span></span><br><span class="line"><span class="comment"># 游标对象支持的数据库的操作</span></span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment">#需要执行的sql语句</span></span><br><span class="line">sql = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#执行一条SQL语句</span></span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    <span class="comment">#执行多条SQL语句</span></span><br><span class="line">    cursor.executemany(sql)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#用来从结果中取一条记录，并将游标指向下一条记录</span></span><br><span class="line">    result = cursor.fetchone()</span><br><span class="line">    <span class="comment">#用来从结果中取多条记录</span></span><br><span class="line">    result = cursor.fetchmany(<span class="number">5</span>)</span><br><span class="line">    <span class="comment">#获取所有记录列表</span></span><br><span class="line">    results = cursor.fetchall()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 插入数据</span></span><br><span class="line">    data = <span class="string">&quot;&#x27;qiye&#x27;,20&quot;</span></span><br><span class="line">    cursor.execute(<span class="string">&#x27;INSERT INTO person (name,age) VALUES (%s)&#x27;</span>%data)</span><br><span class="line">    <span class="comment"># 插入数据，占位符法</span></span><br><span class="line">    cursor.execute(<span class="string">&#x27;INSERT INTO person(name,age) VALUES (%s,%s)&#x27;</span>,(<span class="string">&#x27;qiye&#x27;</span>,<span class="number">20</span>))</span><br><span class="line">    <span class="comment">#执行多条插入语句</span></span><br><span class="line">    cursor.executemany(<span class="string">&#x27;INSERT INTO person(name,age) values &#x27;</span>,[(<span class="string">&#x27;qiye&#x27;</span>,<span class="number">20</span>),(<span class="string">&#x27;jack&#x27;</span>,<span class="number">20</span>)])</span><br><span class="line"></span><br><span class="line">    <span class="comment">#查询数据</span></span><br><span class="line">    cursor.execute(<span class="string">&#x27;SELECT * FROM person&#x27;</span>)</span><br><span class="line">    res = cursor.fetchall() <span class="comment">#获取所有结果</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> res:</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br><span class="line">    cursor.execute(<span class="string">&#x27;SELECT * FROM person&#x27;</span>)</span><br><span class="line">    res = cursor.fetchone() <span class="comment">#只获取一个结果</span></span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#修改和删除数据</span></span><br><span class="line">    cursor.execute(<span class="string">&#x27;UPDATE person SET name=%s WHERE id=%s&#x27;</span>,(<span class="string">&#x27;rose&#x27;</span>,<span class="number">1</span>))</span><br><span class="line">    cursor.execute(<span class="string">&#x27;DELETE FROM person where id=%s&#x27;</span>,(<span class="number">0</span>,))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 用来事务提交，只有commit之后，才会提交到数据库进行一系列的操作</span></span><br><span class="line">    db.commit()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e :</span><br><span class="line">    <span class="comment"># 由于在执行事务的过程中，出现错误，所以回滚，恢复原来的状态，不执行操作</span></span><br><span class="line">    db.rollback()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    cursor.close() <span class="comment">#关闭游标</span></span><br><span class="line">    db.close() <span class="comment">#关闭一个数据库连接</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p></blockquote><h6 id="1-2-MongoDB"><a href="#1-2-MongoDB" class="headerlink" title="1.2 MongoDB"></a>1.2 MongoDB</h6><p>MongoDB是基于分布式文件存储的数据库，用于为Web应用提供可扩展的高性能数据存储解决方案。MongoDB属于非关系数据库。</p><p>MongoDB的基本概念是文档，集合，数据库。</p><p>MongoDB中的表通过collection替代，MongoDB中的行通过document替换。MongoDB中的列通过field替换。<br>MongoDB自动将_id字段设置为主键。</p><blockquote><p>文档：文档是MongoDB中数据的基本单元（即BSON）,类似于关系数据库中的行。文档具有唯一标识_id.数据库可以自动生成。文档以key/value形式。例如: {“name”:”qiye”,”age”:24}</p></blockquote><p>文档具有如下三个特性：</p><ol><li>文档的键值对是有序的，顺序不同文档亦不同。</li><li>文档的值可以是字符串，整数，数组以及文档等类型。</li><li>文档的键是用双引号标识的字符串。以——开头的键是保留的，建议不要使用。</li><li>文档区分大小写以及值类型</li></ol><blockquote><p>集合：集合也就是一组文档，类似于数据表。集合没有固定的结构，可以在集合中插入不同格式和类型的数据（和关系表的差异）。</p></blockquote><p>集合命名不能是空字符串，不能有’\0’字符，不能以system.开头，不要包含$。</p><blockquote><p>数据库：一个MongoDB可以创建多个数据库，默认数据库是db，数据库存储在data目录。MongoDB的单个实例可以容纳多个独立的数据库。</p></blockquote><p>MongoDB的数据类型如下所示：<br><img src="/images/数据类型.PNG" alt="a11"></p><blockquote><p>插入语法：db.集合.insert(JSON格式数据)</p><p>查询语法：db.集合.find()<br><img src="/images/条件查询.PNG" alt="a12"></p></blockquote><p>对于多条件查询(and和or).<br>and通过逗号隔开。例如：db.集合.find({“key1”:{条件1},”key2”:{条件2}})</p><p>or通$or来实现。例如：db.集合.find({<br>    $or:[<br>        {key1:value1},{key2:value2}<br>    ]<br>})</p><blockquote><p>更新文档：MongoDB通过update(),save()方法来更新集合中的文档。update: db.集合.update(<br>    query,<br>    update，{<br>        upsert:boolean,<br>        multi: boolean,<br>        writeConcern:document<br>    }<br>)<br>其中：query为update的查询条件，update:update的对象和一些更新的操作符等（类似于set后面的内容），upsert（可选，如果不存在update记录，是否插入新文档）, multi（可选，是否更新全部查找出来的记录），writeConcern(可选，异常抛出级别)。<br>eg:<br>db.python.update(<br>    {‘title’,’python’},{$set:{‘title’,’python爬’}}<br>)<br>db.python.update(<br>    {‘title’,’python’},{$set:{‘title’:’python爬’}},{multi:true}<br>)</p></blockquote><p>对于save()方法，通过传入的文档替换已有的文档。db.集合.save({<br>    document{<br>        writeConcern:document<br>    }<br>})</p><blockquote><p>删除文档：MongoDB提供了remove()方法来删除文档。</p></blockquote><p>db.集合.remove(<br>    query, #删除的文档的条件<br>    {<br>        justOne:boolean, # 如果设置为true，则只删除一个文档。<br>        writeConcern:document<br>    }<br>)</p><p>删除所有title等于mongodb的文档<br>db.python.remove({‘title’:’Mongodb’})<br>如果没有查询条件，就相当于删除所有的文档。<br>python操作mongodb代码如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1. 建立连接</span></span><br><span class="line"><span class="comment">#pymogo模块使用MongoClient对象描述一个数据库客户端，创建对象的主要参数是host和port</span></span><br><span class="line"><span class="comment">#如下三种方式创建</span></span><br><span class="line">client = pymongo.MongoClient() <span class="comment"># 连接默认的主机IP和端口</span></span><br><span class="line"><span class="comment"># client = pymongo.MongoClient(&#x27;localhost&#x27;,27017) #显示指定IP和端口</span></span><br><span class="line"><span class="comment"># client = pymongo.MongoClient(&#x27;mongodb://localhost:27017/&#x27;) #采用URL格式进行连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2. 获取数据库,通过MongoClient的属性方式来访问数据库</span></span><br><span class="line">db = client.test <span class="comment">#方式一</span></span><br><span class="line"><span class="comment"># db = client[&#x27;pa-pers&#x27;] #方式二</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3. 获取一个集合</span></span><br><span class="line"><span class="comment"># collection = db.books #方式一</span></span><br><span class="line">collection = db[<span class="string">&#x27;test_one&#x27;</span>] <span class="comment">#方式二</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#插入文档操作</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;author&#x27;</span>:<span class="string">&#x27;mike&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;text&#x27;</span>:<span class="string">&#x27;My first book&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;tags&#x27;</span>:[<span class="string">&quot;爬虫&quot;</span>,<span class="string">&quot;python&quot;</span>,<span class="string">&quot;网络&quot;</span>],</span><br><span class="line">    <span class="string">&#x27;date&#x27;</span>: datetime.datetime.utcnow()</span><br><span class="line">&#125;</span><br><span class="line">data_id = collection.insert_one(data) <span class="comment"># 插入一条语句,返回数据的_id值,如果文件内没有_id值，则会自动添加到一文件里</span></span><br><span class="line"><span class="comment"># data_id = collection.insert_many(data) # 插入多条,数据以列表形式[&#123;&#125;,&#123;&#125;]</span></span><br><span class="line"><span class="built_in">print</span>(data_id)</span><br><span class="line"><span class="comment"># 查询语句，find_one</span></span><br><span class="line"><span class="built_in">print</span>(collection.find_one(&#123;<span class="string">&#x27;author&#x27;</span>:<span class="string">&#x27;mike&#x27;</span>&#125;))</span><br><span class="line"><span class="comment"># 通过_id查询</span></span><br><span class="line"><span class="built_in">print</span>(collection.find_one(&#123;<span class="string">&#x27;_id&#x27;</span>: ObjectId(<span class="string">&#x27;619c4dc19c281df292e7e0dd&#x27;</span>)&#125;))</span><br><span class="line"><span class="comment"># 通过find可以查询多个符合条件的文档,并且可以在括号中加入限制条件，查询多个符合条件的文档</span></span><br><span class="line"><span class="keyword">for</span> book <span class="keyword">in</span> collection.find():</span><br><span class="line">    <span class="built_in">print</span>(book)</span><br><span class="line"><span class="comment"># 统计符合条件的数目</span></span><br><span class="line"><span class="built_in">print</span>(collection.count_documents(&#123;<span class="string">&#x27;author&#x27;</span>:<span class="string">&#x27;mike&#x27;</span>&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改文档</span></span><br><span class="line">collection.update_one(&#123;<span class="string">&#x27;author&#x27;</span>:<span class="string">&#x27;mike&#x27;</span>&#125;,&#123;<span class="string">&quot;$set&quot;</span>:&#123;<span class="string">&quot;text&quot;</span>:<span class="string">&quot;python book&quot;</span>&#125;&#125;)</span><br><span class="line"><span class="comment">#删除文档</span></span><br><span class="line">collection.delete_one(&#123;<span class="string">&#x27;author&#x27;</span>:<span class="string">&#x27;mike&#x27;</span>&#125;) <span class="comment"># 如果要删除多个，delete_many</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h6 id="2-动态网站抓取"><a href="#2-动态网站抓取" class="headerlink" title="2. 动态网站抓取"></a>2. 动态网站抓取</h6><p>动态网页主要涉及到的技术是Ajax（Asynchoronous JavaScript and XML）和动态Html。</p><blockquote><p>Ajax技术用于网页的局部刷新，不必刷新整个页面，只需要调整局部内容，达到想要的效果，用户体验得到提升。<br>AJAX使用SOAP,XML或者支持JSON的WebService接口，在客户端利用JavaScript处理来自服务器的响应。</p></blockquote><p>SOAP:简单对象访问协议是交换数据的一种协议规范，是一种轻量的、简单的、基于XML（标准通用标记语言下的一个子集）的协议，它被设计成在WEB上交换结构化的和固化的信息。</p><blockquote><p>动态html（DHTML，Dynamic Html）,由HTML+CSS+JavaScript。</p></blockquote><p>如何从动态html页面爬取数据？有如下两种方法：</p><blockquote><ol><li>直接从JavaScript中采集加载的数据</li></ol></blockquote><h6 id="爬取影评信息"><a href="#爬取影评信息" class="headerlink" title="爬取影评信息"></a>爬取影评信息</h6><p>网页地址(www.mitime.com)</p><blockquote><ol><li>直接采集浏览器中已经加载的数据</li></ol></blockquote><p>对于直接加载渲染后的页面，可以通过PhantomJS,Selenium进行爬取。PhantomJS是基于WebKit的服务端JavaScript API，全面支持Web而无需浏览器支持，运行快，支持各种Web标准，DOM处理，CSS选择器，JSON，Cancas和SVG。PhantomJS可以用于网页自动化，网络检测，网页截屏，无界面测试等。可以把PhantomJS看成一个无界面的浏览器。</p><p>Selenium: Selenium是一个自动化测试工具，支持各种浏览器，Selenium支持浏览器驱动，可以对浏览器进行控制。</p><p>Selenium可以说是网页爬取的大杀器，可以直接模拟操作浏览器页面。下面介绍关于Selenium的使用方法。</p><blockquote><ol><li>安装配置</li></ol></blockquote><p>对于Selenium的安装配置教程可以自行百度。这里我采用的是Firefox,所以只需要两步，1. 下载selenium,通过pip指令就行。2. 下载驱动器geckodriver。通过如下代码即可使用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># executable_path就是下载的geckodriver所在的文件路径</span></span><br><span class="line">driver  = webdriver.Firefox(executable_path=<span class="string">&#x27;E:\codeEverment\python\geckodriver\geckodriver-v0.14.0-win64\geckodriver.exe&#x27;</span>)</span><br><span class="line">driver.get(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)</span><br></pre></td></tr></table></figure></p><blockquote><ol><li>元素查找</li></ol></blockquote><p>selenium的元素定位方法如下图所示：<br><img src="/images/定位方法.PNG" alt="a22"></p><blockquote><ol><li>页面操作</li></ol></blockquote><p>如何给表单填写内容？我们可以定位到表单元素，然后通过元素.send_keys填入内容。找到按钮或链接通过元素.click()模拟点击事件。如果要清除填入的内容，通过元素.clear()可以清除内容。</p><p>对于下拉选项，可以通过WebDriver提供的一个叫Select方法进行选择。</p><p>对于元素拖拽，首先要找到源元素和目的元素，然后用ActionChains类可以实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">driver  = webdriver.Firefox(executable_path=<span class="string">&#x27;E:\codeEverment\python\geckodriver\geckodriver-v0.14.0-win64\geckodriver.exe&#x27;</span>)</span><br><span class="line">driver.get(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(driver.title)</span><br><span class="line"><span class="keyword">assert</span> <span class="string">u&#x27;百度&#x27;</span> <span class="keyword">in</span> driver.title</span><br><span class="line">elem = driver.find_element_by_name(<span class="string">&#x27;wd&#x27;</span>)</span><br><span class="line">elem.clear()</span><br><span class="line">elem.send_keys(<span class="string">u&#x27;网络爬虫&#x27;</span>) <span class="comment"># 给控件填写内容</span></span><br><span class="line">elem.send_keys(Keys.RETURN) <span class="comment">#这里是回车按钮</span></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">driver.close()</span><br><span class="line"><span class="comment"># 执行js代码</span></span><br><span class="line"><span class="comment"># 将页面拉到最低端</span></span><br><span class="line">driver.execute_script(<span class="string">&quot;window.scrollTo(0,document.body.scrollHeight);&quot;</span>)</span><br></pre></td></tr></table></figure><p>显示等待的API：<br><img src="/images/显示等待.PNG" alt="a24"></p><h6 id="3-Web端协议分析"><a href="#3-Web端协议分析" class="headerlink" title="3. Web端协议分析"></a>3. Web端协议分析</h6><h6 id="4-终端协议分析"><a href="#4-终端协议分析" class="headerlink" title="4. 终端协议分析"></a>4. 终端协议分析</h6><h6 id="5-初窥Scrapy爬虫框架"><a href="#5-初窥Scrapy爬虫框架" class="headerlink" title="5. 初窥Scrapy爬虫框架"></a>5. 初窥Scrapy爬虫框架</h6><h6 id="6-深入Scrapy爬虫框架"><a href="#6-深入Scrapy爬虫框架" class="headerlink" title="6. 深入Scrapy爬虫框架"></a>6. 深入Scrapy爬虫框架</h6><h6 id="7-实战项目：Scrapy爬虫"><a href="#7-实战项目：Scrapy爬虫" class="headerlink" title="7. 实战项目：Scrapy爬虫"></a>7. 实战项目：Scrapy爬虫</h6>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;1-数据存储&quot;&gt;&lt;a href=&quot;#1-数据存储&quot; class=&quot;headerlink&quot; title=&quot;1. 数据存储&quot;&gt;&lt;/a&gt;1. 数据存储&lt;/h6&gt;&lt;blockquote&gt;
&lt;p&gt;前面介绍了关于数据存储的csv,txt,json方式，这里介绍如何采用数据库保
      
    
    </summary>
    
      <category term="爬虫" scheme="http://example.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="http://example.com/tags/Python/"/>
    
      <category term="爬虫" scheme="http://example.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫开发与项目实战-第二回合（实战）</title>
    <link href="http://example.com/wiki/%E7%88%AC%E8%99%AB/Python%E7%88%AC%E8%99%AB2.1/"/>
    <id>http://example.com/wiki/爬虫/Python爬虫2.1/</id>
    <published>2021-11-18T08:35:25.519Z</published>
    <updated>2021-11-22T02:19:31.513Z</updated>
    
    <content type="html"><![CDATA[<p>爬虫的原理十分简单，通过URL，获取网页资源，再根据网页资源进一步获取需要的信息数据。</p><p>我们很容易借助requests,beautifulSoup库等实现一个简答的爬虫。实际上，到了这基本上爬虫的大概就已经学习完毕了。对于我们现在编写的爬虫与大型爬虫的差距在于以下几点：</p><blockquote><ol><li>实现方式</li><li>优化方式</li><li>稳健性<br>我们现在仅仅只考虑功能的实现，所以还只是基础爬虫，要实现一个大型的爬虫还因该从效率，稳健性，结构化，维护等方面综合考虑。</li></ol></blockquote><p><img src="/images/基础爬虫.PNG" alt="a1"></p><p>一个爬虫的基础框架可以分为：爬虫调度器，URL管理器，HTML下载器，HTML解析器，数据存储器</p><ol><li><p>爬虫调度器  负责其他四个模块的协调工作</p></li><li><p>URL管理器主要负责URL链接，维护已经爬取的URL集合和未爬取的URL集合，提供互殴去新的URL链接的接口</p></li><li><p>HTML下载器用于从URL管理器中获取未爬取的URL链接并下载HTML页面</p></li><li><p>HTML解析器用于从HTML下载器中获取已经下载的HTML页面，并从中解析出新的URL链接交给URL管理器<br>解析出有效数据交给数据存储器。</p></li><li><p>数据存储器用于将HTML解析器解析出来的数据通过文件或数据库的形式存储起来。</p></li></ol><p>爬虫的动态流程如下所示：<br><img src="/images/爬虫时序图.PNG" alt="a2"></p><h6 id="百度百科词条爬取项目"><a href="#百度百科词条爬取项目" class="headerlink" title="百度百科词条爬取项目"></a>百度百科词条爬取项目</h6><blockquote><h3 id="URL管理器"><a href="#URL管理器" class="headerlink" title="URL管理器"></a>URL管理器</h3></blockquote><h6 id="简单分布式爬虫"><a href="#简单分布式爬虫" class="headerlink" title="简单分布式爬虫"></a>简单分布式爬虫</h6><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>这里实现简单的分布式爬虫，采用主从模式。目前大型的爬虫都采用分布式爬取，所以通过此次实践加深对分布式爬虫的理解。分布式需要考虑如何设计结构，保证各个节点稳定高效地运作。</p><h4 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h4><p>主从模式是指由一台主机作为控制节点，负责管理所有运行网络爬虫的主机，爬虫只需要从控制节点那里接收任务，并把新<br>生成任务提交给控制节点就可以了，在这个过程中不必与其它爬虫通信。</p><blockquote><ol><li>采用主从模式，实现简单，利于管理。而控制节点则需要与所有爬虫进行通信。</li><li>主从模式的缺陷在于，控制节点会成为整个系统的瓶颈，容易导致整个分布式网络爬虫系统性能下降。</li></ol></blockquote><p>主从模式的结构如下所示(以一台主机和两台从机为例)：控制节点（ControlNode）主要分为URL管理器，数据存储器和控制调度器。(1)控制调度器通过三个进程来协调URL管理器和数据存储器的工作：(2)一个是URL管理进程，负责URL的管理和将URL传递给爬虫节点；(3)一个是数据提取进程，负责读取爬虫节点返回的数据，将返回数据中的URL交给URL管理进程，将标题和摘要等数据交给数据存储进程；最后一个是数据存储进程，负责将数据提取进程中提交的数据进行本地存储。</p><p>对于爬虫节点(SpdierNode):包含爬虫调度器，HTML下载器，HTML解析器，主要负责对URL进行爬取，下载，然后将新的URL,data返回给控制节点(ControlNode)。<br>爬虫调度器的执行流程：</p><ol><li>爬虫调度器从控制节点中的url_q队列读取URL</li><li>爬虫调度器调用HTML下载器，HTML解析器获取网页中新的URL和标题摘要</li><li>爬虫调度器将新的URL和标题摘要传入result_q队列交给控制节点</li></ol><p><img src="/images/主从.PNG" alt="a21"><br><img src="/images/控制节点.PNG" alt="a22"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;爬虫的原理十分简单，通过URL，获取网页资源，再根据网页资源进一步获取需要的信息数据。&lt;/p&gt;
&lt;p&gt;我们很容易借助requests,beautifulSoup库等实现一个简答的爬虫。实际上，到了这基本上爬虫的大概就已经学习完毕了。对于我们现在编写的爬虫与大型爬虫的差距在于
      
    
    </summary>
    
      <category term="爬虫" scheme="http://example.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="http://example.com/tags/Python/"/>
    
      <category term="爬虫" scheme="http://example.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫开发与项目实战-第二回合</title>
    <link href="http://example.com/wiki/%E7%88%AC%E8%99%AB/Python%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E4%B8%8E%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%BA%8C%E5%9B%9E%E5%90%88/"/>
    <id>http://example.com/wiki/爬虫/Python爬虫开发与项目实战-第二回合/</id>
    <published>2021-11-17T02:40:35.328Z</published>
    <updated>2021-11-17T08:30:36.279Z</updated>
    
    <content type="html"><![CDATA[<p>网络爬虫：是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。</p><p>网络爬虫可以分为：</p><blockquote><ol><li>通用网络爬虫</li></ol></blockquote><p>通过搜索引擎搜索关键词，然后从搜索引擎返回的数据中，爬取想要的数据。</p><blockquote><ol><li>聚焦网络爬虫</li></ol></blockquote><p>有针对性的爬取指定的网页链接。定向爬取相关页面。</p><blockquote><ol><li>增量式网络爬虫</li></ol></blockquote><p>也就是爬取新的数据，而对于之前爬取过的数据，不会再进行爬取。</p><blockquote><ol><li>深层网络爬虫</li></ol></blockquote><p>也就是爬取一些不能通过静态链接获取的，需要用户操作后才能访问获取的Web页面。</p><h6 id="网络爬虫结构"><a href="#网络爬虫结构" class="headerlink" title="网络爬虫结构"></a>网络爬虫结构</h6><p>爬虫的一般流程：</p><ol><li>需要爬取页面的URL</li><li>读取URL，获取到网页数据</li><li>从网页数据提取有用数据</li><li>抽取网页需要进一步爬取URL，进行再次爬取</li></ol><p><img src="/images/爬虫流程.PNG" alt="1.1"></p><h6 id="Request库"><a href="#Request库" class="headerlink" title="Request库"></a>Request库</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Python对HTTP请求的支持：通过urllib2和urllib或者通过request模块。</span></span><br><span class="line"><span class="string">一般通过request实现http请求。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    #发送get请求</span></span><br><span class="line"><span class="string">    r = requests.get(&#x27;&#x27;)</span></span><br><span class="line"><span class="string">    # 对于带有参数的url，可以通过建立一个map作为参数进行请求</span></span><br><span class="line"><span class="string">    payload = &#123;&#x27;keywords&#x27;:&#x27;blog:qiyeboy&#x27;,&#x27;pageindex&#x27;:1&#125;</span></span><br><span class="line"><span class="string">    r = requests.get(&#x27;&#x27;,params=payload) #通过map提供参数</span></span><br><span class="line"><span class="string">    #发送post请求</span></span><br><span class="line"><span class="string">    r = requests.post(&#x27;&#x27;)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment">#chardet是用于检测文本编码</span></span><br><span class="line"><span class="keyword">import</span> chardet</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">requestTemp</span>():</span></span><br><span class="line">    r = requests.get(<span class="string">&#x27;www.baidu.com&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(r.content) <span class="comment"># 返回字节类型的数据</span></span><br><span class="line">    <span class="built_in">print</span>(r.text) <span class="comment"># 返回文本形式的html</span></span><br><span class="line">    <span class="built_in">print</span>(r.encoding) <span class="comment"># 返回网页编码格式</span></span><br><span class="line">    r.encoding = <span class="string">&#x27;utf-8&#x27;</span> <span class="comment"># 可以自定义编码格式。然后再读取网页文本数据，这样就不会乱码</span></span><br><span class="line">    <span class="built_in">print</span>(r.text) <span class="comment"># 这是在utf-8编码下的文本数据</span></span><br><span class="line">    <span class="comment">#通过chardet进行解码</span></span><br><span class="line">    r.encoding = chardet.detect(r.content)[<span class="string">&#x27;encoding&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">### 我们可以对请求头headers进行处理,即对请求设置请求头,设置Cookie</span></span><br><span class="line">    <span class="comment">### 对于请求头，我们可以通过f12查看请求头格式</span></span><br><span class="line">    user_agent = <span class="string">&#x27;Mozilla/4.0&#x27;</span></span><br><span class="line">    headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>:user_agent&#125; <span class="comment">#设置请求头</span></span><br><span class="line">    <span class="comment">#自定义Cookie</span></span><br><span class="line">    cookies = <span class="built_in">dict</span>(name=<span class="string">&#x27;qiye&#x27;</span>,age=<span class="string">&#x27;10&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    r = requests.get(<span class="string">&#x27;www.baidu.com&#x27;</span>,headers=headers,cookies=cookies)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取响应的Cookie值</span></span><br><span class="line">    <span class="keyword">for</span> cookie <span class="keyword">in</span> r.cookies.keys():</span><br><span class="line">        <span class="built_in">print</span>(r.cookies.get(cookie))</span><br><span class="line"></span><br><span class="line">    <span class="comment">### 获取返回状态编码，判断请求是否成功</span></span><br><span class="line">    <span class="keyword">if</span> r.status_code == requests.codes.ok :</span><br><span class="line">        <span class="built_in">print</span>(r.status_code)</span><br><span class="line">        <span class="built_in">print</span>(r.headers.get(<span class="string">&#x27;content-type&#x27;</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r.raise_for_status() <span class="comment">#通过raise_for_status可以抛出一个异常。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">###自动处理Cookie方法 , 通过session，每次都可以将Cookie值带上</span></span><br><span class="line">    s = requests.Session()</span><br><span class="line">    r = s.get(<span class="string">&quot;wwww.baidu.com&quot;</span>,allow_redirects=<span class="literal">True</span>)</span><br><span class="line">    datas = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;qiyi&#x27;</span>,<span class="string">&#x27;passwd&#x27;</span>:<span class="string">&#x27;123&#x27;</span>&#125;</span><br><span class="line">    <span class="comment"># 通过Session机制，可以保证每次都加上了cookie的值，进行请求</span></span><br><span class="line">    r = s.post(<span class="string">&#x27;wwww.baidu.com&#x27;</span>,data=datas,allow_redirects=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 通过allow_redirects可以设置是否允许重定向</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过r.history可以获取到历史信息，也就是访问成功之前的所有请求跳转信息</span></span><br><span class="line">    <span class="built_in">print</span>(r.history)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#设置超时参数，Timeout</span></span><br><span class="line">    r = requests.get(<span class="string">&#x27;www.baidu.com&#x27;</span>,timeout=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#代理设置，使用代理Proxy,可以为任意请求方法通过设置proxies参数来配置单个请求</span></span><br><span class="line">    proxies = &#123;</span><br><span class="line">        <span class="string">&quot;http&quot;</span>:<span class="string">&quot;http://0.10.1.10:3128&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https&quot;</span>:<span class="string">&quot;http://10.10.1.10:1080&quot;</span>,</span><br><span class="line">        <span class="comment">#&quot;http&quot;:&quot;http://user:pass@10.10.1.10:3128&quot; #这是代理中身份认证的用户名和密码，来设置代理</span></span><br><span class="line">    &#125;</span><br><span class="line">    requests.get(<span class="string">&quot;www.baidu.com&quot;</span>,proxies=proxies) <span class="comment">#设置代理ip</span></span><br></pre></td></tr></table></figure><h6 id="网页解析"><a href="#网页解析" class="headerlink" title="网页解析"></a>网页解析</h6><p>我们通过requets可以下载网页中的文本，那么我们怎么通过下载的文本获取到想要的信息呢？这里就需要使用到文本解析技术了，常用的方法有很多，我们这里采用BeautifulSoup库进行解决。BeautifulSoup具备的解析器如下所示：</p><p>BeautifulSoup将HTML文档转换成一个复杂的树形结构，每个节点都是一个python对象，所有对象可以归纳为四种。</p><blockquote><ol><li>Tag</li><li>NavigableString</li><li>BeautifulSoup</li><li>Comment</li></ol></blockquote><p>BeautifulSoup对网页的解析，主要是搜索指定标签，遍历标签元素，提取标签内容。对于解析文本的方法，可以参考如下代码，本质上就是调用API定位到要爬取到的数据信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">正则表达式：</span></span><br><span class="line"><span class="string">\b: 匹配单词的开始或结束</span></span><br><span class="line"><span class="string">^:  匹配字符串的开始</span></span><br><span class="line"><span class="string">$:  匹配字符串的结束</span></span><br><span class="line"><span class="string">\w: 匹配字母，数字，下划线或汉字</span></span><br><span class="line"><span class="string">\s: 匹配任意空白字符</span></span><br><span class="line"><span class="string">\d: 匹配数字</span></span><br><span class="line"><span class="string">. : 匹配除换行符以外的任意字符</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">字符串转义: 通过\进行转义</span></span><br><span class="line"><span class="string">数量匹配：</span></span><br><span class="line"><span class="string">*：零次或多次</span></span><br><span class="line"><span class="string">+： 一次或多次</span></span><br><span class="line"><span class="string">？：零次或一次</span></span><br><span class="line"><span class="string">&#123;n&#125;: n次</span></span><br><span class="line"><span class="string">&#123;n,&#125;: n次或更多次</span></span><br><span class="line"><span class="string">&#123;n,m&#125; 重复n-m次</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">分支条件：</span></span><br><span class="line"><span class="string">正则表达式通过 | 表示或的关系。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    这里采用BeautifulSoup(美味汁)进行文本解析</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">r = requests.get(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">r.encoding = <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">html = r.text</span><br><span class="line"><span class="comment"># 可以直接打开，不知道解析器，一般采用lxml解析器</span></span><br><span class="line">soup = BeautifulSoup(html,<span class="string">&#x27;lxml&#x27;</span>,from_encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> 获取对象属性():</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#Tag 对象</span></span><br><span class="line">    <span class="comment">#Tag对象就像html标签一样，直接通过soup.标签名进行对象的提取</span></span><br><span class="line">    <span class="comment">#要获取tag对象的属性，通过标签.name获取标签的名称 ， 并且可以设置标签的名称</span></span><br><span class="line">    <span class="comment">#如果需要获取标签的属性，如href和class之类的属性，则通过标签.get(属性名)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(soup.a) <span class="comment"># 根据标签获取</span></span><br><span class="line">    <span class="built_in">print</span>(soup.a.name) <span class="comment">#获取标签名称</span></span><br><span class="line">    <span class="built_in">print</span>(soup.a.get(<span class="string">&#x27;href&#x27;</span>)) <span class="comment"># 获取属性名称</span></span><br><span class="line">    <span class="built_in">print</span>(soup.a.attrs) <span class="comment"># 获取标签中的所有属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果要修改标签中的属性，怎么获取也同样可以怎么设置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># BeautifulSoup用NavigableString类来包装Tag中的字符串，通过标签.string就可以获取到标签内部的文字</span></span><br><span class="line">    <span class="built_in">print</span>(soup.a.string)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(soup.a.string))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#BeautifulSoup对象表示的是一个文档的全部内容。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> 遍历():</span></span><br><span class="line">    <span class="comment">### 遍历操作， beautiful soup 对文档树的遍历</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    1. contents</span></span><br><span class="line"><span class="string">    2.  children</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># contents属性，可以将tag的子节点列表输出</span></span><br><span class="line">    <span class="built_in">print</span>(soup.head.contents)</span><br><span class="line">    <span class="comment"># children属性返回的是一个生成器。可以对Tag的子节点进行循环</span></span><br><span class="line">    <span class="comment"># 也就是通过children可以迭代遍历节点的所有子节点.</span></span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> soup.head.children:</span><br><span class="line">        <span class="built_in">print</span>(child)</span><br><span class="line">    <span class="comment"># 如果要递归遍历所有标签的孙子结点，则通过desendants属性，对所有tag的子孙节点进行循环</span></span><br><span class="line">    <span class="comment"># 标签的内容也属于标签的子节点</span></span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> soup.head.descendants:</span><br><span class="line">        <span class="built_in">print</span>(child)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取结点的内容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># stirng , 如果标记唯一就返回标记的内容，而如果标记不唯一，可能返回None</span></span><br><span class="line">    <span class="built_in">print</span>(soup.a.string)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># strings属性主要用于tag中包含多个字符串的情况，可以循环遍历</span></span><br><span class="line">    <span class="keyword">for</span> string <span class="keyword">in</span> soup.strings:</span><br><span class="line">        <span class="built_in">print</span>(string)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># stripped_strings 可以去掉输出字符串包含的空格或空行</span></span><br><span class="line">    <span class="keyword">for</span> string <span class="keyword">in</span> soup.stripped_strings:</span><br><span class="line">        <span class="built_in">print</span>(string)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取父节点，通过parent属性</span></span><br><span class="line">    <span class="built_in">print</span>(soup.a.parent)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取节点的所有父辈节点，通过parents属性</span></span><br><span class="line">    <span class="keyword">for</span> parent <span class="keyword">in</span> soup.a.parents:</span><br><span class="line">        <span class="keyword">if</span> parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(parent)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(parent.name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取节点的兄弟节点,空白或换行也可也被视作一个节点</span></span><br><span class="line">    <span class="comment"># next_sibling获取下一个兄弟节点</span></span><br><span class="line">    <span class="built_in">print</span>(soup.a.next_sibling)</span><br><span class="line">    <span class="comment"># previous_sibling获取上一个兄弟节点</span></span><br><span class="line">    <span class="built_in">print</span>(soup.a.previous_sibling)</span><br><span class="line">    <span class="comment"># 通过next_siblings或者previous_siblings可以对当前兄弟节点迭代输出</span></span><br><span class="line">    <span class="keyword">for</span> sibling <span class="keyword">in</span> soup.a.next_siblings:</span><br><span class="line">        <span class="built_in">print</span>(sibling)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取节点的前后节点。前后节点是不区分层次结构的前后关系，如&lt;div&gt;&lt;a&gt;&lt;div&gt;,div的后一个节点就是a</span></span><br><span class="line">    <span class="comment"># next_element,previous_element,</span></span><br><span class="line">    <span class="built_in">print</span>(soup.a)</span><br><span class="line">    <span class="built_in">print</span>(soup.a.next_element)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果想遍历所有前后节点，通过next_elements和previous_elements进行遍历</span></span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> soup.a.next_elements:</span><br><span class="line">        <span class="built_in">print</span>(element)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索文档树，搜索指定的内容</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 搜索():</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># find_all()方法，搜索当前tag的所有tag子节点，判断是否满足搜索条件</span></span><br><span class="line">    <span class="comment"># find_add(name,attrs,recursive,txext,**kwargs)</span></span><br><span class="line">    <span class="comment"># name参数可以查找所有名字为name的标记,返回列表.一般用这个来找指定的标签</span></span><br><span class="line">    <span class="comment"># name参数可以是单独的字符，也可以是字符列表。</span></span><br><span class="line">    <span class="comment"># 可以自定义过滤器，用于匹配指定规则的标签</span></span><br><span class="line">    <span class="built_in">print</span>(soup.find_all(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(soup.find_all([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>]))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasClass_Id</span>(<span class="params">tag</span>):</span></span><br><span class="line">        <span class="keyword">return</span> tag.has_attr(<span class="string">&#x27;class&#x27;</span>) <span class="keyword">and</span> tag.has_attr(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(soup.find_all(hasClass_Id)) <span class="comment"># 寻找满足匹配规则的标签</span></span><br><span class="line">    <span class="comment"># 多条件过滤标签</span></span><br><span class="line">    <span class="comment"># 可以在find_all()中根据属性搜索指定的标签，并且可以将正则表达式作为搜索条件</span></span><br><span class="line">    <span class="built_in">print</span>(soup.find_all(<span class="string">&#x27;a&#x27;</span>,href=re.<span class="built_in">compile</span>(<span class="string">&#x27;elsie&#x27;</span>),<span class="built_in">id</span>=<span class="string">&#x27;12&#x27;</span>,class_=<span class="string">&#x27;sister&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#如果要限制搜索数目，则通过limit参数进行限制</span></span><br><span class="line">    <span class="built_in">print</span>(soup.find_all(<span class="string">&#x27;a&#x27;</span>,limit=<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 限制只搜索直接节点，而不搜索子孙节点，设置recursive = False</span></span><br><span class="line">    <span class="built_in">print</span>(soup.find_all(<span class="string">&#x27;a&#x27;</span>,limit=<span class="number">5</span>),recursive=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># CSS选择器</span></span><br><span class="line">    <span class="comment"># 通过元素的CSS属性定位元素的位置</span></span><br><span class="line">    <span class="comment"># 根据name属性通过.class值 , 根据id属性通过#id值</span></span><br><span class="line">    <span class="comment"># 返回类型为list</span></span><br><span class="line">    <span class="comment">#找到所有a标签</span></span><br><span class="line">    soup.select(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    <span class="comment">#找到a标签，id为1</span></span><br><span class="line">    soup.select(<span class="string">&#x27;a#1&#x27;</span>)</span><br><span class="line">    <span class="comment">#根据name查询</span></span><br><span class="line">    soup.select(<span class="string">&#x27;.classs&#x27;</span>)</span><br><span class="line">    <span class="comment">#通过判断是否存在某个属性进行查找</span></span><br><span class="line">    soup.select(<span class="string">&#x27;a[href]&#x27;</span>)</span><br><span class="line">    <span class="comment">#通过属性值查找 ， test可以是待查找的字符串，可以通过正则表达式查询</span></span><br><span class="line">    <span class="comment">#href^= &quot;&quot; , href$= , href*= , 进行正则判断。</span></span><br><span class="line">    soup.select(<span class="string">&#x27;a[href=&quot;test&quot;]&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网络爬虫：是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。&lt;/p&gt;
&lt;p&gt;网络爬虫可以分为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;通用网络爬虫&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过搜索引擎搜索关键词，然后从搜索引擎返回的数据
      
    
    </summary>
    
      <category term="爬虫" scheme="http://example.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="http://example.com/tags/Python/"/>
    
      <category term="爬虫" scheme="http://example.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫与开发项目实战——第一回合</title>
    <link href="http://example.com/wiki/%E7%88%AC%E8%99%AB/Python%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E4%B8%8E%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    <id>http://example.com/wiki/爬虫/Python爬虫开发与项目实战/</id>
    <published>2021-11-15T07:44:24.136Z</published>
    <updated>2021-11-17T02:40:05.260Z</updated>
    
    <content type="html"><![CDATA[<h5 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h5><font color="red" size=3>&nbsp;&nbsp;&nbsp;&nbsp;这一系列主要是对爬虫进一步深入了解,学习之前已经了解过爬虫，并编写过相应的代码，现在阅读书籍，进一步对爬虫的原理进行理解。大家可以通过该系列的开发过程，掌握爬虫的运用，以及进一步了解爬虫的原理。</font><ol><li><h6 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h6></li></ol><p>把内存中的变量变成可存储或可传输的过程，就是序列化。将内存中的变量序列化之后，可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上，实现程序状态的保存和共享。反过来，把变量内容从序列化的对象重新读取到内存，称为反序列化。</p><blockquote><p>也就是说，序列化就是保存了变量的一个快照(某个时刻的值)。反序列化就是根据保存的快照，将值赋值给变量，这样就回到了那个时刻(因为各个变量的值都一样)。<br>Python对序列化的支持：cPickle和pickle来实现序列化。一般都是先导入cPickle模块。实例代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 导入序列化模块</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> cPickle <span class="keyword">as</span> pickle</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    pickle实现序列化主要使用dumps方法或dump方法，</span></span><br><span class="line"><span class="string">    dumps方法可以将任意对象序列化成一个str，然后可以将这个str写入文件进行保存.</span></span><br><span class="line"><span class="string">    dump方法可以将序列化后的对象直接写入到文件中</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    pickle实现反序列化，主要通过loads或load方法，把序列化后的文件从磁盘上读取一个str，然后使用loads方法将str转化位对象</span></span><br><span class="line"><span class="string">    或者直接使用load方法将文件直接反序列化位对象</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#dumps</span></span><br><span class="line">d = <span class="built_in">dict</span>(url=<span class="string">&quot;index.html&quot;</span>,title=<span class="string">&quot;首页&quot;</span>,content=<span class="string">&quot;首页&quot;</span>)</span><br><span class="line"><span class="built_in">str</span> = pickle.dumps(d)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#dump</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">r&#x27;dump.txt&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">pickle.dump(d,f)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过load方法</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">r&#x27;dump.txt&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">d = pickle.load(f)</span><br><span class="line">f.close()</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure></p></blockquote><ol><li><h6 id="进程和多进程"><a href="#进程和多进程" class="headerlink" title="进程和多进程"></a>进程和多进程</h6></li></ol><p>python对多进程的方法：一种通过os模块的fork方法(适用于unix和linux操作系统)，一种通过multiprocessing模块(跨平台的实现方式)。这里主要采用Multiprocessing来创建多进程.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#multiprocessing模块创建多进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#通过Process类来描述一个进程对象，创建子进程时，只需要传入一个执行函数和函数参数，</span></span><br><span class="line"><span class="comment">#即可完成一个Process实例的创建，用strt()方法启动进程，用join方法实现进程间的同步</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#子进程要执行的代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_proc</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Child process %s (%s) Running...&#x27;</span>%(name,os.getpid()))</span><br><span class="line"></span><br><span class="line"><span class="comment">##进程池任务</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_task</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task %s (pid=%s) is runing...&#x27;</span>%(name,os.getpid()))</span><br><span class="line">    time.sleep(random.random()*<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task %s end.&#x27;</span>%name)</span><br><span class="line"><span class="comment">#写数据进程执行的代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proc_write</span>(<span class="params">q,urls</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Process(%s) is writing...&#x27;</span>%os.getpid())</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        q.put(url)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Put %s queue...&#x27;</span>%url)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"><span class="comment">#读数据进程执行的代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proc_read</span>(<span class="params">q</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Process(%s) is reading&#x27;</span>%os.getpid())</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        url = q.get(<span class="literal">True</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Get %s from queue.&#x27;</span>%url)</span><br><span class="line"><span class="function"><span class="keyword">def</span> 多进程():</span></span><br><span class="line">    <span class="comment"># print(&#x27;Parent process %s.&#x27;%os.getpid())</span></span><br><span class="line">    <span class="comment"># for i in range(5):</span></span><br><span class="line">    <span class="comment">#     p = Process(target=run_proc,args=(str(i),))#指定子进程要执行的方法，以及传递的参数</span></span><br><span class="line">    <span class="comment">#     print(&#x27;Process will start.&#x27;)</span></span><br><span class="line">    <span class="comment">#     p.start()</span></span><br><span class="line">    <span class="comment"># p.join()</span></span><br><span class="line">    <span class="comment"># print(&#x27;Process end&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过进程池创建多个进程</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Current process %s.&#x27;</span> % os.getpid())</span><br><span class="line">    p = Pool(processes=<span class="number">3</span>)  <span class="comment"># 创建进程池，指定进程池中进程的个数，默认位CPU核数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        p.apply_async(run_task, args=(i,))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Waiting for all subprocess done ...&#x27;</span>)</span><br><span class="line">    p.close()  <span class="comment"># g关闭进程池，就不能继续向进程池中添加新的任务</span></span><br><span class="line">    p.join()  <span class="comment"># 使用join表示等待所有子进程结束</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进程通信 通过Queue或者Pipe(一般用于两个进程通信)实现进程通信</span></span><br><span class="line">    <span class="comment"># 通过Queue进行get和put操作，可以设置blocked和timeout两个属性，blocked是设定操作是否阻塞</span></span><br><span class="line">    <span class="comment"># timeout是设置操作的等待时间。</span></span><br><span class="line">    q = Queue()  <span class="comment"># 创建消息队列</span></span><br><span class="line">    proc_write1 = Process(target=proc_write, args=(q, [<span class="string">&#x27;url_1&#x27;</span>, <span class="string">&#x27;url_2&#x27;</span>, <span class="string">&#x27;url_3&#x27;</span>]))</span><br><span class="line">    proc_write2 = Process(target=proc_write, args=(q, [<span class="string">&#x27;url_4&#x27;</span>, <span class="string">&#x27;url_5&#x27;</span>, <span class="string">&#x27;url_6&#x27;</span>]))</span><br><span class="line">    proc_reader = Process(target=proc_read, args=(q,))</span><br><span class="line">    <span class="comment"># 启动子进程proc_writer写入</span></span><br><span class="line">    proc_write1.start()</span><br><span class="line">    proc_write2.start()</span><br><span class="line">    <span class="comment"># 启动子进程读取</span></span><br><span class="line">    proc_reader.start()</span><br><span class="line">    <span class="comment"># 等待写入结束</span></span><br><span class="line">    proc_write1.join()</span><br><span class="line">    proc_write2.join()</span><br><span class="line">    <span class="comment"># 由于读取是死循环，所以只能强行终止</span></span><br><span class="line">    proc_reader.terminate()</span><br></pre></td></tr></table></figure></p><ol><li><h6 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h6></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#多线程</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_run</span>(<span class="params">urls</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Current %s is running ...&#x27;</span>%threading.current_thread().name)</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s ------&gt;&gt;&gt; %s&#x27;</span>%(threading.current_thread().name,url))</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s ended.&#x27;</span>% threading.current_thread().name)</span><br><span class="line"></span><br><span class="line"><span class="comment">#继承创建线程类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,urls</span>):</span></span><br><span class="line">        threading.Thread.__init__(self,name=name)</span><br><span class="line">        self.urls =urls</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Current %s is running ...&#x27;</span> % threading.current_thread().name)</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> self.urls:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s ------&gt;&gt;&gt; %s&#x27;</span> % (threading.current_thread().name, url))</span><br><span class="line">            time.sleep(random.random())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s ended.&#x27;</span> % threading.current_thread().name)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;in&#x27;</span>)</span><br><span class="line">    <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        多线程，线程类似于执行多个不同的程序，多线程可以将允许时间长的任务放到后台处理。</span></span><br><span class="line"><span class="string">        Python对多线程的支持，thread和threading，一般我们使用threading模块</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is running...&#x27;</span>%threading.current_thread().name)</span><br><span class="line">    t1 = threading.Thread(target=thread_run,name=<span class="string">&#x27;Thread_1&#x27;</span>,args=([<span class="string">&#x27;url_1&#x27;</span>,<span class="string">&#x27;url_2&#x27;</span>,<span class="string">&#x27;url_3&#x27;</span>],))</span><br><span class="line">    t2 = threading.Thread(target=thread_run, name=<span class="string">&#x27;Thread_2&#x27;</span>, args=([<span class="string">&#x27;url_4&#x27;</span>, <span class="string">&#x27;url_5&#x27;</span>, <span class="string">&#x27;url_6&#x27;</span>],))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s ended.&#x27;</span>%threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#自定义线程类</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is running...&#x27;</span> % threading.current_thread().name)</span><br><span class="line">    t1 = MyThread(  name=<span class="string">&#x27;Thread_1&#x27;</span>, urls=([<span class="string">&#x27;url_1&#x27;</span>, <span class="string">&#x27;url_2&#x27;</span>, <span class="string">&#x27;url_3&#x27;</span>]))</span><br><span class="line">    t2 = MyThread(  name=<span class="string">&#x27;Thread_2&#x27;</span>, urls=([<span class="string">&#x27;url_4&#x27;</span>, <span class="string">&#x27;url_5&#x27;</span>, <span class="string">&#x27;url_6&#x27;</span>]))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s ended.&#x27;</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">    <span class="comment">##线程同步</span></span><br><span class="line">    <span class="comment">##一般通过Thread的Lock和RLock实现简单的线程同步，两个对象都有acquire和release方法</span></span><br><span class="line">    mylock = threading.RLock() <span class="comment">#创建一个锁</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">myThread1</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">            threading.Thread.__init__(self,name=name)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">            <span class="keyword">global</span> num</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                mylock.acquire()</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;%s locked,Number :%d&#x27;</span>%(threading.current_thread().name,num))</span><br><span class="line">                <span class="keyword">if</span> num &gt;=<span class="number">4</span> :</span><br><span class="line">                    mylock.release()</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;%s released, Number: %s&#x27;</span>%(threading.current_thread().name,num))</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;%s released Number %s&#x27;</span>%(threading.current_thread().name,num))</span><br><span class="line">                mylock.release()</span><br><span class="line">    thread1 = myThread1(<span class="string">&#x27;Thread_1&#x27;</span>)</span><br><span class="line">    thread2 = myThread1(<span class="string">&#x27;Thread_2&#x27;</span>)</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>协程</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#各个协程执行的任务</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_task</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Visis --&gt; %s&#x27;</span>%url)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data  = urllib3.connection_from_url(url=url).urlopen(url=url,method=<span class="string">&quot;GET&quot;</span>).data</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s bytes received from %s.&#x27;</span>%(<span class="built_in">len</span>(data),url))</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;in&#x27;</span>)</span><br><span class="line">    <span class="comment"># 协程又称微线程(纤程),用户级的轻量级线程</span></span><br><span class="line">    <span class="comment">#协程能够保留上一次调用时的状态</span></span><br><span class="line">    <span class="comment">#Python对写出的支持通过gevent库，Python通过yield提供对协程的基本支持但是不完全，所以使用</span></span><br><span class="line">    <span class="comment">#gevent更加好</span></span><br><span class="line">    <span class="comment">#gevent实际上是greenlet在实现切换工作。如果出现io阻塞的时候，gevent会自动切换到没有阻塞的代码执行</span></span><br><span class="line">    <span class="comment">#所以gevent一直保持greenlet在允许</span></span><br><span class="line">    urls = [<span class="string">&#x27;https://github.com/&#x27;</span>,<span class="string">&#x27;https://www.python.org/&#x27;</span>,<span class="string">&#x27;http://www.baidu.com/&#x27;</span>] <span class="comment"># 各个协程访问的网址</span></span><br><span class="line">    greenlets = [gevent.spawn(run_task,url) <span class="keyword">for</span> url <span class="keyword">in</span> urls] <span class="comment"># 这里将各个协程加入到greenlets中</span></span><br><span class="line">    gevent.joinall(greenlets=greenlets) <span class="comment">#进行执行各个协程</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>分布式进程</li></ol><p>分布式进程：分布式也就是将计算任务分布到多个计算机上进行运算，然后将结果返回。分布式进程也就是指，将Process进程分不到多台机器，利用多台机器的性能，完成复杂的任务。</p><p>对于分布式进程，通过multiprocessing模块的managers子模块，将多线程分布到多台机器上。</p><p>一般我们通过分布式处理任务，将某块的任务分配给某个机器执行，然后某个功能模块给其他模块执行。将任务分成多个计算机集群进行处理，提高速度。例如爬取图片，可以一个计算机专门爬取图片链接，然后多个计算机专门根据爬取到的图片链接下载图片。<br>将中间处理的结果，让其他机器进程都能访问的过程称为本地队列的网络化。过程如下所示：<br><img src="/images/分布式.PNG" alt="a5"></p><p>两个实现代码</p><p>taskManager.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">from</span> multiprocessing.managers <span class="keyword">import</span> BaseManager</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> freeze_support</span><br><span class="line"></span><br><span class="line"><span class="comment">#服务进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#任务个数</span></span><br><span class="line">task_number = <span class="number">10</span></span><br><span class="line"><span class="comment">#定义收发队列</span></span><br><span class="line">task_queue = queue.Queue(task_number)</span><br><span class="line">result_queue = queue.Queue(task_number)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_task</span>():</span></span><br><span class="line">    <span class="keyword">return</span> task_queue</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_result</span>():</span></span><br><span class="line">    <span class="keyword">return</span> result_queue</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建类似的QueueManager</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueManager</span>(<span class="params">BaseManager</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">win_run</span>():</span></span><br><span class="line">    <span class="comment">#Windows下绑定调用接口</span></span><br><span class="line">    QueueManager.register(<span class="string">&#x27;get_task_queue&#x27;</span>,<span class="built_in">callable</span>=get_task)</span><br><span class="line">    QueueManager.register(<span class="string">&#x27;get_result_queue&#x27;</span>,<span class="built_in">callable</span>=get_result)</span><br><span class="line">    <span class="comment">#绑定端口并设置验证口令，Windows下需要填写IP地址</span></span><br><span class="line">    manager = QueueManager(address=(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8001</span>),authkey=<span class="string">&#x27;qiye&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="comment">#启动</span></span><br><span class="line">    manager.start()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#通过网络获取任务队列和结果队列</span></span><br><span class="line">        task = manager.get_task_queue()</span><br><span class="line">        result = manager.get_result_queue()</span><br><span class="line">        <span class="comment">#添加任务</span></span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> [<span class="string">&#x27;ImageUrl_&#x27;</span>+<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;put task %s...&#x27;</span>%url)</span><br><span class="line">            task.put(url)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;try get result...&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;result is %s &#x27;</span>%result.get(timeout=<span class="number">10</span>))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Manager error&#x27;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment">#一定要关闭，否则会报管道未关闭的错误</span></span><br><span class="line">            manager.shutdown()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment">#Windows多线程可能有问题，进行缓解</span></span><br><span class="line">    freeze_support()</span><br><span class="line">    win_run()</span><br></pre></td></tr></table></figure></p><p>taskWorker.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing.managers <span class="keyword">import</span>  BaseManager</span><br><span class="line"></span><br><span class="line"><span class="comment">#处理进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建类似的QueueManager</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueManager</span>(<span class="params">BaseManager</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment">#第一步使用Queuemanager注册用于获取Queueu的方法名称</span></span><br><span class="line">QueueManager.register(<span class="string">&#x27;get_task_queue&#x27;</span>)</span><br><span class="line">QueueManager.register(<span class="string">&#x27;get_result_queue&#x27;</span>)</span><br><span class="line"><span class="comment">#第二部连接到服务器</span></span><br><span class="line">server_addr =  <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Connect to server %s...&#x27;</span>%server_addr)</span><br><span class="line"><span class="comment">#端口哦和验证口令</span></span><br><span class="line">m = QueueManager(address=(server_addr,<span class="number">8001</span>),authkey=<span class="string">&#x27;qiye&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment">#从网络链接</span></span><br><span class="line">m.connect()</span><br><span class="line"><span class="comment">#第三步获取Queue的对象</span></span><br><span class="line">task = m.get_task_queue()</span><br><span class="line">result = m.get_result_queue()</span><br><span class="line"><span class="comment">#第四步，从task队列获取任务，把结果写入到result队列</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">not</span> task.empty()):</span><br><span class="line">    image_url = task.get(<span class="literal">True</span>,timeout=<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;run task download %s...&#x27;</span>%image_url)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    result.put(<span class="string">&quot;%s---&gt;success&quot;</span>%image_url)</span><br><span class="line"><span class="comment">#处理结束</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;worker exit .&#x27;</span>)</span><br></pre></td></tr></table></figure></p><ol><li>网络编程</li></ol><p>两台计算机之间的通信，实际上是两台计算机，端口之间的通信。当在浏览器浏览网页的时候，实际上就是本地计算机的一个端口进程和服务器的某个端口进程建立了连接，并进行通信。</p><p>一般通过Socket（套接字）,描述通信。Socket由ip+端口组成。Python提供了两个Socket模块。<br>Socket：提供了标准的BSD Sockets API<br>SocketServer: 提供了服务器中心类，可以简化网络服务器的开发。</p><blockquote><p>Socket类型<br>套接字格式为：socket(family,type[,protocal]),使用给定的地址族，套接字类型，协议编号（默认为0）来创建套接字。<br>套接字类型如下所示：<br><img src="/images/Socket类型.PNG" alt="a6"></p><p>Socket常用函数<br><img src="/images/Socket2.PNG" alt="a61"></p><p>TCP编程</p></blockquote><p>TCP-Server.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 网络编程包含两个部分：服务端和客户端</span></span><br><span class="line"><span class="comment"># TCP是面向连接的通信方式</span></span><br><span class="line"><span class="comment"># 主动发起连接的叫做客户端</span></span><br><span class="line"><span class="comment"># 被动响应连接的叫服务端</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建TCP服务端</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1. 创建Socket,绑定Socket到本地IP与端口</span></span><br><span class="line"><span class="string">2. 开始监听连接</span></span><br><span class="line"><span class="string">3. 进入循环，不断接收客户端的连接请求</span></span><br><span class="line"><span class="string">4.接收传来的数据，并发送给对方数据</span></span><br><span class="line"><span class="string">5.传输完毕后，关闭Socket</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dealClient</span>(<span class="params">sock,addr</span>):</span></span><br><span class="line">    <span class="comment"># 第四步：接收传来的数据，并发送给对方数据</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Accept new connection from %s:%s...&#x27;</span>%(sock,addr))</span><br><span class="line">    sock.send(<span class="string">b&#x27;Hello,I am server!&#x27;</span>)<span class="comment">#发送数据</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = sock.recv(<span class="number">1024</span>) <span class="comment">#接收数据</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data <span class="keyword">or</span> data.decode(<span class="string">&#x27;utf-8&#x27;</span>) == <span class="string">&#x27;exit&#x27;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;----&gt;&gt;&gt;%s!&#x27;</span>%data.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        sock.send((<span class="string">&#x27;Loop_Msg:%s!&#x27;</span>%data.decode(<span class="string">&#x27;utf-8&#x27;</span>)).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="comment">#关闭Socket</span></span><br><span class="line">    sock.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Connection from %s:%s closed.&#x27;</span>%(sock,addr))</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment">#第一步：创建基于IPv4和TCP协议的Socket</span></span><br><span class="line">    <span class="comment">#Socket绑定IP（127.0.0.1为本机IP）与端口</span></span><br><span class="line">    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    s.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9999</span>))</span><br><span class="line">    <span class="comment">#第二步：监听连接</span></span><br><span class="line">    s.listen(<span class="number">5</span>)<span class="comment">#最大连接数量</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Waiting for connection...&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment">#第三步: 接收一个新连接</span></span><br><span class="line">        sock,addr = s.accept()</span><br><span class="line">        <span class="comment">#创建新线程来处理TCP连接</span></span><br><span class="line">        t = threading.Thread(target=dealClient,args=(sock,addr,))</span><br><span class="line">        t.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>TCP-Client.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#TCP客户端</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1.创建Socket，连接远端地址</span></span><br><span class="line"><span class="string">2.连接后发送数据和接收数据</span></span><br><span class="line"><span class="string">3.传输完毕后，关闭Socket</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="comment">#初始化Socket</span></span><br><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"><span class="comment">#连接目标的ip和端口</span></span><br><span class="line">s.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9999</span>))</span><br><span class="line"><span class="comment">#接收消息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;---&gt;&gt;&gt;&#x27;</span>+s.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment">#发送消息</span></span><br><span class="line">s.send(<span class="string">b&#x27;Hello,I am Client&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;---&gt;&#x27;</span>+s.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">s.send(<span class="string">b&#x27;exit&#x27;</span>)</span><br><span class="line"><span class="comment">#关闭Socket</span></span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure></p><blockquote><p>UDP编程</p></blockquote><p>UDP-Server.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># UDP 服务器端</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">UDP是面向无连接的协议。使用UDP协议时，不需要建立连接，只需要直到对方的IP地址和端口号，就可以直接发数据包。</span></span><br><span class="line"><span class="string">并不关心能够到达目的端。对于不要求可靠到达的数据，就可以使用UDP协议。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">服务端创建过程：</span></span><br><span class="line"><span class="string">    1. 创建Socket，绑定指定的ip和端口</span></span><br><span class="line"><span class="string">    2. 直接发送数据和接收数据</span></span><br><span class="line"><span class="string">    3. 关闭Socket</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Socket,绑定指定IP和端口</span></span><br><span class="line"><span class="comment"># SOCK_DGRAM指定了这个Socket的类型是UDP，绑定端口和TCP示例一样</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">s.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Bind UDP on 9999...&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 直接发送数据和接收数据</span></span><br><span class="line">    data, addr = s.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Received from %s:%s. &#x27;</span> %(addr,data.decode(<span class="string">&#x27;utf-8&#x27;</span>)))</span><br><span class="line">    s.sendto(<span class="string">b&#x27;Hello,!&#x27;</span>, addr)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>DUP-Client.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#UDP的客户端</span></span><br><span class="line"><span class="comment"># UDP客户端，创建Socket即可与服务器数据交换。</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> [<span class="string">b&#x27;Hello&#x27;</span>,<span class="string">b&#x27;World&#x27;</span>]:</span><br><span class="line">    <span class="comment">#发送数据</span></span><br><span class="line">    s.sendto(data,(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9999</span>))</span><br><span class="line">    <span class="comment">#接收数据</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(s.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><blockquote><p>小结</p></blockquote><p>两个计算机之间的通信是端口进程之间的通信。端口属于应用层。对于应用层之间的数据，通过运输层提供相应的数据。运输层的协议，有TCP和UDP传输协议。</p><p>对于TCP协议，是面向连接的，所以在使用tcp协议传送数据的时候，需要保证两个通信的主机建立了连接，然后再进行数据的传输。<br>&gt;</p><blockquote><p>  所以对于TCP而言，服务器和客户端的连接步骤<br>对于TCP服务器：</p><ol><li>创建Socket，绑定到对应端口</li><li>监听端口，检测是否有连接</li><li>如果有客户端连接，接收客户端连接，可以获得客户端的套接字</li><li>建立连接后，可以循环监听接收客户端发送的数据，也可发送数据给客户端</li><li>会话完毕，就可以关闭连接</li></ol><p>对于TCP客户端</p><ol><li>创建Socket</li><li>连接到服务器，然后建立连接</li><li>发送，接收数据</li><li>会话完毕，关闭连接</li></ol></blockquote><p>对于UDP协议，是面向无连接的，所以在使用UDP协议的时候，并不需要确定双方是否建立了连接，直接向对应的（地址，端口号），发送数据即可，不关心是否发送成功。同理，接收数据也是直接接收即可。因为发送的时候就是直接发到对应主机，然后接收直接接收即可。</p><blockquote><p>对于UDP服务器</p><ol><li>创建Socket,绑定端口</li><li>监听端口，查看是否有数据</li><li>接收到数据（data,addr），可以发送给数据到指定的addr</li></ol><p>对于UDP客户端</p><ol><li>创建Socket</li><li>向服务器(addr,post)发送数据</li><li>可以监听自己的计算机，是否有其他计算机发送的数据</li></ol><p>总结</p></blockquote><p>从上面TCP/UDP客户端和服务器的创建过程可以比较出，TCP需要确定连接，而对于UDP而言不需要确定是否连接成功。</p><ol><li>WEB前端基础</li></ol><blockquote><p>W3C标准</p></blockquote><p>W3C即万维网联盟，W3C标准是一系列标准的集合。</p><p>一个网页由三部分组成：结构(Structure),表现(Presentation),行为(Behavior)。对应</p><p>结构化标准语言：XHTML，XML<br>表现标准语言：CSS<br>行为标准：对象模型(如W3C DOM)，ECMAScript等。</p><p>HTML（超文本标记语言），也就是是一种标签语言。</p><p>CSS(层叠样式表): 用于解决内容和表现的分离。CSS主要由选择器+属性构成。选择器用于指定渲染元素，属性用于指定渲染效果。</p><p>JavaScript（轻量级脚本语言）</p><p>XPath: 一门在XML文档中查找信息的语言。</p><p>JSON：JavaScript对象表示法，用于存储和交换文本信息。</p><p>HTTP协议(超文本传输协议)，用于从www服务区传输超文本到本地浏览器的传送协议。HTTP协议永远都是客户端发起请求，服务器会送响应。</p><p>HTTP协议是一个无状态协议，同一个客户端的这次请求和上次请求没有对应关系。</p><p>HTTP状态码：</p><p>200—请求成功<br>301—资源网页被永久转移到其他URL<br>404—请求的资源不存在<br>500—内部服务器错误</p><p>1开头一般表示服务器收到请求，需要请求者继续执行操作<br>2开头一般表示请求操作成功<br>3开头一般表示重定向<br>4开头一般表示客户端错误<br>5开头一般表示服务器错误</p><blockquote><p>Cookie和Session都用于保存状态信息，Cookie保存在客户端，Session保存在服务器端。</p></blockquote><p>Cookie：服务器给每个Session分配一个唯一的JSESSIONID，并通过Cookie发送给客户端，当客户端发起新的请求的时候，将在Cookie头中携带JSESSIONID。这样服务器就能够找到这个客户端对应的Session。</p><p><img src="/images/Cookie.PNG" alt="a7"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h5&gt;&lt;font color=&quot;red&quot; size=3&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这一系列主要是对爬虫进一步深入了
      
    
    </summary>
    
      <category term="爬虫" scheme="http://example.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="http://example.com/tags/Python/"/>
    
      <category term="爬虫" scheme="http://example.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>4. Java对象与类</title>
    <link href="http://example.com/wiki/JavaSE/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/class/"/>
    <id>http://example.com/wiki/JavaSE/第四章-对象与类/class/</id>
    <published>2021-11-03T07:05:53.433Z</published>
    <updated>2021-11-15T07:43:27.465Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象程序设计OOP(Object Oriented Programming)。</p><p>类用于描述对象所具有的属性和方法，具体的对象称为类的一个实例。</p><p>封装也就是将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式。</p><p>对象的三个特性，行为，状态，标识。</p><p>对象的行为描述了对象具有哪些操作，对象的状态（状态也就是对象当前的特征信息）决定了在不同情况下相应的操作的响应，对象的标识描述了不同的实例对象。</p><blockquote><p>类之间的关系</p></blockquote><ol><li><p>依赖关系(uses-a)</p><p> 如果一个类A的方法使用了另一个类B，那么就形成了依赖关系。<br> A依赖于B。（过多的依赖会使得类之间的耦合度高）</p></li><li><p>聚合关系(has-a)</p><p> 如果类A包含一些类B，那么A和B是聚合关系。</p></li><li><p>继承关系(is-a)</p><p> 父类和子类的关系，也就是继承关系。</p></li></ol><p>UML（Unified Modeling Language,统一建模语言）中类关系的表示：<br><img src="/images/UML.PNG" alt="a1"></p><p>Java中的对象通过new进行创建，通过new创建一个新的对象变量。一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。通过new 操作符的返回值也是一个引用。这可以理解为Java中所有的对象变量实际上就是一个指针，指向实际对象所在的地址。</p><blockquote><ol><li>更改器方法(get),访问器方法(set)</li></ol></blockquote><p>注意不要编写返回引用可变对象的访问器方法。如果返回了可变对象，那么在类外部对返回对象的改变，同时也会影响到类内部的变量。<br>如果需要返回一个可变对象的引用，首先因该对它进行克隆(clone)。对象的clone是指存放在另一个位置上的对象副本。<br>如果需要返回一个可变数据域的拷贝，就应该使用 clone。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Employee other)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name.equals(other.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上段代码，我们可以看出，在equals方法中，调用了other的私有变量。对于Javaa来说，类的方法可以访问该类的任何对象的遍私有变量。<br>类方法可以访问所属类的私有特性。</p><blockquote><ol><li>构造器</li></ol></blockquote><pre><code>•构造器与类同名•每个类可以有一个以上的构造器•构造器可以有 0 个、1 个或多个参数•构造器没有返回值•构造器总是伴随着 new 操作一起调用</code></pre><blockquote><ol><li>隐式参数与显示参数</li></ol></blockquote><p>以下列代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> a ;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.a;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们对于方法setA,可以看出对于参数a是显示的参数。而隐式参数是谁呢？隐式参数是调用该方法调用的类对象，通过关键字this表示隐式参数。</p><p>第一个参数称为隐式 （ implicit ) 参数， 是出现在方法名前的Employee 类对象。第二个参数位于方法名后面括号中的数值，这是一个显式 （ explicit)参数（ 有些人把隐式参数称为方法调用的目标或接收者。</p><p>也就是说，this表明该方法的调用者。</p><blockquote><ol><li>访问修饰符</li></ol></blockquote><div class="table-container"><table><thead><tr><th>修饰符</th><th>作用</th><th>作用域</th></tr></thead><tbody><tr><td>public</td><td>公开的</td><td>任意类都能访问</td></tr><tr><td>private</td><td>私有的</td><td>只能被定义它们的类使用</td></tr><tr><td>final</td><td>final 修饰符大都应用于基本 （primitive ) 类型域，或不可变（immutable)类的域（如果类中的每个方法都不会改变其对象， 这种类就是不可变的类)。</td></tr><tr><td>static</td><td>静态域（类域）和静态方法。对于静态域变量，该变量属于类，而不属于任何独立的对象，通过类就能够直接访问到静态域变量(公开的)，实例对象，也能够访问到该变量，但是该变量属于类，所有对象访问到的静态域对象都是一样的。对于静态域一般可以用于设置静态常量，通过类名就能引用，但是不会被修改。对于静态方法，加在方法名之前，静态方法可以通过类名直接调用，静态方法不属于单独的对象。静态方法不具有this参数，所以静态方法不能访问非静态域的实例域。</td></tr></tbody></table></div><p>在下面两种情下使用静态方法：</p><ol><li>一 方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如：Math.pow) </li><li>一个方法只需要访问类的静态域（例如：Employee.getNextld）。</li></ol><h4 id="初始化数据域"><a href="#初始化数据域" class="headerlink" title="初始化数据域"></a>初始化数据域</h4><blockquote><p>默认域初始化</p></blockquote><p>如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值： 数值为 0、布尔值为 false、 对象引用为 null。<br>尽量对对象进行赋初始值，而不是采用默认初始值</p><blockquote><p>构造器初始化<br>通过this可以调用同一个类的另一个构造器。如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String <span class="keyword">double</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// calls Employee(String, double)</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="string">&quot;Employee #&quot;</span> + nextld, s);</span><br><span class="line">    nextld++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过this，引用到了同一个Employee的另一个的构造函数，对类对象进行初始化。</p><p>在声明中赋值</p><p>在初始化块赋值</p></blockquote><p>初始块也就是通过{}包含的一段代码块。只要构造类的对象，这些块就会被执行。初始化块的执行顺序，首先运行初始化块，然后才运行构造器的主体部分。</p><p>对于静态域的初始化，需要加上关键字static<br>static{<br>    //进行初始化<br>}</p><blockquote><p>Java调用构造器的步骤</p></blockquote><ol><li>所有数据域被初始化默认值(0,false,null)</li><li>按照类声明中出现的次序，依次执行所有域初始化语句或初始化块。</li><li>如果构造器第一行调用了其它构造器，则调用其它构造器</li><li>执行这个构造器主体。</li></ol><p>构造器是最后执行的，先执行声明和代码块语句。</p><h4 id="Java参数调用"><a href="#Java参数调用" class="headerlink" title="Java参数调用"></a>Java参数调用</h4><p>方法参数共有两种类型：</p><ol><li>基本数据类型（数字、布尔值K</li><li>对象引用。</li></ol><p>Java 程序设计语言总是采用按值调用。也就是说， 方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。一个方法，无法改变基本数据类型的参数，但是对象引用作为参数就不同了。对于引用参数就不一样了，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</p><blockquote><p>总结</p></blockquote><ol><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li><li>一个方法可以改变一个对象参数的状态。</li><li>一个方法不能让对象参数引用一个新的对象。（因为Java的引用对象，并不是真正的引用(只是值的传递),可以通过反证进行证明）</li></ol><h4 id="重载-overloading-和重写-overwrite"><a href="#重载-overloading-和重写-overwrite" class="headerlink" title="重载(overloading)和重写(overwrite)"></a>重载(overloading)和重写(overwrite)</h4><blockquote><p>重载</p></blockquote><p>如果多个方法（比如， StringBuilder 构造器方法）有相同的名字、 不同的参数，便产生了重载。对于不同的重载方法， 通过方法给出的参数类型和特定的方法调用所使用的值类型进行匹配来挑选相应的方法（返回值不作为特征）。。如果编译器找不到匹配的参数， 就会产生编译时错误，因为根本不存在匹配， 或者没有一个比其他的更好。（这个过程被称为重载解析（overloading resolution)。）</p><p>对于一个方法的签名(signature)，包含方法名，方法参数类型构成。方法签名=方法名(参数类型)。</p><blockquote><p>重写</p></blockquote><h4 id="Java的包"><a href="#Java的包" class="headerlink" title="Java的包"></a>Java的包</h4><p>Java允许使用包(package)将类组织起来，借助于包可以方便地组织自己的代码，并将自己的代码与别人提供的代码库分开管理。使用包的主要原因是确保类名的唯一性(全限定类名)，一般我们对包名的命名规则是以因特网域名的逆序形式作为包名，并且对于不同的项目使用不同的子包。</p><p>一个类可以使用所属包中的所有类，以及其他包中的公有类(public class)。</p><p>import语句不仅可以导入类，还增加了导入静态方法和静态域的功能。</p><blockquote><p>import static java.lang.System.*<br>通过上述语句就可以直接使用System类的静态方法和静态域，而不必加类名前缀。<br>这样就可以直接在程序中使用out.println(“hello world”);而不用加前缀。</p></blockquote><p>把一个类放到一个包中， 需要通过package 指定所属的包。如果没有设置，则类被放在默认的包(default package)。</p><blockquote><p>对于包的作用域</p></blockquote><p>对于标记public部分，可以被任意的类使用。标记为private部分，只能被定义它们的类使用。如果没有指定public或private，这个部分(类，方法或变量)可以被同一个包中的所有方法访问。</p><blockquote><p>类路径</p></blockquote><p>为了使类能够被多个程序共享，需要做到下面几点：</p><p>1 ) 把类放到一个目录中， 例如 /home/user/classdir。需要注意， 这个目录是包树状结构的基目录。如果希望将 com.horstmann.corejava.Employee 类添加到其中，这个Employee.class类文件就必须位于子目录 /home/user/classdir/com/horstmann/corejava 中。</p><p>2 ) 将 JAR 文件放在一个目录中，例如：/home/user/archives。</p><p>3 ) 设置类路径（classpath)。类路径是所有包含类文件的路径的集合。</p><h4 id="类路径包括："><a href="#类路径包括：" class="headerlink" title="类路径包括："></a>类路径包括：</h4><p>•基目录 /home/user/classdir或 c:\classes；</p><p>•当前目录 (.);</p><p>•JAR 文件 /home/user/archives/archive.jar或c:\archives\archive.jar </p><p>从 Java SE 6 开始，可以在 JAR 文件目录中指定通配符，如下：/home/user/dassdir:.:/home/aser/archives/<em><br>或者c:\classdir;.;c:\archives\</em></p><blockquote><p>假定虚拟机要搜寻 com.horstmann.corejava.Employee 类文件。它首先要查看存储在 jre/<br>lib 和jre/lib/ext 目录下的归档文件中所存放的系统类文件。显然，在那里找不到相应的类文件，然后再查看类路径。然后查找以下文件：</p><blockquote><p>•/home/user/classdir/com/horstmann/corejava/Employee.class<br>•com/horstmann/corejava/Employee.class 从当前目录开始<br>•com/horstmann/corejava/Employee.class inside /home/user/archives/archive.jar</p></blockquote><p>设置类路径</p></blockquote><p>如果需要指定类的路径，可以借助-classpath来指定类路径。</p><h4 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h4><blockquote><p>通过/<em>* </em>/开始注释。</p></blockquote><p>对于代码的描述性句子，一般在/<em>* </em>/第一行进行编写，对于概要性的句子，可以使用HTML修饰符进行修饰(但是不要使用h1标签),如果需要键入等宽代码，使用{@code}。</p><blockquote><p>方法主要使用的注释</p></blockquote><p>@param 变量描述</p><p>@return 返回值描述</p><p>@throws 抛出异常描述</p><blockquote><p>通用注释</p></blockquote><p>@author 姓名<br>@version 版本信息<br>@since 从哪个版本开始加入的<br>@deprecated 描述该类或方法或变量不再使用<br>@see 增加一个超级链接 , 可以通过全限定类名作为超链接<br>eg: @see com.itheima.Employee#raiseSalary(double ),链接指向Employee下的raiseSalary(double)方法</p><blockquote><p>总结</p></blockquote><p>所有Java对象都是在堆中构造的，构造器总是伴随着new操作符一起使用。</p><h4 id="类设计技巧"><a href="#类设计技巧" class="headerlink" title="类设计技巧"></a>类设计技巧</h4><ol><li>数据私有</li><li>对数据初始化</li><li>不要再类中使用过多的基本类型</li><li>不是所有的域都需要独立的get/set方法</li><li>将职责过多的类进行分解</li><li>类名和方法名要能够体现它们的职责，也就是见名知义</li><li>优先使用不可变的类</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;面向对象程序设计OOP(Object Oriented Programming)。&lt;/p&gt;
&lt;p&gt;类用于描述对象所具有的属性和方法，具体的对象称为类的一个实例。&lt;/p&gt;
&lt;p&gt;封装也就是将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式。&lt;/p&gt;
&lt;p&gt;对象的
      
    
    </summary>
    
      <category term="JavaSE" scheme="http://example.com/categories/JavaSE/"/>
    
    
      <category term="JAVA" scheme="http://example.com/tags/JAVA/"/>
    
      <category term="JAVASE" scheme="http://example.com/tags/JAVASE/"/>
    
  </entry>
  
  <entry>
    <title>Anaconda配置</title>
    <link href="http://example.com/wiki/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/python/Anaconda/"/>
    <id>http://example.com/wiki/软件配置/python/Anaconda/</id>
    <published>2021-11-02T03:22:44.814Z</published>
    <updated>2021-11-02T03:25:18.217Z</updated>
    
    <content type="html"><![CDATA[<p>Anaconda下载地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/ </a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Anaconda下载地址：&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/&quot;&gt;https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/ &lt;/a&gt;
      
    
    </summary>
    
      <category term="软件配置" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    
      <category term="python配置" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/python%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="配置" scheme="http://example.com/tags/%E9%85%8D%E7%BD%AE/"/>
    
      <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>hexo使用问题</title>
    <link href="http://example.com/wiki/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/hexo/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>http://example.com/wiki/软件配置/hexo/问题解决/</id>
    <published>2021-11-01T07:32:29.409Z</published>
    <updated>2021-11-02T03:22:35.748Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何解决wiki中图片显示不全"><a href="#如何解决wiki中图片显示不全" class="headerlink" title="如何解决wiki中图片显示不全"></a>如何解决wiki中图片显示不全</h3><p>只需要把图片放在images文件夹下， 然后通过/images/xxx.xx进行引用即可，这是通过绝对路径进行引用。如果要通过相对路径引用则每个md需要创建相应的文件夹存放图片，较为麻烦。</p><h3 id="如何解决wiki中mermaid流程图无法显示的问题"><a href="#如何解决wiki中mermaid流程图无法显示的问题" class="headerlink" title="如何解决wiki中mermaid流程图无法显示的问题"></a>如何解决wiki中mermaid流程图无法显示的问题</h3><ol><li>修改 /theme/Wikitten下的config.yml文件</li></ol><p>讲下列代码粘贴到文件末尾<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mermaid: <span class="comment">## mermaid url https://github.com/knsv/mermaid</span></span><br><span class="line">enable: true  </span><br><span class="line"><span class="comment"># default true</span></span><br><span class="line">version: <span class="string">&quot;7.1.2&quot;</span></span><br><span class="line"><span class="comment"># default v7.1.2</span></span><br><span class="line">options:  </span><br></pre></td></tr></table></figure></p><ol><li>下载mermaid</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-filter-mermaid-diagrams</span><br></pre></td></tr></table></figure><ol><li>找到Wikitten下layout下 common/footer.ejs ,替换如下代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;footer id=<span class="string">&quot;footer&quot;</span>&gt;</span><br><span class="line">    &lt;% <span class="keyword">if</span> (theme.mermaid.enable) &#123; %&gt;</span><br><span class="line">        &lt;script src=<span class="string">&#x27;https://unpkg.com/mermaid@&lt;%= theme.mermaid.version %&gt;/dist/mermaid.min.js&#x27;</span>&gt;&lt;/script&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            <span class="keyword">if</span> (window.mermaid) &#123;</span><br><span class="line">                mermaid.initialize(&#123;</span><br><span class="line">                    theme: <span class="string">&#x27;forest&#x27;</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">        &lt;% &#125; %&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;outer&quot;</span>&gt;</span><br><span class="line">                &lt;div id=<span class="string">&quot;footer-info&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;inner&quot;</span>&gt;</span><br><span class="line">                    &lt;%= config.author || config.title %&gt; &amp;copy;</span><br><span class="line">                        &lt;%= date(<span class="keyword">new</span> Date(), <span class="string">&#x27;YYYY&#x27;</span>) %&gt;</span><br><span class="line">                            &lt;a rel=<span class="string">&quot;license&quot;</span> href=<span class="string">&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot;</span>&gt;&lt;img alt=<span class="string">&quot;Creative Commons License&quot;</span> style=<span class="string">&quot;border-width:0&quot;</span> src=<span class="string">&quot;https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png&quot;</span> /&gt;&lt;/a&gt;</span><br><span class="line">                            &lt;br&gt; Powered by &lt;a href=<span class="string">&quot;http://hexo.io/&quot;</span> target=<span class="string">&quot;_blank&quot;</span>&gt;Hexo&lt;/a&gt;. Theme - &lt;a href=<span class="string">&quot;https://github.com/zthxxx/hexo-theme-Wikitten&quot;</span>&gt;wikitten&lt;/a&gt;</span><br><span class="line">                            &lt;% <span class="keyword">if</span> (theme.plugins.busuanzi_count) &#123; %&gt;</span><br><span class="line">                                &lt;br&gt;</span><br><span class="line">                                &lt;span id=<span class="string">&quot;busuanzi_container_site_pv&quot;</span>&gt;&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;fa fa-eye&quot;</span>&gt;&lt;/i&gt; &lt;span id=<span class="string">&quot;busuanzi_value_site_pv&quot;</span>&gt;&lt;/span&gt;&lt;/span&gt;</span><br><span class="line">                                &amp;nbsp;|&amp;nbsp;</span><br><span class="line">                                &lt;span id=<span class="string">&quot;busuanzi_container_site_pv&quot;</span>&gt;&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;fa fa-user&quot;</span>&gt;&lt;/i&gt; &lt;span id=<span class="string">&quot;busuanzi_value_site_uv&quot;</span>&gt;&lt;/span&gt;&lt;/span&gt;</span><br><span class="line">                                &lt;% &#125; %&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">&lt;/footer&gt;</span><br></pre></td></tr></table></figure><h3 id="解决Wiki无法渲染数学公式的问题"><a href="#解决Wiki无法渲染数学公式的问题" class="headerlink" title="解决Wiki无法渲染数学公式的问题"></a>解决Wiki无法渲染数学公式的问题</h3><ol><li>执行下列指令</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><ol><li>找到../node_modules/kramed/lib/rules/inline.js</li></ol><p>修改如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,      第11行，将其修改为</span></span><br><span class="line">escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,</span><br><span class="line"><span class="comment">//em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,    第20行，将其修改为</span></span><br><span class="line">em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br></pre></td></tr></table></figure></p><ol><li>对需要使用MathJax公式的文章，修改文章标签,增加mathjax: true</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">mathjax: <span class="keyword">true</span></span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;如何解决wiki中图片显示不全&quot;&gt;&lt;a href=&quot;#如何解决wiki中图片显示不全&quot; class=&quot;headerlink&quot; title=&quot;如何解决wiki中图片显示不全&quot;&gt;&lt;/a&gt;如何解决wiki中图片显示不全&lt;/h3&gt;&lt;p&gt;只需要把图片放在images文件夹下
      
    
    </summary>
    
      <category term="软件配置" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    
      <category term="hexo" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/hexo/"/>
    
    
      <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
      <category term="bug" scheme="http://example.com/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow2笔记-LeNet(经典卷积网络)</title>
    <link href="http://example.com/wiki/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Tensorflow%E7%AC%94%E8%AE%B0/%E7%BB%8F%E5%85%B8%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C/"/>
    <id>http://example.com/wiki/机器学习/Tensorflow笔记/经典卷积网络/</id>
    <published>2021-11-01T02:11:58.082Z</published>
    <updated>2021-11-02T02:56:20.465Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>这里主要介绍卷积神经网络的经典网络，然后通过tensorflow进行实现（以上章的卷积神经网络实现代码为基础，进行实现）。</p><p>统计卷积网络神经网络层数一般只统计卷积计算层和全连接计算层。</p><blockquote><p>ImageNet</p></blockquote><p>ImageNet 是一个计算机视觉系统识别项目,是目前世界上图像识别最大的数据库。是美国斯坦福的计算机科学家，模拟人类的识别系统建立的。能够从图片识别物体。ImageNet是一个非常有前景的研究项目，未来用在机器人身上，就可以直接辨认物品和人了。</p><h3 id="经典卷积网络"><a href="#经典卷积网络" class="headerlink" title="经典卷积网络"></a>经典卷积网络</h3><pre class="mermaid">   graph LR    A(LeNet 1998) --> B(AlexNet 2012)    B --> C(VGGNet 2014)     C --> D(Inception Net 2014)     D --> E(ResNet 2015)</pre><h4 id="LeNet"><a href="#LeNet" class="headerlink" title="LeNet"></a>LeNet</h4><p>由Yann LeCun于1998年提出，卷积网络开篇之作。通过共享卷积核减少了网络的参数。LeNet如下所示(C5画错了是F5)</p><p><img src="/images/LeNet.PNG" alt="aaa"></p><p>LeNet提出的时候还没提出BN和Dropout层，所以LeNet网络不具有BN和Dropout层。</p><p>根据上图实现LeNet代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLeNet</span>(<span class="params">Model</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(MyLeNet, self).__init__()</span><br><span class="line">        self.c1 = Conv2D(filters=<span class="number">6</span>,kernel_size=(<span class="number">5</span>,<span class="number">5</span>),activation=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line">        self.p1 = MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>),strides=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        self.c2 = Conv2D(filters=<span class="number">16</span>,kernel_size=(<span class="number">5</span>,<span class="number">5</span>),activation=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line">        self.p2 = MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>),strides=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        self.flatten = Flatten()</span><br><span class="line">        self.f1 = Dense(<span class="number">120</span>,activation=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line">        self.f2 = Dense(<span class="number">84</span>,activation=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line">        self.f3 = Dense(<span class="number">10</span>,activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        x = self.c1(x)</span><br><span class="line">        x = self.p1(x)</span><br><span class="line">        x = self.c2(x)</span><br><span class="line">        x = self.p2(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 提取的特征作为神经网络的输入特征</span></span><br><span class="line">        x = self.flatten(x)</span><br><span class="line">        x = self.f1(x)</span><br><span class="line">        x = self.f2(x)</span><br><span class="line">        y = self.f3(x)</span><br><span class="line">        <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><h4 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h4><p>AlexNet网络诞生于2012年，是Hinton代表作之一。使用relu激活函数，提升训练速度，使用Dropout缓解过拟合。<br><img src="/images/AlexNet.PNG" alt="a2"><br>AlexNet实现代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlexNet</span>(<span class="params">Model</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(AlexNet, self).__init__()</span><br><span class="line">        <span class="comment"># 第一层</span></span><br><span class="line">        self.c1 = Conv2D(filters=<span class="number">96</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line">        self.b1 = BatchNormalization()</span><br><span class="line">        self.a1 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.p1 = MaxPool2D(pool_size=(<span class="number">3</span>,<span class="number">3</span>),strides=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#第二层</span></span><br><span class="line">        self.c2 = Conv2D(filters=<span class="number">256</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line">        self.b2 = BatchNormalization()</span><br><span class="line">        self.a2 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.p2 = MaxPool2D(pool_size=(<span class="number">3</span>,<span class="number">3</span>),strides=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#第三层</span></span><br><span class="line">        self.c3 = Conv2D(filters=<span class="number">384</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>),padding=<span class="string">&#x27;same&#x27;</span>,activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#第四层</span></span><br><span class="line">        self.c4 = Conv2D(filters=<span class="number">384</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>),padding=<span class="string">&#x27;same&#x27;</span>,activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#第五层</span></span><br><span class="line">        self.c5 = Conv2D(filters=<span class="number">256</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>),padding=<span class="string">&#x27;same&#x27;</span>,activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.p3 = MaxPool2D(pool_size=(<span class="number">3</span>,<span class="number">3</span>),strides=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#神经网络计算层</span></span><br><span class="line">        self.flatten = Flatten()</span><br><span class="line">        self.f1 = Dense(<span class="number">2048</span>,activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.d1 = Dropout(<span class="number">0.5</span>)</span><br><span class="line">        self.f2 = Dense(<span class="number">84</span>,activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.d1 = Dropout(<span class="number">0.5</span>)</span><br><span class="line">        self.f3 = Dense(<span class="number">10</span>,activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        x = self.c1(x)</span><br><span class="line">        x = self.b1(x)</span><br><span class="line">        x = self.a1(x)</span><br><span class="line">        x = self.p1(x)</span><br><span class="line"></span><br><span class="line">        x = self.c2(x)</span><br><span class="line">        x = self.b2(x)</span><br><span class="line">        x = self.a2(x)</span><br><span class="line">        x = self.p2(x)</span><br><span class="line"></span><br><span class="line">        x = self.c3(x)</span><br><span class="line"></span><br><span class="line">        x = self.c4(x)</span><br><span class="line"></span><br><span class="line">        x = self.c5(x)</span><br><span class="line">        x = self.p3(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 提取的特征作为神经网络的输入特征</span></span><br><span class="line">        x = self.flatten(x)</span><br><span class="line">        x = self.f1(x)</span><br><span class="line">        x = self.d1(x)</span><br><span class="line">        x = self.f2(x)</span><br><span class="line">        x = self.d2(x)</span><br><span class="line">        y = self.f3(x)</span><br><span class="line">        <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><h4 id="VGGNet"><a href="#VGGNet" class="headerlink" title="VGGNet"></a>VGGNet</h4><p>CGGNet诞生于2014年，当年ImageNet竞赛的亚军。使用小尺寸卷积核，在减少的参数的同时，提高了识别准确率。VGGNet网络结构框图如下所示。<br><img src="/images/VGGnet.PNG" alt="a3"></p><p>VGGNet的网络结构是：两次CBA，CBAPD，三次CBA , CBA,CBAPD。<br>实现代码如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VGGNet</span>(<span class="params">Model</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(VGGNet, self).__init__()</span><br><span class="line">        <span class="comment"># 首先重复两次CBA CBAPD</span></span><br><span class="line">        <span class="comment">#1</span></span><br><span class="line">        self.c1 = Conv2D(filters=<span class="number">64</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>),padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.b1 = BatchNormalization()</span><br><span class="line">        self.a1 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.c2 = Conv2D(filters=<span class="number">64</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.b2 = BatchNormalization()</span><br><span class="line">        self.a2 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.p1 = MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>),strides=<span class="number">2</span>,padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.d1 = Dropout(<span class="number">0.2</span>)</span><br><span class="line">        <span class="comment">#2</span></span><br><span class="line">        self.c3 = Conv2D(filters=<span class="number">128</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.b3 = BatchNormalization()</span><br><span class="line">        self.a3 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.c4 = Conv2D(filters=<span class="number">128</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.b4 = BatchNormalization()</span><br><span class="line">        self.a4 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.p2 = MaxPool2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>), strides=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.d2 = Dropout(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 再重复三次 CBA CBA CBAPD</span></span><br><span class="line">        <span class="comment"># 1</span></span><br><span class="line">        self.c5 = Conv2D(filters=<span class="number">256</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.b5 = BatchNormalization()</span><br><span class="line">        self.a5 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.c6 = Conv2D(filters=<span class="number">256</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.b6 = BatchNormalization()</span><br><span class="line">        self.a6 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.c7 = Conv2D(filters=<span class="number">256</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.b7 = BatchNormalization()</span><br><span class="line">        self.a7 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.p3 = MaxPool2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>), strides=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.d3 = Dropout(<span class="number">0.2</span>)</span><br><span class="line">        <span class="comment"># 2</span></span><br><span class="line">        self.c8 = Conv2D(filters=<span class="number">512</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.b8 = BatchNormalization()</span><br><span class="line">        self.a8 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.c9 = Conv2D(filters=<span class="number">512</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.b9 = BatchNormalization()</span><br><span class="line">        self.a9 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.c10 = Conv2D(filters=<span class="number">512</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.b10 = BatchNormalization()</span><br><span class="line">        self.a10 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.p4 = MaxPool2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>), strides=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.d4 = Dropout(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3</span></span><br><span class="line">        self.c11 = Conv2D(filters=<span class="number">512</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.b11 = BatchNormalization()</span><br><span class="line">        self.a11 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.c12 = Conv2D(filters=<span class="number">512</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.b12 = BatchNormalization()</span><br><span class="line">        self.a12 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.c13 = Conv2D(filters=<span class="number">512</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.b13 = BatchNormalization()</span><br><span class="line">        self.a13 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.p5 = MaxPool2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>), strides=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.d5 = Dropout(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 三个全连接层</span></span><br><span class="line">        self.flatten = Flatten()</span><br><span class="line">        self.f1 = Dense(<span class="number">512</span>,activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.d6 = Dropout(<span class="number">0.2</span>)</span><br><span class="line">        self.f2 = Dense(<span class="number">512</span>,activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.d6 = Dropout(<span class="number">0.2</span>)</span><br><span class="line">        self.f3 = Dense(<span class="number">10</span>,activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        <span class="comment"># 两次CBA CBAPD</span></span><br><span class="line">        <span class="comment">#1</span></span><br><span class="line">        x = self.c1(x)</span><br><span class="line">        x = self.b1(x)</span><br><span class="line">        x = self.a1(x)</span><br><span class="line"></span><br><span class="line">        x = self.c2(x)</span><br><span class="line">        x = self.b2(x)</span><br><span class="line">        x = self.a2(x)</span><br><span class="line">        x = self.p1(x)</span><br><span class="line">        x = self.d1(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#2</span></span><br><span class="line">        x = self.c3(x)</span><br><span class="line">        x = self.b3(x)</span><br><span class="line">        x = self.a3(x)</span><br><span class="line"></span><br><span class="line">        x = self.c4(x)</span><br><span class="line">        x = self.b4(x)</span><br><span class="line">        x = self.a4(x)</span><br><span class="line">        x = self.p2(x)</span><br><span class="line">        x = self.d2(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#三次 CBA CBA CBAPD</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1</span></span><br><span class="line">        x = self.c5(x)</span><br><span class="line">        x = self.b5(x)</span><br><span class="line">        x = self.a5(x)</span><br><span class="line"></span><br><span class="line">        x = self.c6(x)</span><br><span class="line">        x = self.b6(x)</span><br><span class="line">        x = self.a6(x)</span><br><span class="line"></span><br><span class="line">        x = self.c7(x)</span><br><span class="line">        x = self.b7(x)</span><br><span class="line">        x = self.a7(x)</span><br><span class="line">        x = self.p3(x)</span><br><span class="line">        x = self.d3(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2</span></span><br><span class="line">        x = self.c8(x)</span><br><span class="line">        x = self.b8(x)</span><br><span class="line">        x = self.a8(x)</span><br><span class="line"></span><br><span class="line">        x = self.c9(x)</span><br><span class="line">        x = self.b9(x)</span><br><span class="line">        x = self.a9(x)</span><br><span class="line"></span><br><span class="line">        x = self.c10(x)</span><br><span class="line">        x = self.b10(x)</span><br><span class="line">        x = self.a10(x)</span><br><span class="line">        x = self.p4(x)</span><br><span class="line">        x = self.d4(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">        x = self.c11(x)</span><br><span class="line">        x = self.b11(x)</span><br><span class="line">        x = self.a11(x)</span><br><span class="line"></span><br><span class="line">        x = self.c12(x)</span><br><span class="line">        x = self.b12(x)</span><br><span class="line">        x = self.a12(x)</span><br><span class="line"></span><br><span class="line">        x = self.c13(x)</span><br><span class="line">        x = self.b13(x)</span><br><span class="line">        x = self.a13(x)</span><br><span class="line">        x = self.p5(x)</span><br><span class="line">        x = self.d5(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 提取的特征作为神经网络的输入特征</span></span><br><span class="line">        x = self.flatten(x)</span><br><span class="line">        x = self.f1(x)</span><br><span class="line">        x = self.d5(x)</span><br><span class="line">        x = self.f2(x)</span><br><span class="line">        x = self.d6(x)</span><br><span class="line">        y = self.f3(x)</span><br><span class="line">        <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure></p><h4 id="Inception-Net"><a href="#Inception-Net" class="headerlink" title="Inception Net"></a>Inception Net</h4><p>InceptionNet诞生于2014年。当年ImageNet冠军。Inception引入了Inception结构快。<br>同一层网络使用不同尺寸的卷积核，提升了模型感知力，使用了批标准化，缓解了梯度消失。</p><blockquote><p>Inception结构快如图所示</p></blockquote><p><img src="/images/inter.PNG" alt="a14"></p><p>从图中可以看出，Inception包含四个卷积过程，分成四个不同的卷积核进行卷积操作。</p><blockquote><ol><li>1×1的卷积核</li><li>1×1的卷积核+3×3的卷积核</li><li>1×1的卷积核+5×5的卷积核</li><li>3×3的最大池+1×1的卷积核</li><li>最后将四个部分的输出结果，按照深度方向堆叠在一起，作为一个Inception结构快输出。</li></ol></blockquote><h4 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h4><p>ResNet（何凯明）于2015年提出，是当时的ImageNet竞赛冠军。ResNet提出了层间残差跳连，引入了前方信息，缓解梯度消失，使神经网络层数增加称为可能。</p><blockquote><p>单纯堆叠神经网络层数，会使神经网络模型退化，以致于后面的特征丢失了前边特征的原本模样。</p></blockquote><p>ResNet块的结构如下所示：<br><img src="/images/ResNet块.PNG" alt="ar"></p><p>ResNet的输出值包括两部分组成，一部分是由卷积过程提取出的特征输出F(x)，另一部分是直接由输入X得到的恒等映射X组成。将F(x)和x的对应元素相加得到输出特征H(x)。这样可以缓解神经网络堆叠导致的退化。使得神经网络层数增加称为可能。</p><p>对于X到跳过卷积层直接到输出特征有两种处理方式。</p><p><img src="/images/两种ResNet块.PNG" alt="ar1"></p><blockquote><ol><li>不做任何处理<br>H(x) = F(x) + x<br>由于不做任何处理，所以维度没有改变。</li><li>通过函数W(x)进行处理，其中W是1×1的卷积操作，用于调整X的维度。<br>H(x) = F(x) + W(x)<br>其中通过卷积步长可以改变输出特征图尺寸，通过卷积核的个数可以改变特征图的深度（类似Inception结构，多个卷积核，该变深度）。</li></ol></blockquote><p>ResNet网络结构如下所示：</p><p><img src="/images/ResNet.PNG" alt="ar1"></p><p>实现代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResentBlock</span>(<span class="params">Model</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,filters,strides=<span class="number">1</span>,residual_path=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(ResentBlock, self).__init__()</span><br><span class="line">        self.filters = filters</span><br><span class="line">        self.strides = strides</span><br><span class="line">        self.residual_path = residual_path</span><br><span class="line"></span><br><span class="line">        self.c1 = Conv2D(filters,(<span class="number">3</span>,<span class="number">3</span>),strides=strides,padding=<span class="string">&#x27;same&#x27;</span>,use_bias=<span class="literal">False</span>)</span><br><span class="line">        self.b1 = BatchNormalization()</span><br><span class="line">        self.a1 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.c2 = Conv2D(filters,(<span class="number">3</span>,<span class="number">3</span>),strides=<span class="number">1</span>,padding=<span class="string">&#x27;same&#x27;</span>,use_bias=<span class="literal">False</span>)</span><br><span class="line">        self.b2 = BatchNormalization()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#fesiders_path 为True时候，对输入进行采样，都用1×1的卷积核做卷积操作，保证x能和F(x)维度相同，顺利相加</span></span><br><span class="line">        <span class="keyword">if</span> residual_path:</span><br><span class="line">            self.down_c1 = Conv2D(filters,(<span class="number">1</span>,<span class="number">1</span>),strides=strides,padding=<span class="string">&#x27;same&#x27;</span>,use_bias=<span class="literal">False</span>)</span><br><span class="line">            self.down_b1 = BatchNormalization()</span><br><span class="line">        self.a2 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self,inputs</span>):</span></span><br><span class="line">        residual = inputs <span class="comment"># residual等于输入本身</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#将输入通过卷积层，BN层，激活层计算F(x)</span></span><br><span class="line">        x = self.c1(inputs)</span><br><span class="line">        x = self.b1(x)</span><br><span class="line">        x = self.a1(x)</span><br><span class="line"></span><br><span class="line">        x = self.c2(x)</span><br><span class="line">        y = self.b2(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.residual_path:</span><br><span class="line">            residual = self.down_c1(inputs)</span><br><span class="line">            residual = self.down_b1(residual)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 最后输出是两部分的和，即F(x)+x或F(x)+W(x),然后再过激活函数。</span></span><br><span class="line">        out = self.a2(y + residual)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由一层卷积网络+八个ResNet块组成</span></span><br><span class="line"><span class="comment"># 神经网络由一个全连接层构成</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResNet</span>(<span class="params">Model</span>):</span></span><br><span class="line">    <span class="comment"># block_list表示每个block有几个卷积层</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,block_list,initial_filters=<span class="number">64</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(ResNet, self).__init__()</span><br><span class="line">        self.num_blocks = <span class="built_in">len</span>(block_list)</span><br><span class="line">        self.block_list = block_list</span><br><span class="line">        self.out_filters = initial_filters</span><br><span class="line">        <span class="comment"># 对应图中第一个卷几层</span></span><br><span class="line">        self.c1 = Conv2D(self.out_filters,(<span class="number">3</span>,<span class="number">3</span>),strides=<span class="number">1</span>,padding=<span class="string">&#x27;same&#x27;</span>,use_bias=<span class="literal">False</span>,kernel_initializer=<span class="string">&#x27;he_normal&#x27;</span>)</span><br><span class="line">        self.b1 = BatchNormalization()</span><br><span class="line">        self.a1 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.blocks = tf.keras.models.Sequential()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对应图中的八个ResNet块</span></span><br><span class="line">        <span class="comment">#构建ResNet网络结构 4*2 = 8</span></span><br><span class="line">        <span class="keyword">for</span> block_id <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(block_list)):<span class="comment">#第几个resnet block</span></span><br><span class="line">            <span class="keyword">for</span> layer_id <span class="keyword">in</span> <span class="built_in">range</span>(block_list[block_id]):<span class="comment"># 第几个卷层</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> block_id != <span class="number">0</span> <span class="keyword">and</span> layer_id == <span class="number">0</span> : <span class="comment">#对除第一个block以外的每个Block的输入进行采样</span></span><br><span class="line">                    block = ResentBlock(self.out_filters,strides=<span class="number">2</span>,residual_path=<span class="literal">True</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    block = ResentBlock(self.out_filters,residual_path=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">                self.blocks.add(block)  <span class="comment"># 将构建好的blcok加入到renset</span></span><br><span class="line">            self.out_filters *=<span class="number">2</span>  <span class="comment">#下一个block卷积核数是上一个block的两倍</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 平均池</span></span><br><span class="line">        self.p1 = tf.keras.layers.GlobalAveragePooling2D()</span><br><span class="line">        <span class="comment"># 全连接层</span></span><br><span class="line">        self.f1 = tf.keras.layers.Dense(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self,inputs</span>):</span></span><br><span class="line">        x = self.c1(inputs)</span><br><span class="line">        x = self.b1(x)</span><br><span class="line">        x = self.a1(x)</span><br><span class="line">        x = self.blocks(x)</span><br><span class="line">        x = self.p1(x)</span><br><span class="line">        y = self.f1(x)</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">model = ResNet([<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>])</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>LeNet<br>通过共享卷积核，减少网络参数</li><li>AlexNet<br> 通过使用relu激活函数，提升训练速度。<br> 使用Dropout缓解过拟合。</li><li>VGGNet<br> 小尺寸卷积核减少参数，网络结构规整，适合并行加速。</li><li>InceptionNet<br> 一层内使用不同尺寸卷积核，提升感知力。使用批标准化，缓解梯度消失。</li><li>ResNet<br> 层间残差跳连，引入前方信息，缓解模型退化，使神经网络层数加深成为可能。</li></ol><blockquote><p>训练优化</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;一些训练方法和超参数的设定对模型训练结果的影响是相当显著的，如数据增强（对训练集图像进行旋转、偏移、翻转等多种操作，目的是增强训练集的随机性）、学习率策略（一般的策略是在训练过程中逐步减小学习率）、Batch size 的大小设置（每个 batch 包含训练集图片的数量）、模型参数初始化的方式等等。。所以，在神经网络的训练中，除了选择合适的模型以外，如何更好地训练一个模型也是一个非常值得探究的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;这里主要介绍卷积神经网络的经典网络，然后通过tensorflow进行实现（以上章的卷积神经网络实现代码为基础，进行实现）。&lt;/p&gt;
&lt;p&gt;统
      
    
    </summary>
    
      <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="TensorFlow2" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/TensorFlow2/"/>
    
    
      <category term="TensorFlow2" scheme="http://example.com/tags/TensorFlow2/"/>
    
      <category term="CNN" scheme="http://example.com/tags/CNN/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow2笔记-NN(全连接)</title>
    <link href="http://example.com/wiki/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Tensorflow%E7%AC%94%E8%AE%B0/NN/"/>
    <id>http://example.com/wiki/机器学习/Tensorflow笔记/NN/</id>
    <published>2021-10-29T06:05:38.694Z</published>
    <updated>2021-10-29T06:12:34.236Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>全连接NN：每个神经元与前后相邻层的每一个神经元都有连接关系，输入是特征，输出为预测的结果。<br>（可以类比于满射，前后层神经元之间都有联系）</p><blockquote><p>参数个数</p></blockquote><p>参数个数=$\displaystyle \sum^{}_{各层}{前层*后层(w)+后层(b)}$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;全连接NN：每个神经元与前后相邻层的每一个神经元都有连接关系，输入是特征，输出为预测的结果。&lt;br&gt;（可以类比于满射，前后层神经元之间都有联
      
    
    </summary>
    
      <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="TensorFlow2" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/TensorFlow2/"/>
    
    
      <category term="TensorFlow2" scheme="http://example.com/tags/TensorFlow2/"/>
    
      <category term="CNN" scheme="http://example.com/tags/CNN/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow2笔记-第四讲(网络八股扩展)</title>
    <link href="http://example.com/wiki/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Tensorflow%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1%E6%89%A9%E5%B1%95/"/>
    <id>http://example.com/wiki/机器学习/Tensorflow笔记/第四讲-网络八股扩展/</id>
    <published>2021-10-29T06:00:43.670Z</published>
    <updated>2021-10-29T06:01:12.943Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="TensorFlow2" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/TensorFlow2/"/>
    
    
      <category term="TensorFlow2" scheme="http://example.com/tags/TensorFlow2/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow2笔记-CNN(卷积神经网络)</title>
    <link href="http://example.com/wiki/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Tensorflow%E7%AC%94%E8%AE%B0/CNN/"/>
    <id>http://example.com/wiki/机器学习/Tensorflow笔记/CNN/</id>
    <published>2021-10-29T04:44:21.509Z</published>
    <updated>2021-11-01T08:56:31.980Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/多通道计算.PNG" alt="aaa"></p><h3 id="问题介绍"><a href="#问题介绍" class="headerlink" title="问题介绍"></a>问题介绍</h3><p>如果仅仅依靠全连接神经网络来训练模型，则在实际应用中，输入特征会非常多，参数十分复杂，让训练变得非常庞大。所以在实际应用时，会对原始图像进行特征提取再把提取到的特征送给全连接网络。流程如下所示：</p><pre class="mermaid">    graph LR        原始图片 --> 若干层特征提取        若干层特征提取 --> 全连接网络</pre><p>卷积计算是一种提取图片特征的有效方法。</p><h3 id="卷积计算过程"><a href="#卷积计算过程" class="headerlink" title="卷积计算过程"></a>卷积计算过程</h3><blockquote><blockquote><p>单通道卷积计算<br><img src="/images/卷积计算过程.PNG" alt="aaa"></p></blockquote><p>从上图可以看出,卷积神经网络计算的过程实际上就是将大的数据，根据区域提取其相关特征，减少了特征数目。从 5x5x1 的参数，经过 3x3x1的卷积核卷积计算后，转化为3x3x1的参数网络。<br>&gt;</p><blockquote><p>多通道卷积计算<br><img src="/images/多通道计算.PNG" alt="bb"><br>从图中可以看出，对于输入特征是多通道的，每个通道都通过卷积层计算相应的调整值。从图片看从5×5×3经过3×3×3的卷积核计算，对每个通道的重合区域，经过对应通道 的卷积核计算的结果作为输出调整图中的一个像素点。</p></blockquote><p>总结<br>对于卷积神经网络的计算过程，就是从左到右，从上到下，根据卷积核重叠的区域，依次计算结果，作为输出特征图的一个像素点。</p></blockquote><h3 id="用CNN实现离散数据的分类-以图像分类为例"><a href="#用CNN实现离散数据的分类-以图像分类为例" class="headerlink" title="用CNN实现离散数据的分类(以图像分类为例)"></a>用CNN实现离散数据的分类(以图像分类为例)</h3><h4 id="1-感受野-Receptive-Field"><a href="#1-感受野-Receptive-Field" class="headerlink" title="1. 感受野(Receptive Field)"></a>1. 感受野(Receptive Field)</h4><p>感受野：卷积神经网络各输出特征图中的每个像素点，在原始输入图片上映射区域的大小。</p><p>这里可以参考一下卷积神经网络的计算过程中，5×5×1 经过 3×3×1 卷积后得到一张3×3的特征图，那么最终3×3特征图中的一个像素点所对应在5×5×1输入特征图的区域大小，（大小只取正方形区域边的大小），称之为感受野，从图上可以看出对应的感受野为3。</p><blockquote><p>如果输出特征图的感受野都是一样的,但是选取的卷积核不一样（如刚刚的5×5×1的输入特征可以经过两层3×3×1的卷积核得到1的输出特征图，同样可以经过一层5×5×1的卷积核得到1的输出特征图，二者的感受野都是5）。</p></blockquote><p>这里就需要考虑选取不同的卷积核所带来的计算代价，计算越少越好。<br><img src="/images/选取卷积核.PNG" alt="ccc"></p><blockquote><p>对计算量的计算步骤，以两层3×3×1为例，对于输入特征图经过第一层卷积核的计算量-&gt;首先每次计算共有9次乘法运算，卷积核总共扫描的区域数很容易得出为(x-3+1)(x-3+1),总的计算数为9×(x-2)×(x-2)。同理经过第一层卷积核的输出特征图经过第二个卷积核的计算量为9×(x-2-3+1)×(x-2-3+1)。将两个卷积核计算量相加得到总的计算量：18$x^2$-108x+180</p></blockquote><h4 id="2-全零填充-Padding"><a href="#2-全零填充-Padding" class="headerlink" title="2. 全零填充(Padding)"></a>2. 全零填充(Padding)</h4><p>为了保证输入特征图的尺寸不变，通过0进行填充，在输入特征图周围填充0，如原来的5×5×1经过3×3×1后仍然还是5×5×1。</p><blockquote><p>填充公式(卷积输出特征图维度计算公式)</p></blockquote><script type="math/tex; mode=display">padding=\left\{     \begin{aligned}SAME(全0填充)\frac{入长}{步长} & ,(向上取整)    \\    VALID(不全0填充) \frac{入长-核长+1}{步长}&,(向上取整)    \end{aligned}    \right.</script><p>TF描述全0填充，用参数padding=’SAME’或padding=’VALID’表示。<br><img src="/images/零填充.PNG" alt="ccc"></p><h4 id="3-Tensorflow2描述卷积层"><a href="#3-Tensorflow2描述卷积层" class="headerlink" title="3. Tensorflow2描述卷积层"></a>3. Tensorflow2描述卷积层</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### TF描述卷积层的代码</span></span><br><span class="line"><span class="comment"># tf.keras.layers.Conv2D(</span></span><br><span class="line"><span class="comment">#     filters=卷积核个数,</span></span><br><span class="line"><span class="comment">#     kernel_size=卷积核尺寸,#正方形写核长整数,或（核高h,核宽w）</span></span><br><span class="line"><span class="comment">#     strides = 滑动步长,#横纵向相同写步长整数，或（纵向步长h，横向步长w）,默认1</span></span><br><span class="line"><span class="comment">#     padding = &quot;same&quot; or &quot;valid&quot;,#使用全0填充是same，不使用是valid(默认)</span></span><br><span class="line"><span class="comment">#     activation=&quot;relu&quot;or&quot;sigmoid&quot;or&quot;tanh&quot;or&quot;softmax&quot;等,#如有BN此处不写</span></span><br><span class="line"><span class="comment">#     input_shape=(高，宽，通道数) #输入特征图维度，可省略</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line">model = tf.keras.models.Sequential([</span><br><span class="line">    Conv2D(<span class="number">6</span>,<span class="number">5</span>,padding=<span class="string">&#x27;valid&#x27;</span>,activation=<span class="string">&#x27;sigmoid&#x27;</span>),</span><br><span class="line">    MaxPool2D(<span class="number">2</span>,<span class="number">2</span>),</span><br><span class="line">    Conv2D(<span class="number">6</span>,(<span class="number">5</span>,<span class="number">5</span>),padding=<span class="string">&#x27;valid&#x27;</span>,activation=<span class="string">&#x27;sigmoid&#x27;</span>),</span><br><span class="line">    MaxPool2D(<span class="number">2</span>,(<span class="number">2</span>,<span class="number">2</span>)),</span><br><span class="line">    Conv2D(filters=<span class="number">6</span>,kernel_size=(<span class="number">5</span>,<span class="number">5</span>),padding=<span class="string">&#x27;valid&#x27;</span>,activation=<span class="string">&#x27;sigmoid&#x27;</span>),</span><br><span class="line">    MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>),strides=<span class="number">2</span>),</span><br><span class="line">    Flatten(),</span><br><span class="line">    Dense(<span class="number">10</span>,activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h4 id="4-批标准化-Batch-Normalization-BN"><a href="#4-批标准化-Batch-Normalization-BN" class="headerlink" title="4. 批标准化(Batch Normalization , BN)"></a>4. 批标准化(Batch Normalization , BN)</h4><p>神经网络对0附件的数据更敏感。</p><p>标准化：使数据符合0均值，1为标准差的分布<br>批标准化：对一小批数据（batch），做标准化处理。<br>批标准化，第K个卷积核的输出特征图(feature map)中第i个像素点。</p><p><img src="/images/拟标准化.PNG" alt="a4"></p><blockquote><p>$H_{i}^{‘k}$ = $\frac{H_{i}^{k}-u_{batch}^{k}} {\sigma_{batch}^{k}}$<br>$H_{i}^{k}$：批标准化前，第K个卷积核，输出特征图中第i个像素点。<br>$u_{batch}^{k}$：批量化前，第k个卷积核，batch张输出特征图中所有像素点平均值。</p></blockquote><p>$u_{batch}^{k}$ = $\frac{1} {m} \displaystyle \sum^{m}_{i=1} H_{i}^{k}$</p><blockquote><p>$\sigma_{batch}^{k}$：批标准化前，第k个卷积核，batch张输出特征图中所有像素点标准差。</p></blockquote><p>$\sigma_{batch}^{k}$ = $\sqrt{\delta+\frac{1}{m}\displaystyle \sum^m_{i = 1}(H_i^k-u_{batch}^k)^2}$</p><p>通过BN操作，将数据标准化到0均值。如下图所示：<br><img src="/images/拟标准-1.PNG" alt="a41"></p><p>通过标准化使得输入特征的微小变化也能使得激活函数有明显的变化，提升激活函数对输入数据的区分力。</p><p>从图中可以看出，经过标准化的Sigmoid函数，特征数据$H_i^{‘k}$集中在0附近，但是从图中可以看出，Sigmoid函数在0区域附近的曲线接近线性函数，所以这样会导致激活函数的非线性特性丧失。为了解决这个问题，需要为每个卷积核引入可训练参数$\gamma$（缩放因子）和$\beta$（偏移因子）,用于调整归一化的力度,优化特征数据分布的宽窄和偏移量，保证了网络的非线性表达力。<br>调整后的数据$x_i^k$ = $\gamma_{k}H_{i}^{‘k}+\beta_k$。</p><p>从上面可以看出，BN层用于对数据的标准化处理，可以缓解梯度消失，所以BN层位于卷积层之后，激活层之前。</p><blockquote><p>TensorFlow描述批标准化的代码如下</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    TF通过tf.keras.layers.BatchhNormalization()描述BN层</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">model = tf.keras.models.Sequential([</span><br><span class="line">   Conv2D(padding=<span class="string">&#x27;same&#x27;</span>,kernel_size=(<span class="number">5</span>,<span class="number">5</span>),filters=<span class="number">6</span>),</span><br><span class="line">    BatchNormalization(),<span class="comment">#BN层</span></span><br><span class="line">    Activation(<span class="string">&#x27;relu&#x27;</span>),<span class="comment">#激活层</span></span><br><span class="line">    MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>),strides=<span class="number">2</span>,padding=<span class="string">&#x27;same&#x27;</span>),</span><br><span class="line">    Dropout(<span class="number">0.2</span>),<span class="comment">#droupt层</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure><h3 id="5-池化-Pooling"><a href="#5-池化-Pooling" class="headerlink" title="5. 池化(Pooling)"></a>5. 池化(Pooling)</h3><p>池化用于减少特征数据量。池化包含最大值池化和均值池化。最大值池化可以提取图片纹理，均值池化可以保留背景特征。</p><p>两种池化的计算如下图所示。<br><img src="/images/Pooling.PNG" alt="a6"><br>用池大小为2×2，步长为2的池进行处理。<br>从图中可以看出二者的计算过程。</p><blockquote><p>最大值池化</p></blockquote><p>选择被池包含区域内最大的特征值作为输出结果。</p><blockquote><p>均值池化</p></blockquote><p>选择被池包含区域内特征值的平均值作为输出结果。</p><blockquote><p>TensorFlow描述池化的代码如下</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        tf.keras.MaxPool2D(</span></span><br><span class="line"><span class="string">            pool_size=池化核尺寸,#正方形写核长整数，或用元组给出核的高和宽(核高h,核宽w)</span></span><br><span class="line"><span class="string">            strides=池化步长,#步长整数，或(纵向步长h，横向步长w),默认为pool_size</span></span><br><span class="line"><span class="string">            padding=&#x27;valid&#x27;or&#x27;same&#x27;#q全0填充是same,否则是&#x27;valid</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">        tf.keras.AveragePooling2D(</span></span><br><span class="line"><span class="string">        pool_size=池化核尺寸,#正方形写核长整数，或用元组给出核的高和宽(核高h,核宽w)</span></span><br><span class="line"><span class="string">            strides=池化步长,#步长整数，或(纵向步长h，横向步长w),默认为pool_size</span></span><br><span class="line"><span class="string">            padding=&#x27;valid&#x27;or&#x27;same&#x27;#q全0填充是same,否则是&#x27;valid</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    model = tf.keras.models.Sequential([</span><br><span class="line">        Conv2D(padding=<span class="string">&#x27;same&#x27;</span>,kernel_size=(<span class="number">5</span>,<span class="number">5</span>),filters=<span class="number">6</span>),<span class="comment">#卷积层</span></span><br><span class="line">        BatchNormalization(),<span class="comment">#BN层</span></span><br><span class="line">        Activation(<span class="string">&#x27;relu&#x27;</span>),<span class="comment">#激活层</span></span><br><span class="line">        MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>),strides=<span class="number">2</span>,padding=<span class="string">&#x27;same&#x27;</span>),<span class="comment">#池化层</span></span><br><span class="line">        Dropout(<span class="number">0.2</span>),<span class="comment">#droupt层</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure><h3 id="6-舍弃（Dropout）"><a href="#6-舍弃（Dropout）" class="headerlink" title="6. 舍弃（Dropout）"></a>6. 舍弃（Dropout）</h3><p>舍弃是为了缓解神经网络过拟合。舍弃也就是在神经网络训练的过程中，将一部分神经元按照一定概率从神经网络中暂时舍弃。神经网络使用时，被舍弃的神经元恢复链接。（也就是说在神经网络训练的过程中，一些神经元会被暂时踢出训练，等最后在加入到神经网络中。）。舍弃过程如图所示：<br><img src="/images/Dropout.PNG" alt="a7"></p><p>在训练的过程中，将一部分神经元暂时舍弃(类似于神经元死亡，也就是神经元的参数不再更新)。</p><blockquote><p>TensorFlow描述舍弃（Dropout）</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    tf描述舍弃：tf.keras.layers.Dropout(舍弃的概率)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">    model = tf.keras.models.Sequential([</span><br><span class="line">        Conv2D(padding=<span class="string">&#x27;same&#x27;</span>,kernel_size=(<span class="number">5</span>,<span class="number">5</span>),filters=<span class="number">6</span>),<span class="comment">#卷积层</span></span><br><span class="line">        BatchNormalization(),<span class="comment">#BN层</span></span><br><span class="line">        Activation(<span class="string">&#x27;relu&#x27;</span>),<span class="comment">#激活层</span></span><br><span class="line">        MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>),strides=<span class="number">2</span>,padding=<span class="string">&#x27;same&#x27;</span>),<span class="comment">#池化层</span></span><br><span class="line">        Dropout(<span class="number">0.2</span>),<span class="comment">#droupt层，随机舍弃掉20%的神经元</span></span><br><span class="line">    ])</span><br></pre></td></tr></table></figure><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><p>从上面介绍可以看出，卷积的过程就是对特征值的特征进行提取，来减少特征值的数量（卷积，池化）。通过用一个输出像素点来反映一块区域内像素点的特征。通过这样的方式有效的减少了特征值的数量。</p><blockquote><p>卷积神经网络的主要组成模块,卷积层，BN层，激活层，池化层,舍弃层(dropout层)，全连接层（Fully Connected）。<br>卷积层，BN层，激活层，池化层这四层用于对输入特征进行特征提取。</p></blockquote><pre class="mermaid">    graph LR        A("卷积&#40;Convolutional&#41;") --> B("批标准化&#40;BN&#41;")         B --> C("激活&#40;Activation&#41;")         C --> D("池化&#40;Pooling&#41;")         D --> F("舍弃层&#40;Dropout&#41;")        F --> E("全连接&#40;FC&#41;")</pre><blockquote><p>卷积是什么？</p></blockquote><p>卷积就是<font color=red>特征提取器</font>,就是CBAPD(D表示的是舍弃，Dropout)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/多通道计算.PNG&quot; alt=&quot;aaa&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;问题介绍&quot;&gt;&lt;a href=&quot;#问题介绍&quot; class=&quot;headerlink&quot; title=&quot;问题介绍&quot;&gt;&lt;/a&gt;问题介绍&lt;/h3&gt;&lt;p&gt;如果仅仅依靠全连接神经网络来训
      
    
    </summary>
    
      <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="TensorFlow2" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/TensorFlow2/"/>
    
    
      <category term="TensorFlow2" scheme="http://example.com/tags/TensorFlow2/"/>
    
      <category term="CNN" scheme="http://example.com/tags/CNN/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法</title>
    <link href="http://example.com/wiki/%E7%AE%97%E6%B3%95/Leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/KMP/"/>
    <id>http://example.com/wiki/算法/Leetcode/字符串/KMP/</id>
    <published>2021-10-28T09:15:08.580Z</published>
    <updated>2021-11-15T00:55:53.024Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#1-问题描述">1. 问题描述</a></li><li><a href="#2-解题思路">2. 解题思路</a></li></ul><h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h3><p>今天的问题很简单，就是给定两个字符串text和pattern，让你找出在text中是否存在一个序列等于pattern,如果存在就返回true,如果不存在就返回false 。</p><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h3><p>从题目描述上来看，很容易看出这题目是关于字符串匹配的问题，也就是从一段文本中，找出某个模式的全部出现位置的问题。</p><blockquote><ol><li>朴素的字符串匹配算法</li></ol></blockquote><p>用一个循环找出所有有效位移，对text每个字符进行检测，然后匹配pattern，如果匹配成功就返回下标。如果失败，就移动text下一个位置，重复操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len_h , len_s , i , j = <span class="number">0</span> ;</span><br><span class="line">        len_s = needle.length() ;</span><br><span class="line">        <span class="keyword">if</span>(len_s == <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        len_h = haystack.length() ;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt;= len_h - len_s ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(haystack.charAt(i)==needle.charAt(j))&#123;</span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;len_s;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(haystack.charAt(i+j)!=needle.charAt(j))</span><br><span class="line">                        <span class="keyword">break</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=len_s)</span><br><span class="line">                    <span class="keyword">return</span> i ;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    j = <span class="number">0</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><blockquote><ol><li>KMP算法</li></ol></blockquote><p>KMP算法的巧妙之处就是利用已经匹配字符串来确定下一次匹配开始的位置。这就是和朴素字符串匹配算法的区别，朴素字符串匹配算法每次匹配完毕之后，只是从下一个字符开始进行匹配，那么就浪费了已经匹配过字符串的有效信息，所以造成时间上的浪费。如何确定下一字符开始匹配的位置呢？假设已经匹配模式串pattern的位置为j,也就是从text的位置i开始 text[i…..,i+j] = pattern[0……,0+j]</p><blockquote><p>KMP算法的前缀函数(next)</p></blockquote><p>前缀函数 $\pi$(i)(0 $\leq$ i &lt; m)表示s 的子串 s[0:i] 的最长的相等的真前缀与真后缀的长度。特别地，如果不存在符合条件的前后缀，那么 $\pi$(i) = 0。其中真前缀与真后缀的定义为不等于自身的的前缀与后缀。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求解字符前缀函数</span></span><br><span class="line"><span class="comment"> * /</span></span><br><span class="line"><span class="comment"> public int[] getNext(String s)&#123;</span></span><br><span class="line"><span class="comment">        int len , k ,q ;</span></span><br><span class="line"><span class="comment">        len = s.length() ;</span></span><br><span class="line"><span class="comment">        int[] next = new int[len];</span></span><br><span class="line"><span class="comment">        next[0] = 0 ;</span></span><br><span class="line"><span class="comment">        for(q = 1,k=0 ; q&lt; len ; q++)&#123;  //长字符串的前缀建立在短字符前缀的匹配上。</span></span><br><span class="line"><span class="comment">            while (k&gt;0&amp;&amp;s.charAt(k)!=s.charAt(q))&#123;</span></span><br><span class="line"><span class="comment">                    k = next[k-1] ;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if(s.charAt(q) == s.charAt(k))&#123;</span></span><br><span class="line"><span class="comment">                k = k+1 ;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            next[q] = k ;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return next ;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过前缀函数进行字符串的匹配</span></span><br><span class="line"><span class="comment"> * /</span></span><br><span class="line"><span class="comment">    public int Matcher(String t , String p )&#123;</span></span><br><span class="line"><span class="comment">        int   q , i;</span></span><br><span class="line"><span class="comment">        int n = t.length(), m = p.length();</span></span><br><span class="line"><span class="comment">        if (m == 0) &#123;</span></span><br><span class="line"><span class="comment">            return 0;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        int[] next = getNext(p) ;</span></span><br><span class="line"><span class="comment">        q = 0 ;</span></span><br><span class="line"><span class="comment">        for(i = 0 ,q=0; i &lt; n ;i++)&#123;</span></span><br><span class="line"><span class="comment">            while(q&gt;0&amp;&amp;p.charAt(q)!=t.charAt(i))&#123;  //如果不匹配则移动到下一个位置</span></span><br><span class="line"><span class="comment">                q = next[q-1] ;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if(p.charAt(q) == t.charAt(i))&#123;</span></span><br><span class="line"><span class="comment">                q = q+1 ;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if(q == m)&#123;</span></span><br><span class="line"><span class="comment">                return i-m+1 ;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return -1 ;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure><blockquote><p>个人总结</p></blockquote><p>KMP算法主要在于计算前缀函数next，前缀函数的计算依据最长相同前后缀长度为依据来计算。通过next来获取到移动的位置。</p><p>对于next前缀函数的计算过程，patten(q) 和 patten(k) 不等说明了，在前一个（q-1）的最长前后缀匹配的位置，增加一个text(q)后，patten[0-&gt;next(q-1),next(q-1)+1] 和patten[(q-1)-next(q-1)-&gt;q]并不相等(因为新增的最后一个字符和前一个patten(q-1)字符串的最长前后缀并不相等)，所以需要进一步比较next[next(q-1)] 是否满足，patten[0-&gt;k+1] == patten[k-q,q] , 如果相等，则另k+1 , next[q] = k 。<br><img src="/images/时间复杂度.PNG" alt="a6"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-问题描述&quot;&gt;1. 问题描述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-解题思路&quot;&gt;2. 解题思路&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-问题描述&quot;&gt;&lt;a href=&quot;#1-问题描述&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="经典算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>48.旋转数组</title>
    <link href="http://example.com/wiki/%E7%AE%97%E6%B3%95/Leetcode/%E9%93%BE%E8%A1%A8/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>http://example.com/wiki/算法/Leetcode/链表/19.删除链表的倒数第N个结点/</id>
    <published>2021-10-28T08:36:32.058Z</published>
    <updated>2021-10-28T08:48:47.469Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。(进阶：你能尝试使用一趟扫描实现吗？)</p><blockquote><p>示例 1：</p></blockquote><pre><code>输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5]</code></pre><blockquote><p>示例 2：</p></blockquote><pre><code>输入：head = [1], n = 1输出：[]</code></pre><blockquote><p>示例 3：</p></blockquote><pre><code>输入：head = [1,2], n = 1输出：[1]</code></pre><h3 id="解法思路"><a href="#解法思路" class="headerlink" title="解法思路"></a>解法思路</h3><p>从题目分析，我们需要删除链表的倒数第N个结点，那么我们就必须知道哪个结点是倒数第N个结点。确定一个结点在列表中的位置大概有如下几种方法。</p><blockquote><p>方法一</p></blockquote><p>先确定整个列表的长度，然后就能够确定结点所在的位置(可以通过堆栈或者数组存放数据元素，通过数组有利于操作)。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;ListNode&gt; listNodes = <span class="keyword">new</span> ArrayList&lt;&gt;()  ;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span> ;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            len++ ;</span><br><span class="line">            listNodes.add(head) ;</span><br><span class="line">            head = head.next ;</span><br><span class="line">        &#125;</span><br><span class="line">        listNodes.add(head) ; </span><br><span class="line">        <span class="keyword">if</span>(len-n-<span class="number">1</span>&lt;<span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> listNodes.get(<span class="number">1</span>) ;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            listNodes.get(len-n-<span class="number">1</span>).next = listNodes.get(len-n).next ;</span><br><span class="line">            <span class="keyword">return</span> listNodes.get(<span class="number">0</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>方法二</p></blockquote><p>通过快慢指针法，让一个指针永远比当前指针快n个元素，那么当快指针到达末尾的时候，就能够确定倒数第N个元素。示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode p , q , pre ;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        p = head ; <span class="comment">// 快指针</span></span><br><span class="line">        q = head ;<span class="comment">// 慢指针</span></span><br><span class="line">        pre = q ; <span class="comment">//用于记录q的前一个元素，有利于元素的删除</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; n ; i++) <span class="comment">//让p比q快n个元素</span></span><br><span class="line">            p = p.next ;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            p = p.next ;</span><br><span class="line">            pre = q ;</span><br><span class="line">            q = q.next ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre == q)&#123;       <span class="comment">// 判断删除元素是否为头</span></span><br><span class="line">            <span class="keyword">return</span> q.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre.next = q.next ;</span><br><span class="line">            <span class="keyword">return</span> head ; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目介绍&quot;&gt;&lt;a href=&quot;#题目介绍&quot; class=&quot;headerlink&quot; title=&quot;题目介绍&quot;&gt;&lt;/a&gt;题目介绍&lt;/h3&gt;&lt;p&gt;给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。(进阶：你能尝试使用一趟扫描实现吗？)&lt;/p&gt;
&lt;bloc
      
    
    </summary>
    
      <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/Leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>3. Java控制流程</title>
    <link href="http://example.com/wiki/JavaSE/%E7%AC%AC%E4%B8%89%E7%AB%A0-Java%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/java%20controll%20followe/"/>
    <id>http://example.com/wiki/JavaSE/第三章-Java基本程序结构/java controll followe/</id>
    <published>2021-10-27T03:07:05.097Z</published>
    <updated>2021-10-27T06:48:04.804Z</updated>
    
    <content type="html"><![CDATA[<p>程序的控制流程一般包含，选择结构，循环结构，顺序结构。</p><blockquote><p>顺序结构</p><blockquote><p>顺序结构很简单，程序都具有顺序结构，依次按顺序执行。<br>Java的语法，不允许在嵌套的两个块(块一般是指，通过{}包含的代码区域，称为块)中，声明同名变量。示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">int</span> n; <span class="comment">// Error can&#x27;t redefine n in inner block</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>选择结构<br>选择结构也就是 if-else结构，通过条件语句来选择需要执行的语句。else与最近的if构成匹配。示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ifElseTemplemate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span> ,b = <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; b)</span><br><span class="line">            System.out.println(<span class="string">&quot;a大于b&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span>(a == b)</span><br><span class="line">                System.out.println(<span class="string">&quot;a 等于 b&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.println(<span class="string">&quot;a 小于 b&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果有多个选择情况，可以通过Switch-case语句进行实现。代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ifElseTemplemate</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> a = <span class="number">1</span> ,b = <span class="number">2</span> ;</span><br><span class="line">       <span class="keyword">if</span>(a &gt; b)</span><br><span class="line">           System.out.println(<span class="string">&quot;a大于b&quot;</span>);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">if</span>(a == b)</span><br><span class="line">               System.out.println(<span class="string">&quot;a 等于 b&quot;</span>);</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               System.out.println(<span class="string">&quot;a 小于 b&quot;</span>);</span><br><span class="line">       <span class="keyword">switch</span> (a)&#123;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">               System.out.println(a);<span class="keyword">break</span> ;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">               System.out.println(a);</span><br><span class="line">               <span class="keyword">break</span> ;</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               System.out.println(a);<span class="keyword">break</span> ;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br>switch语句将从与选项值相匹配的case标签处开始执行直到遇到 break 语句，或者执行到switch i吾句的结束处为止。如果没有相匹配的case标签,而有default子句,就执行这个子句。<br>case 标签可以是：</p></blockquote></blockquote><pre><code>•类型为 char、byte、 short 或 int 的常量表达式。•枚举常量。•从 Java SE 7开始， case 标签还可以是字符串字面量。</code></pre><blockquote><p>循环结构<br>循环执行某个代码块。一般包含for循环和while循环，do-while循环。示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forWhileStatement</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">// 计算1-100的和</span></span><br><span class="line">     <span class="keyword">int</span> sum = <span class="number">0</span> , i = <span class="number">0</span> ;</span><br><span class="line">     <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt;= <span class="number">100</span> ; i++)&#123;</span><br><span class="line">         sum +=i;</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(sum);</span><br><span class="line">     i = <span class="number">0</span> ;</span><br><span class="line">     sum = <span class="number">0</span> ;</span><br><span class="line">     <span class="keyword">while</span>(i&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">         sum+=i;</span><br><span class="line">         i++;</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(sum);</span><br><span class="line">     i = <span class="number">0</span> ;</span><br><span class="line">     sum = <span class="number">0</span> ;</span><br><span class="line">     <span class="keyword">do</span>&#123;</span><br><span class="line">         sum+=i;</span><br><span class="line">         i++;</span><br><span class="line">     &#125;<span class="keyword">while</span>(i&lt;=<span class="number">100</span>) ;</span><br><span class="line">     System.out.println(sum);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>还有一种循环方式为for-each循环，参考数组的循环。</p></blockquote><p>如果想跳出循环可以使用break;，如果想要跳出某个执行过程可以用continue。Java也支持类似于goto的语法，通过break 标签来结束循环。示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forWhileStatement</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>   i = <span class="number">0</span>, j  ;</span><br><span class="line">        lables:</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;in&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span> lables;<span class="comment">//跳出指定的循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;程序的控制流程一般包含，选择结构，循环结构，顺序结构。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;顺序结构&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;顺序结构很简单，程序都具有顺序结构，依次按顺序执行。&lt;br&gt;Java的语法，不允许在嵌套的两个块(块一般是指，通过{}包含的代码
      
    
    </summary>
    
      <category term="JavaSE" scheme="http://example.com/categories/JavaSE/"/>
    
    
      <category term="JAVA" scheme="http://example.com/tags/JAVA/"/>
    
      <category term="JAVASE" scheme="http://example.com/tags/JAVASE/"/>
    
  </entry>
  
  <entry>
    <title>2. Java基本语法</title>
    <link href="http://example.com/wiki/JavaSE/%E7%AC%AC%E4%B8%89%E7%AB%A0-Java%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/java%20basic%20statment/"/>
    <id>http://example.com/wiki/JavaSE/第三章-Java基本程序结构/java basic statment/</id>
    <published>2021-10-26T09:21:11.459Z</published>
    <updated>2021-10-27T07:14:45.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Java注释"><a href="#1-Java注释" class="headerlink" title="1. Java注释"></a><a href="#one">1. Java注释</a></h2><h2 id="2-Java数据类型"><a href="#2-Java数据类型" class="headerlink" title="2. Java数据类型"></a><a href="#two">2. Java数据类型</a></h2><h2 id="3-Java变量"><a href="#3-Java变量" class="headerlink" title="3. Java变量"></a><a href="#three">3. Java变量</a></h2><h2 id="4-Java运算符"><a href="#4-Java运算符" class="headerlink" title="4. Java运算符"></a><a href="#four">4. Java运算符</a></h2><h2 id="5-Java字符串"><a href="#5-Java字符串" class="headerlink" title="5. Java字符串"></a><a href="#five">5. Java字符串</a></h2><h2 id="6-Java输入流"><a href="#6-Java输入流" class="headerlink" title="6. Java输入流"></a><a href="#six">6. Java输入流</a></h2><h2 id="7-Java数组"><a href="#7-Java数组" class="headerlink" title="7. Java数组"></a><a href="#seven">7. Java数组</a></h2><h2 id="8-大数值"><a href="#8-大数值" class="headerlink" title="8. 大数值"></a><a href="#eight">8. 大数值</a></h2><p>一般我们在学习一门语言的时候，总是从hello world入门，所以我们也是从hello world开始入门。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstSample</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果你想运行一个java程序，那么需要在类里面加上main方法，作为程序的入口让程序运行起来。格式如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String口 args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        program statements</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="1-注释"><a href="#1-注释" class="headerlink" title="1. 注释"></a>1.<a id="one"></a> 注释</h3><p>注释一般用于书写一些关于程序或者变量，算法的说明。用于辅助他人阅读你的程序代码，增加代码的可读性。</p><p>Java的注释可以分成三种注释。</p><blockquote><ol><li>以双反斜杠标记的注释 //</li></ol></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;如下代码所示，通过//注释对变量进行解释说明。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String口 args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i , j ; <span class="comment">// i和j为临时变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>2, 以/<em> TO-DO </em>/,将一段内容进行注释。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;这个注释和//注释的区别在于。//是单行注释，而/<em>….</em>/可以表示多行注释。示例如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String口 args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这是多行注释。</span></span><br><span class="line"><span class="comment">            可以注释多行。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="keyword">int</span> i , j ; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>第三种是/<em>* </em>/注释，称为文档注释，用于生成程序说明文档。一般在类上或者方法上进行注释。</li></ol></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;示例如下：通过文档注释，标明了类创建的时间。关于文档注释的其它声明，可以查阅相关资料。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021-10-26 19:44</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java</span>基本数据类型 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果想要程序在执行中间退出，则通过System.exit()退出程序</span></span><br><span class="line">        System.exit(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;程序中止返回&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. <a id="two"></a>数据类型</h3><p>Java是一种强类型语言，Java的变量在使用前，都需要进行变量的声明。Java有8种基本数据类型。分别为4种整型，2种浮点型，1种字符型，1种布尔型(boolean).</p><blockquote><p>1, 整型</p></blockquote><p>整型也就是常说的整数。用于表示数据为整数。</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">字长</th><th style="text-align:center">取值</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">1</td><td style="text-align:center">-128-127</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">2</td><td style="text-align:center">-2^15-(2^15-1)</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">4</td><td style="text-align:center">-2^31-(2^31-1)</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">8</td><td style="text-align:center">-2^63-(2^63-1)</td></tr></tbody></table></div><p>示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">basicType</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">byte</span> a ;</span><br><span class="line">       <span class="keyword">short</span> b ;</span><br><span class="line">       <span class="keyword">int</span> c;</span><br><span class="line">       <span class="keyword">long</span> d  ;</span><br><span class="line">       d = <span class="number">10000000L</span> ; <span class="comment">//通过L表示为长整型数据</span></span><br><span class="line">       c = <span class="number">0x123</span> ; <span class="comment">//通过0x表示为十六进制</span></span><br><span class="line">       c = <span class="number">0b1001</span> ; <span class="comment">//通过0b表示二进制数据</span></span><br><span class="line">       c = <span class="number">010</span> ; <span class="comment">//通过0开头，表示为八进制数据。</span></span><br><span class="line">   &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure></p><blockquote><ol><li>浮点类型</li></ol></blockquote><p>浮点类型的数据也就是我们常说的小数。</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">字长</th><th style="text-align:center">取值</th></tr></thead><tbody><tr><td style="text-align:center">float</td><td style="text-align:center">4</td><td style="text-align:center">大约 ± 3.402 823 47E+38F (有效位数为 6 ~ 7 位）</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8</td><td style="text-align:center">大约 ± 1.797 693 134 862 315 70E+308 (有效位数为 15 位)</td></tr></tbody></table></div><p>double 表示这种类型的数值精度是 float 类型的两倍（有人称之为双精度数值)。绝大部分应用程序都采用 double 类型。float 类型的数值有一个后缀 F 或 f (例如，3.14F。) 没有后缀 F 的浮点数值（如 3.14 ) 默认为double 类型。当然，也可以在浮点数值后面添加后缀 D 或 d (例如，3.14D)<br>。</p><blockquote><ol><li>字符类型<br>字符类型char采用unicode编码格式。char 类型的字面量值要用单引号括起来。, char 类型的值可以表示为十六进制值，其范围从 \u0000 到 \Uffff。例如：W2122 表示注册符号 ( ), \u03C0 表示希腊字母 it。在Java中，char类型占用两个字节（采用16位的Unicode字符集）。示例代码如下，用于输出显示两个特殊的字符。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">basicType</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">char</span> g = <span class="string">&#x27;\u2122&#x27;</span>; <span class="comment">//注册符号 Tm</span></span><br><span class="line">      System.out.println(g);</span><br><span class="line">      g = <span class="string">&#x27;\u03C0&#x27;</span> ;</span><br><span class="line">      System.out.println(g);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li>Boolean类型<br>boolean(布尔)类型一般有两个值:true和false,用来判定逻辑条件。在Java中整型不能替代布尔类型(这在C/c++却是可以的。)</li></ol></blockquote><p>对于数据类型，我们可以在不同的数据类型之间进行转化(强制类型转换)。</p><h3 id="3-变量"><a href="#3-变量" class="headerlink" title="3.  变量"></a>3. <a id="three"></a> 变量</h3><p>变量的声明在前面数据类型也可以看到。一般格式为：数据类型  变量名; </p><blockquote><p>变量名的命名格式</p></blockquote><p>变量名必须是一个以字母开头并由字母或数字构成的序列。需要注意，与大多数程序设<br>计语言相比，Java 中“ 字母” 和“ 数字” 的范围更大。字母包括“A’~Z”、“a~z”、或在某种语言中表示字母的任何 Unicode 字符。</p><blockquote><p>变量的初始化和赋值操作</p></blockquote><p>初始化一般是在变量的声明时候，给变量一个初始值(这是一个好的编程习惯)。变量的赋值一般通过=对变量进行赋值操作。示例代码如下所示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">30</span> , b ; <span class="comment">//对变量进行初始化</span></span><br><span class="line">      b = <span class="number">20</span> ; <span class="comment">//对变量进行赋值</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>常量</p></blockquote><p>常量也就是一直不变的量，只能被赋值一次。一般我们通过final来指示常量(一般用纯大写作为变量名，下划线进行分割)。示例代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">30</span> , b ; <span class="comment">//对变量进行初始化</span></span><br><span class="line">    b = <span class="number">20</span> ; <span class="comment">//对变量进行赋值</span></span><br><span class="line">    <span class="keyword">final</span>  <span class="keyword">double</span> PI = <span class="number">3.1415962</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于类常量，一般是作为类的成员变量，并且访问修饰符为static。可以理解为，加了sttic外部就能直接引用该变量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.1415926</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4. 运算符"></a>4. <a id="four"></a>运算符</h3><p>运算符一般就是加减乘除这些运算符，以及一些特殊操作。+,-,*./,%(取余)。</p><p>对于取余有一个技巧，保证不取负数。通过（(position +<br>adjustment) % 12 + 12) % 12。公式进行取余操作，就保证了余数在0-11之间，不出现负数的情况。</p><p>还有一些运算符属于双目运算符，如 +=,-=,*=…。这写运算符和前面的运算符类似只不过，多了赋值操作。a += b; 等价于 a = a+b 。可以编程进行验证。</p><p>自增运算符：++和—, x++也就等价于 x += 1; </p><p>关系运算符：主要是用于比较数值的大小，如&gt;=,&lt;=,&gt;,&lt;，!= 等关系运算。简单的例子就是：a&gt;b ,比较a和b的大小。</p><p>逻辑运算符：也就是与，或，非三个运算。&amp;&amp; 表示与， || 表示或，！表示非。一般用于条件表达式表示多条件的情况。如表示 a&gt; b 且 a&gt; c的情况,可以写成 a&gt;b &amp;&amp; a&gt;c </p><p>三元操作符?: 用法 a&gt;b?a:b 。如果a&gt;b则执行a,反之执行b</p><p>位运算符：&amp;,|,^（异或）,~(非)。一般用于对整数各个位(二进制)进行位运算。&gt;&gt;和&lt;&lt;运算符，用于将数据左移和右移。需要建立位模式来完成位掩码时， 这两个运算符会很方便。&gt;&gt;&gt;会用0填充高位，而&gt;&gt;则是用符号位填充高位。移位运算符的右操作数要完成模 32 的运算（除非左操作数是 long 类型， 在这种情况下需要对右操作數模 64 )。例如， 1 «35 的值等同于 1 «3 或 8。也就是最多不会超过int类型，如果超过那么就等同于模32后再右移动。</p><blockquote><p>运算符优先级<br>运算符优先级也就是运算符的优先执行顺序。如果不确定优先级，我们可以用括号包含起来。<br>运算符优先级 单目运算(!,~,++,new,强制类型转换) &gt; (*，/,%) &gt; (+,-) &gt; (&lt;&lt;, &gt;&gt; , &gt;&gt;&gt;) &gt; (&lt; , &gt;  , &gt;= , instanceof) &gt; (==,!=) &gt; (&amp;) &gt; (^) &gt;(|) &gt; (&amp;&amp;) &gt; (||) &gt; (?) &gt; (=,+=,-=……)。</p><p>枚举类型<br>通过enum 进行枚举类型的声明，包括有限个命名的值。示例代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> 枚举类型 </span>&#123;</span><br><span class="line">    SMALL(<span class="number">1</span>,<span class="string">&quot;小号&quot;</span>),</span><br><span class="line">    MEDIUM(<span class="number">2</span>,<span class="string">&quot;中号&quot;</span>),;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code ;</span><br><span class="line">    <span class="keyword">private</span> String message ;</span><br><span class="line">    枚举类型(<span class="keyword">int</span> code , String message)&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code ;</span><br><span class="line">        <span class="keyword">this</span>.message = message ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">(String define)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 返回枚举类型的code,根据Message</span></span><br><span class="line">        <span class="keyword">return</span> 枚举类型.valueOf(define).code ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMessage</span><span class="params">(String define)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> 枚举类型.valueOf(define).message ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="5-字符串"><a href="#5-字符串" class="headerlink" title="5. 字符串"></a>5. <a id="five"></a>字符串</h3><p>字符串也就是一串字符，通常用””包含。一般我们使用String表示字符类型。示例: String str = “hello world” ; , 字串则是字符串的一串连续的字符，如”worl”就是str的一个字串。如果需要拼接字符，可以通过+号进行拼接。如果需要拼接多个，可以通过定界符(，)分割，然后用静态join方法拼接。如:String str = String.join(“h”,”ello”,”w”,”rold”) ; </p><p>Java如果要修改某个字符，一般需要创建新的字符常量对象。Java的String类似于指针，指向字串常量在存储池（堆）的相应位置。如果指向相同的字符常量， 则这两个变量是相同的。可以运行如下代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">byteString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String a = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        String b = <span class="string">&quot;123&quot;</span> ;</span><br><span class="line">        String c = <span class="keyword">new</span> String(<span class="string">&quot;123&quot;</span>) ;</span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">        System.out.println(a.equals(b));</span><br><span class="line">        System.out.println(a == c);</span><br><span class="line">        System.out.println(a.equals(c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面的代码中两个变量 a == b 比较的是两个变量是否相同(类比于比较地址是否相同)，a.equeals(b)检测的是两个字符串是否相等。<br>检查一个字符串既不是 null 也不为空串，这种情况下就需要使用以下条件：if (str != null &amp;&amp; str.length()!= 0),先检测变量是否为空，在判断长度是否为空。</p><blockquote><p>StringBuffer和StringBuilder的区别</p></blockquote><p>StringBuilder支持单线程，StringBuffer支持多线程。就效率而言,StringBuilder快于StringBuffer，所以在单线程程序中采用StringBuilder较好，多线程程序采用StringBuffer。</p><h3 id="6-输入输出流"><a href="#6-输入输出流" class="headerlink" title="6. 输入输出流"></a>6. <a id="six"></a>输入输出流</h3><p>java输入输出流，通过Scanner对象和标准输入流（System.in）相关联进行获取。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ioStream</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// Java构建输入流，通过Scanner对象和标准输入流Sytem.in对象关联。</span></span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in) ;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;输入字符：&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String text = in.nextLine() ;</span><br><span class="line"></span><br><span class="line">        System.out.println(text);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因为输入是可见的， 所以 Scanner 类不适用于从控制台读取密码。Java SE 6 特别<br>引入了 Console 类实现这个目的。要想读取一个密码， 可以采用下列代码：</p><pre><code>Console cons = System.console();String username = cons.readLine(&quot;User name: &quot;)；char [] passwd = cons.readPassword(&quot;Password:&quot;);</code></pre><p>为了安全起见， 返回的密码存放在一维字符数组中， 而不是字符串中。在对密码进<br>行处理之后，应该马上用一个填充值覆盖数组元素（数组处理将在 3.10 节介绍）。<br>采用 Console 对象处理输入不如采用 Scanner 方便。每次只能读取一行输入， 而没有<br>能够读取一个单词或一个数值的方法。</p><blockquote><p>格式化输出<br>最简单的方法是采用C语言的方法进行输出System.printf就可以通过C语言的printf输出方式进行输出。</p><p>文件输入与输出<br>通过File对象构建Scanner对象进行文件的读取，通过PrintWriter进行文件的输出。示例代码如下所：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileIO</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//文件输入流 , get路径为文件路径</span></span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(Paths.get(<span class="string">&quot;javase/src/main/java/Java核心技术/第三章Java的基本程序设计/myfile.txt&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>) ;</span><br><span class="line">        <span class="keyword">while</span>(in.hasNext())&#123;</span><br><span class="line">            System.out.println(in.next());</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">        System.out.println();</span><br><span class="line">        in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">&quot;javase/src/main/java/Java核心技术/第三章Java的基本程序设计/myfile.txt&quot;</span>)) ;</span><br><span class="line">        <span class="keyword">while</span>(in.hasNextLine())&#123;</span><br><span class="line">            System.out.println(in.nextLine());</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文件输出流，路径填写文件路径</span></span><br><span class="line">        PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> File(<span class="string">&quot;javase/src/main/java/Java核心技术/第三章Java的基本程序设计/myfile.txt&quot;</span>) ) ;</span><br><span class="line">        out.write(<span class="string">&quot;this is a test two&quot;</span>);</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="7-数组"><a href="#7-数组" class="headerlink" title="7.数组"></a>7.<a id="seven"></a>数组</h3><p>数组存储了一串连续地址的元素，通过元素下标可以访问到数组元素。数组有如下几种声明方式。</p><pre><code>int[] a ;int[] a = new int[100] ; int a[] ; int[] a = &#123;1,2,3,4,5&#125; ; new int[] &#123;17,19,23,29&#125; ; //匿名数组</code></pre><blockquote><p>数组的迭代方法</p><ol><li>for，while循环<br>通过遍历数组下标来遍历数组的元素</li><li>for-each循环<br>通过for-each遍历数组的每一个元素。for-each的一般形式为：for (variable : collection) statement。如果要遍历集合，那么对应的集合必须是数组或者实现了Iterable接口的类对象。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">array</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i ;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125; ;</span><br><span class="line">        <span class="comment">//for循环遍历</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; a.length ; i++)&#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for-each循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> temp : a)&#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>打印数组<br>通过Arrays类的toString方法，可以打印一个数组。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">array</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i ;</span><br><span class="line">       <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125; ;</span><br><span class="line">       <span class="comment">//for循环遍历</span></span><br><span class="line">       <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; a.length ; i++)&#123;</span><br><span class="line">           System.out.println(a[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//for-each循环</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> temp : a)&#123;</span><br><span class="line">           System.out.println(temp);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//打印数组</span></span><br><span class="line">       System.out.println(Arrays.toString(a) );;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br>数组拷贝<br>简单的数组赋值，只是浅拷贝，二者指向的还是一个堆栈空间。如果需要进行数值拷贝，则通过Arrays.copyOf进行数据的拷贝。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125; ; </span><br><span class="line"><span class="keyword">int</span>[] b ; </span><br><span class="line">b = a ; <span class="comment">//这是简单的赋值，浅拷贝</span></span><br><span class="line">b[<span class="number">1</span>] = <span class="number">10</span> ;<span class="comment">// 则a[1]也变为10 </span></span><br><span class="line">b = Arrays.copyOf(a,a.length) ; <span class="comment">//</span></span><br><span class="line">b[<span class="number">1</span>] = <span class="number">2</span> ; <span class="comment">//则a[1] 还是为10并不影响。</span></span><br></pre></td></tr></table></figure><br>Arrays包含许多关于数组的操作,包括数组的打印，数组的拷贝，排序等功能。</p><p>数组排序<br>通过Arrays.sort（a），可以对数组a进行排序（无返回值）。该排序方法使用了优化的快速排序算法(可以阅读源码，理解排序方法)。</p><p>数组填充<br>通过Arrays.fill（a,value），用数据填充数组。</p><p>多维数组<br>多维数组的初始化方法：<br>    double[][] balances ;<br>    balances = new double[NYEARS] [NRATES];<br>    int[][] magicSquare =<br>            {<br>                {16, 3, 2, 13}， {5, 10, 11, 8},<br>                (9, 6, 7, 12},<br>                {4, 15, 14, 1}<br>            };<br>多维数组的迭代<br>for循环迭代，只需要通过下标进行迭代即可。<br>for-each迭代格式如下：</p></blockquote><pre><code>for (doubleG row : a)    for (double value : row)        do something with value        </code></pre><blockquote><p>多维数组的打印<br>通过Arrays.deepToString进行多为数组的打印。</p><p>不规则的数组<br>不规则数组一般是多维的维数可能不一致。如果需要创建多维数组，必须先分配具有所含行数的数组，然后再分配行数组的长度。</p><h3 id="8-大数值-1"><a href="#8-大数值-1" class="headerlink" title="8. 大数值"></a>8. <a id="eight"></a>大数值</h3><p>如果基本的整数和浮点数精度不能够满足需求， 那么可以使用jaVa.math 包中的两个<br>很有用的类：Biglnteger 和 BigDecimaL 这两个类可以处理包含任意长度数字序列的数值。<br>Biglnteger 类实现了任意精度的整数运算， BigDecimal 实现了任意精度的浮点数运算。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bigData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//通过BigInter和BigDecimal可以实现大数的运算,需要将数据转化为大数对象，再进行运算。</span></span><br><span class="line">        BigInteger a = BigInteger.valueOf(<span class="number">1</span>) ;</span><br><span class="line">        a = a.add(BigInteger.valueOf(Long.MAX_VALUE));</span><br><span class="line">        System.out.println(a.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Java注释&quot;&gt;&lt;a href=&quot;#1-Java注释&quot; class=&quot;headerlink&quot; title=&quot;1. Java注释&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#one&quot;&gt;1. Java注释&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;2-Java数据类型&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="JavaSE" scheme="http://example.com/categories/JavaSE/"/>
    
    
      <category term="JAVA" scheme="http://example.com/tags/JAVA/"/>
    
      <category term="JAVASE" scheme="http://example.com/tags/JAVASE/"/>
    
  </entry>
  
  <entry>
    <title>1. Java介绍</title>
    <link href="http://example.com/wiki/JavaSE/%E7%AC%AC%E4%B8%89%E7%AB%A0-Java%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/java%20introduce/"/>
    <id>http://example.com/wiki/JavaSE/第三章-Java基本程序结构/java introduce/</id>
    <published>2021-10-26T06:59:14.834Z</published>
    <updated>2021-11-15T01:54:07.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Java语言的特性"><a href="#1-Java语言的特性" class="headerlink" title="1. Java语言的特性"></a><a href="#one">1. Java语言的特性</a></h2><h2 id="2-JAVA8新特性"><a href="#2-JAVA8新特性" class="headerlink" title="2. JAVA8新特性"></a><a href="#two">2. JAVA8新特性</a></h2><h3 id="1-Java语言的特性-1"><a href="#1-Java语言的特性-1" class="headerlink" title="1. Java语言的特性"></a>1. <a id="one"></a>Java语言的特性</h3><p>1 ) 简单性</p><p>Java语法相对于C++而言，少了很多复杂与语法，如头文件，指针运算，结构，联合，操作符重载，虚基类等。</p><p>2 ) 面向对象</p><p>面向对象是一种程序设计技术，与之相对应的技术为面向过程。面向对象的程序设计在设计方法上着重于事物的属性和行为的设计，而不是具体的过程上进行设计。</p><p>3 ) 分布式</p><p>分布式也就是将一个任务分到多个服务器进行解决。Java提供了丰富的例程库，用于处理TCP/IP协议。</p><p>4 ) 健壮性</p><p>Java在对程序错误的检测包括，编译时错误和运行时错误，消除了容易出错的情况。并且对于Java采用的指针模型，可以消除重写内存和损坏数据的可能性。</p><p>5 ) 安全性</p><p> 从一开始，Java 就设计成能够防范各种攻击，其中包括：</p><pre><code>•运行时堆栈溢出。 如蠕虫和病毒常用的攻击手段。•破坏自己的进程空间之外的内存。•未经授权读写文件</code></pre><p>Java 浏览器插件不再信任远程代码，除非代码有数字签名而且用户同意执行这个代码</p><p>6 ) 体系结构中立</p><p>编译器生成字节码文件(类似于用一个新语言进行解释),只要有java运行环境，就能够在计算机上运行程序。虚拟机可以将执行最频繁的字节码序列翻译成机器码(即时编译)，加快运行速度。(字节码的解释程序由C语言进行实现。)</p><p>Java源程序-编译器&gt;生成字节码文件(出现频繁的字节码序列会被翻译成机器码)-java虚拟机&gt;运行字节码文件，运行Java程序。</p><p>7 ) 可移植性</p><p>Java中的int永远为32位的整数，与平台无关。字符数据通过Unicode格式存储。</p><p>8 ) 解释型</p><p>Java 解释器可以在任何移植了解释器的机器上执行 Java 字节码。Java是解释型语言。</p><p>9 ) 高性能</p><p>即时编译器可以监控经常执行哪些代码并优化这些代码以提高速度。更为复杂的优化是消除函数调用（即“ 内联”）。即时编译器知道哪些类已经加载。基于当前加载的类集， 如果特定的函数不会被覆盖，就可以使用内联。必要时，还可以撤销优化。</p><p>10 ) 多线程</p><p>多线程可以带来更好的交互响应和实时行为。</p><p>11 ) 动态性</p><p>从各种角度看， Java 与 C 或 C++ 相比更加具有动态性。它能够适应不断发展的环境库中可以自由地添加新方法和实例变量， 而对客户端却没有任何影响。在Java 中找出运行时类型信息十分简单。当需要将某些代码添加到正在运行的程序中时， 动态性将是一个非常重要的特性。</p><blockquote><p>总结Java特性：Java采用字节码文件作为编译后的文件，通过JVM生成字节码文件，并且对于常用出现的字节码序列会转化为机器码(即时编译器))，加快程序编译运行速度。并且Java与平台无关，拥有丰富的库，能够支持分布式，动态式，多线程。并且很安全。</p></blockquote><h3 id="2-JAVA8新特性-1"><a href="#2-JAVA8新特性-1" class="headerlink" title="2. JAVA8新特性"></a>2. <a id="two"></a>JAVA8新特性</h3><pre><code>Lambda表达式，包含默认方法的接口，流和时间/日期库</code></pre><h3 id="JAVA开发环境"><a href="#JAVA开发环境" class="headerlink" title="JAVA开发环境"></a>JAVA开发环境</h3><blockquote><h4 id="一些Java环境术语"><a href="#一些Java环境术语" class="headerlink" title="一些Java环境术语"></a>一些Java环境术语</h4><blockquote><ul><li><p>JDK（Java Development Kit）: 编写Java程序的程序员使用的软件。在Java 1.2-1.4版本被称为Java SDK (软件开发包,Software Development Kit)。我们现在经常看到关于JDK1.8,以及Java8，那么二者之间是什么关系呢？Java早期发布版本是直接增加小数点后面的数值。例如1.3，1.4，1.5等。而在2006年后版本号进行简化，开始次啊用Java SE6,Java SE 7 ,Java SE 8 作为版本号，这就是我们常熟悉的版本号。但是对于其内部的版本号，分别是1.6.0，1.7.0，1.8.0。对于版本号为1.8.0_31（Java SE 8u31）表示的是对Java SE 8 的第31次修改后的版本。</p></li><li><p>JRE（Java Runtime Enviroment）:运行Java程序的用户使用的软件。</p></li><li>SE(Standard Edition): 用于桌面或简单服务器应用的Java平台。</li><li>EE(Enterprise Edition):用于复杂服务器应用的Java平台。</li><li>ME(Micro Edition):用于手机和其它小型设备的Java平台。 </li></ul></blockquote></blockquote><h4 id="命令行操作"><a href="#命令行操作" class="headerlink" title="命令行操作"></a>命令行操作</h4><ol><li>通过命令行命令查看Java版本号 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -version</span><br></pre></td></tr></table></figure></li><li>通过命令行运行Java程序<br> 通过javac编译java源程序，通过java程序启动java虚拟机，虚拟机执行编译器放在class文件的字节码。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac xxxx.java</span><br><span class="line">java xxxx</span><br></pre></td></tr></table></figure> 在编译运行java程序的时候，会将程序中包含main方法的类名提供给字节码解释器，以便启动程序。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Java语言的特性&quot;&gt;&lt;a href=&quot;#1-Java语言的特性&quot; class=&quot;headerlink&quot; title=&quot;1. Java语言的特性&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#one&quot;&gt;1. Java语言的特性&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;2-JAVA8新
      
    
    </summary>
    
      <category term="JavaSE" scheme="http://example.com/categories/JavaSE/"/>
    
    
      <category term="JAVA" scheme="http://example.com/tags/JAVA/"/>
    
      <category term="JAVASE" scheme="http://example.com/tags/JAVASE/"/>
    
  </entry>
  
  <entry>
    <title>48.旋转数组</title>
    <link href="http://example.com/wiki/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/48.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <id>http://example.com/wiki/算法/Leetcode/数组/48.旋转数组/</id>
    <published>2021-10-26T04:21:45.745Z</published>
    <updated>2021-10-26T04:48:30.703Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  通过辅助数组进行实现</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[][] totataMatrix = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix.length] ;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span> , j = <span class="number">0</span> , len = matrix.length;</span><br><span class="line">      <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; len ; j++)&#123;</span><br><span class="line">              totataMatrix[j][len-i-<span class="number">1</span>] = matrix[i][j];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; len ; j++)&#123;</span><br><span class="line">              matrix[i][j] = totataMatrix[i][j];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果需要原地旋转，那就必须需要考虑数组下标之间的关系，然后进行旋转操作</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotateTwo</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span> , j = <span class="number">0</span> , len = matrix.length;</span><br><span class="line">      <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; len / <span class="number">2</span>; i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; (len+<span class="number">1</span>) /<span class="number">2</span> ; j++)&#123;</span><br><span class="line">              <span class="keyword">int</span> temp = matrix[i][j] ;</span><br><span class="line">              matrix[i][j] = matrix[len-j-<span class="number">1</span>][i] ;</span><br><span class="line">              matrix[len-j-<span class="number">1</span>][i] = matrix[len-i-<span class="number">1</span>][len-j-<span class="number">1</span>] ;</span><br><span class="line">              matrix[len-i-<span class="number">1</span>][len-j-<span class="number">1</span>] = matrix[j][len-i-<span class="number">1</span>] ;</span><br><span class="line">              matrix[j][len-i-<span class="number">1</span>] = temp ;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数组选择90度又可以转换为数组翻转问题，首先进行上下翻转，然后再根据主对角线进行翻转。</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotateThree</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span> , j = <span class="number">0</span> , len = matrix.length;</span><br><span class="line">      <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; len / <span class="number">2</span>; i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; (len+<span class="number">1</span>) /<span class="number">2</span> ; j++)&#123;</span><br><span class="line">              <span class="keyword">int</span> temp = matrix[i][j] ;</span><br><span class="line">              matrix[i][j] = matrix[len-j-<span class="number">1</span>][i] ;</span><br><span class="line">              matrix[len-j-<span class="number">1</span>][i] = matrix[len-i-<span class="number">1</span>][len-j-<span class="number">1</span>] ;</span><br><span class="line">              matrix[len-i-<span class="number">1</span>][len-j-<span class="number">1</span>] = matrix[j][len-i-<span class="number">1</span>] ;</span><br><span class="line">              matrix[j][len-i-<span class="number">1</span>] = temp ;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>36.有效数独</title>
    <link href="http://example.com/wiki/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/36.%E6%9C%89%E6%95%88%E6%95%B0%E7%8B%AC/"/>
    <id>http://example.com/wiki/算法/Leetcode/数组/36.有效数独/</id>
    <published>2021-10-26T02:09:42.061Z</published>
    <updated>2021-10-26T04:48:10.980Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public boolean <span class="function"><span class="title">isValidSudokuTwo</span>(<span class="params">char[][] board</span>)</span> &#123;</span><br><span class="line">        int i = <span class="number">0</span> , j = <span class="number">0</span> , k = <span class="number">0</span> , l = <span class="number">0</span> , idx  ;</span><br><span class="line">        HashMap&lt;Integer, HashSet&lt;Character&gt;&gt; area = <span class="keyword">new</span> HashMap&lt;Integer, HashSet&lt;Character&gt;&gt;() ;</span><br><span class="line">        <span class="comment">//判断行列是否符合数独条件</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; board.length ; i++)&#123;</span><br><span class="line">            HashMap&lt;Character, Integer&gt; row = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;() ;</span><br><span class="line">            HashMap&lt;Character, Integer&gt; col = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;() ;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; board.length ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] != <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(row.containsKey(board[i][j]))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        row.put(board[i][j],<span class="number">1</span>) ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(board[j][i] != <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(col.containsKey(board[j][i]))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        col.put(board[j][i],<span class="number">1</span>) ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                idx = (i/<span class="number">3</span>)*<span class="number">3</span> + j/<span class="number">3</span> ;</span><br><span class="line">                <span class="keyword">if</span>(!area.containsKey(idx))&#123;</span><br><span class="line">                    area.put(idx,<span class="keyword">new</span> HashSet&lt;Character&gt;()) ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(area.get(idx).contains(board[i][j]))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    area.get(idx).add(board[i][j]) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>  ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
      <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Git常见的问题及解决方案</title>
    <link href="http://example.com/wiki/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/Git/%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/wiki/程序技术/Git/问题/</id>
    <published>2021-10-25T11:43:34.168Z</published>
    <updated>2021-11-04T06:51:28.358Z</updated>
    
    <content type="html"><![CDATA[<!--编写md文件的时候，需要指明文章名称title,文章分类categroies,文章标签tags--><h3 id="Git使用教程"><a href="#Git使用教程" class="headerlink" title="Git使用教程"></a>Git使用教程</h3><h2 id="Git常见问题"><a href="#Git常见问题" class="headerlink" title="Git常见问题"></a>Git常见问题</h2><h3 id="1-当能够正常运行的项目突然无法运行，出现找不到资源文件错误的时候。"><a href="#1-当能够正常运行的项目突然无法运行，出现找不到资源文件错误的时候。" class="headerlink" title="1. 当能够正常运行的项目突然无法运行，出现找不到资源文件错误的时候。"></a>1. 当能够正常运行的项目突然无法运行，出现找不到资源文件错误的时候。</h3><pre><code>首先，能运行就标明项目本身并没有问题。对于资源文件找不到，可能就和系统的缓存加载有关。</code></pre><p>所以这个时候，可以对项目的依赖文件进行重新的审查，如果没有问题，再查看依赖是否有问题。对于Maven项目的依赖问题，<br>可以重新clean被依赖的工程，再重新install被依赖的工程。重新加载资源文件。</p><h3 id="2-git提交代码到Github时候，出现fatal-unable-to-access-‘https-github-com-zzcpage-zzcpage-github-io-git-‘-OpenSSL-SSL-read-Connection-was-reset-errno-10054"><a href="#2-git提交代码到Github时候，出现fatal-unable-to-access-‘https-github-com-zzcpage-zzcpage-github-io-git-‘-OpenSSL-SSL-read-Connection-was-reset-errno-10054" class="headerlink" title="2. git提交代码到Github时候，出现fatal: unable to access ‘https://github.com/zzcpage/zzcpage.github.io.git/‘: OpenSSL SSL_read: Connection was reset, errno 10054"></a>2. git提交代码到Github时候，出现<font color="red">fatal: unable to access ‘<a href="https://github.com/zzcpage/zzcpage.github.io.git/">https://github.com/zzcpage/zzcpage.github.io.git/</a>‘: OpenSSL SSL_read: Connection was reset, errno 10054</font></h3><p>产生的原因：一般是这是因为服务器的SSL证书没有经过第三方机构的签署，所以才报错。</p><p>解决方法：解除ssl验证后，再次git即可。</p><p>通过<font color="red">git config —global http.sslVerify “false”</font>命令进行解除SSL验证，解除完之后，再次Git即可提交成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!--编写md文件的时候，需要指明文章名称title,文章分类categroies,文章标签tags--&gt;
&lt;h3 id=&quot;Git使用教程&quot;&gt;&lt;a href=&quot;#Git使用教程&quot; class=&quot;headerlink&quot; title=&quot;Git使用教程&quot;&gt;&lt;/a&gt;Git使用教程&lt;/h
      
    
    </summary>
    
      <category term="程序技术" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Git" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/Git/"/>
    
    
      <category term="Git" scheme="http://example.com/tags/Git/"/>
    
      <category term="Bug解决方案" scheme="http://example.com/tags/Bug%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
</feed>
