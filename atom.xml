<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-11-15T03:19:12.371Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>ZZC</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>4. Java对象与类</title>
    <link href="http://example.com/wiki/JavaSE/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/class/"/>
    <id>http://example.com/wiki/JavaSE/第四章-对象与类/class/</id>
    <published>2021-11-03T07:05:53.433Z</published>
    <updated>2021-11-15T03:19:12.371Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象程序设计OOP(Object Oriented Programming)。</p><p>类用于描述对象所具有的属性和方法，具体的对象称为类的一个实例。</p><p>封装也就是将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式。</p><p>对象的三个特性，行为，状态，标识。</p><p>对象的行为描述了对象具有哪些操作，对象的状态（状态也就是对象当前的特征信息）决定了在不同情况下相应的操作的响应，对象的标识描述了不同的实例对象。</p><blockquote><p>类之间的关系</p></blockquote><ol><li><p>依赖关系(uses-a)</p><p> 如果一个类A的方法使用了另一个类B，那么就形成了依赖关系。<br> A依赖于B。（过多的依赖会使得类之间的耦合度高）</p></li><li><p>聚合关系(has-a)</p><p> 如果类A包含一些类B，那么A和B是聚合关系。</p></li><li><p>继承关系(is-a)</p><p> 父类和子类的关系，也就是继承关系。</p></li></ol><p>UML（Unified Modeling Language,统一建模语言）中类关系的表示：<br><img src="/images/UML.PNG" alt="a1"></p><p>Java中的对象通过new进行创建，通过new创建一个新的对象变量。一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。通过new 操作符的返回值也是一个引用。这可以理解为Java中所有的对象变量实际上就是一个指针，指向实际对象所在的地址。</p><blockquote><ol><li>更改器方法(get),访问器方法(set)</li></ol></blockquote><p>注意不要编写返回引用可变对象的访问器方法。如果返回了可变对象，那么在类外部对返回对象的改变，同时也会影响到类内部的变量。<br>如果需要返回一个可变对象的引用，首先因该对它进行克隆(clone)。对象的clone是指存放在另一个位置上的对象副本。<br>如果需要返回一个可变数据域的拷贝，就应该使用 clone。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Employee other)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name.equals(other.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上段代码，我们可以看出，在equals方法中，调用了other的私有变量。对于Javaa来说，类的方法可以访问该类的任何对象的遍私有变量。<br>类方法可以访问所属类的私有特性。</p><blockquote><ol><li>构造器</li></ol></blockquote><pre><code>•构造器与类同名•每个类可以有一个以上的构造器•构造器可以有 0 个、1 个或多个参数•构造器没有返回值•构造器总是伴随着 new 操作一起调用</code></pre><blockquote><ol><li>隐式参数与显示参数</li></ol></blockquote><p>以下列代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> a ;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.a;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们对于方法setA,可以看出对于参数a是显示的参数。而隐式参数是谁呢？隐式参数是调用该方法调用的类对象，通过关键字this表示隐式参数。</p><p>第一个参数称为隐式 （ implicit ) 参数， 是出现在方法名前的Employee 类对象。第二个参数位于方法名后面括号中的数值，这是一个显式 （ explicit)参数（ 有些人把隐式参数称为方法调用的目标或接收者。</p><p>也就是说，this表明该方法的调用者。</p><blockquote><ol><li>访问修饰符</li></ol></blockquote><div class="table-container"><table><thead><tr><th>修饰符</th><th>作用</th></tr></thead><tbody><tr><td>public</td><td>公开的</td></tr><tr><td>private</td><td>私有的</td></tr><tr><td>final</td><td>final 修饰符大都应用于基本 （primitive ) 类型域，或不可变（immutable)类的域（如果类中的每个方法都不会改变其对象， 这种类就是不可变的类)。</td></tr><tr><td>static</td><td>静态域（类域）和静态方法。对于静态域变量，该变量属于类，而不属于任何独立的对象，通过类就能够直接访问到静态域变量(公开的)，实例对象，也能够访问到该变量，但是该变量属于类，所有对象访问到的静态域对象都是一样的。对于静态域一般可以用于设置静态常量，通过类名就能引用，但是不会被修改。对于静态方法，加在方法名之前，静态方法可以通过类名直接调用，静态方法不属于单独的对象。静态方法不具有this参数，所以静态方法不能访问非静态域的实例域。</td></tr></tbody></table></div><p>在下面两种情下使用静态方法：</p><ol><li>一 方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如：Math.pow) </li><li>一个方法只需要访问类的静态域（例如：Employee.getNextld）</li></ol><p>。</p><h4 id="初始化数据域"><a href="#初始化数据域" class="headerlink" title="初始化数据域"></a>初始化数据域</h4><blockquote><p>默认域初始化</p></blockquote><p>如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值： 数值为 0、布尔值为 false、 对象引用为 null。<br>尽量对对象进行赋初始值，而不是采用默认初始值</p><blockquote><p>构造器初始化<br>通过this可以调用同一个类的另一个构造器。如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String <span class="keyword">double</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// calls Employee(String, double)</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="string">&quot;Employee #&quot;</span> + nextld, s);</span><br><span class="line">    nextld++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过this，引用到了同一个Employee的另一个的构造函数，对类对象进行初始化。</p><p>在声明中赋值</p><p>在初始化块赋值</p></blockquote><p>初始块也就是通过{}包含的一段代码块。只要构造类的对象，这些块就会被执行。初始化块的执行顺序，首先运行初始化块，然后才运行构造器的主体部分。</p><h4 id="Java参数调用"><a href="#Java参数调用" class="headerlink" title="Java参数调用"></a>Java参数调用</h4><p>方法参数共有两种类型：</p><ol><li>基本数据类型（数字、布尔值K</li><li>对象引用。</li></ol><p>Java 程序设计语言总是采用按值调用。也就是说， 方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。一个方法，无法改变基本数据类型的参数，但是对象引用作为参数就不同了。对于引用参数就不一样了，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</p><blockquote><p>总结</p></blockquote><ol><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li><li>一个方法可以改变一个对象参数的状态。</li><li>一个方法不能让对象参数引用一个新的对象。（因为Java的引用对象，并不是真正的引用(只是值的传递),可以通过反证进行证明）</li></ol><h4 id="重载-overloading-和重写-overwrite"><a href="#重载-overloading-和重写-overwrite" class="headerlink" title="重载(overloading)和重写(overwrite)"></a>重载(overloading)和重写(overwrite)</h4><blockquote><p>重载</p></blockquote><p>如果多个方法（比如， StringBuilder 构造器方法）有相同的名字、 不同的参数，便产生了重载。对于不同的重载方法， 通过方法给出的参数类型和特定的方法调用所使用的值类型进行匹配来挑选相应的方法（返回值不作为特征）。。如果编译器找不到匹配的参数， 就会产生编译时错误，因为根本不存在匹配， 或者没有一个比其他的更好。（这个过程被称为重载解析（overloading resolution)。）</p><p>对于一个方法的签名(signature)，包含方法名，方法参数类型构成。方法签名=方法名(参数类型)。</p><blockquote><p>重写</p><p>总结</p></blockquote><p>所有Java对象都是在堆中构造的，构造器总是伴随着new操作符一起使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;面向对象程序设计OOP(Object Oriented Programming)。&lt;/p&gt;
&lt;p&gt;类用于描述对象所具有的属性和方法，具体的对象称为类的一个实例。&lt;/p&gt;
&lt;p&gt;封装也就是将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式。&lt;/p&gt;
&lt;p&gt;对象的
      
    
    </summary>
    
      <category term="JavaSE" scheme="http://example.com/categories/JavaSE/"/>
    
    
      <category term="JAVA" scheme="http://example.com/tags/JAVA/"/>
    
      <category term="JAVASE" scheme="http://example.com/tags/JAVASE/"/>
    
  </entry>
  
  <entry>
    <title>Anaconda配置</title>
    <link href="http://example.com/wiki/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/python/Anaconda/"/>
    <id>http://example.com/wiki/软件配置/python/Anaconda/</id>
    <published>2021-11-02T03:22:44.814Z</published>
    <updated>2021-11-02T03:25:18.217Z</updated>
    
    <content type="html"><![CDATA[<p>Anaconda下载地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/ </a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Anaconda下载地址：&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/&quot;&gt;https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/ &lt;/a&gt;
      
    
    </summary>
    
      <category term="软件配置" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    
      <category term="python配置" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/python%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="配置" scheme="http://example.com/tags/%E9%85%8D%E7%BD%AE/"/>
    
      <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>hexo使用问题</title>
    <link href="http://example.com/wiki/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/hexo/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>http://example.com/wiki/软件配置/hexo/问题解决/</id>
    <published>2021-11-01T07:32:29.409Z</published>
    <updated>2021-11-02T03:22:35.748Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何解决wiki中图片显示不全"><a href="#如何解决wiki中图片显示不全" class="headerlink" title="如何解决wiki中图片显示不全"></a>如何解决wiki中图片显示不全</h3><p>只需要把图片放在images文件夹下， 然后通过/images/xxx.xx进行引用即可，这是通过绝对路径进行引用。如果要通过相对路径引用则每个md需要创建相应的文件夹存放图片，较为麻烦。</p><h3 id="如何解决wiki中mermaid流程图无法显示的问题"><a href="#如何解决wiki中mermaid流程图无法显示的问题" class="headerlink" title="如何解决wiki中mermaid流程图无法显示的问题"></a>如何解决wiki中mermaid流程图无法显示的问题</h3><ol><li>修改 /theme/Wikitten下的config.yml文件</li></ol><p>讲下列代码粘贴到文件末尾<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mermaid: <span class="comment">## mermaid url https://github.com/knsv/mermaid</span></span><br><span class="line">enable: true  </span><br><span class="line"><span class="comment"># default true</span></span><br><span class="line">version: <span class="string">&quot;7.1.2&quot;</span></span><br><span class="line"><span class="comment"># default v7.1.2</span></span><br><span class="line">options:  </span><br></pre></td></tr></table></figure></p><ol><li>下载mermaid</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-filter-mermaid-diagrams</span><br></pre></td></tr></table></figure><ol><li>找到Wikitten下layout下 common/footer.ejs ,替换如下代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;footer id=<span class="string">&quot;footer&quot;</span>&gt;</span><br><span class="line">    &lt;% <span class="keyword">if</span> (theme.mermaid.enable) &#123; %&gt;</span><br><span class="line">        &lt;script src=<span class="string">&#x27;https://unpkg.com/mermaid@&lt;%= theme.mermaid.version %&gt;/dist/mermaid.min.js&#x27;</span>&gt;&lt;/script&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            <span class="keyword">if</span> (window.mermaid) &#123;</span><br><span class="line">                mermaid.initialize(&#123;</span><br><span class="line">                    theme: <span class="string">&#x27;forest&#x27;</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">        &lt;% &#125; %&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;outer&quot;</span>&gt;</span><br><span class="line">                &lt;div id=<span class="string">&quot;footer-info&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;inner&quot;</span>&gt;</span><br><span class="line">                    &lt;%= config.author || config.title %&gt; &amp;copy;</span><br><span class="line">                        &lt;%= date(<span class="keyword">new</span> Date(), <span class="string">&#x27;YYYY&#x27;</span>) %&gt;</span><br><span class="line">                            &lt;a rel=<span class="string">&quot;license&quot;</span> href=<span class="string">&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot;</span>&gt;&lt;img alt=<span class="string">&quot;Creative Commons License&quot;</span> style=<span class="string">&quot;border-width:0&quot;</span> src=<span class="string">&quot;https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png&quot;</span> /&gt;&lt;/a&gt;</span><br><span class="line">                            &lt;br&gt; Powered by &lt;a href=<span class="string">&quot;http://hexo.io/&quot;</span> target=<span class="string">&quot;_blank&quot;</span>&gt;Hexo&lt;/a&gt;. Theme - &lt;a href=<span class="string">&quot;https://github.com/zthxxx/hexo-theme-Wikitten&quot;</span>&gt;wikitten&lt;/a&gt;</span><br><span class="line">                            &lt;% <span class="keyword">if</span> (theme.plugins.busuanzi_count) &#123; %&gt;</span><br><span class="line">                                &lt;br&gt;</span><br><span class="line">                                &lt;span id=<span class="string">&quot;busuanzi_container_site_pv&quot;</span>&gt;&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;fa fa-eye&quot;</span>&gt;&lt;/i&gt; &lt;span id=<span class="string">&quot;busuanzi_value_site_pv&quot;</span>&gt;&lt;/span&gt;&lt;/span&gt;</span><br><span class="line">                                &amp;nbsp;|&amp;nbsp;</span><br><span class="line">                                &lt;span id=<span class="string">&quot;busuanzi_container_site_pv&quot;</span>&gt;&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;fa fa-user&quot;</span>&gt;&lt;/i&gt; &lt;span id=<span class="string">&quot;busuanzi_value_site_uv&quot;</span>&gt;&lt;/span&gt;&lt;/span&gt;</span><br><span class="line">                                &lt;% &#125; %&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">&lt;/footer&gt;</span><br></pre></td></tr></table></figure><h3 id="解决Wiki无法渲染数学公式的问题"><a href="#解决Wiki无法渲染数学公式的问题" class="headerlink" title="解决Wiki无法渲染数学公式的问题"></a>解决Wiki无法渲染数学公式的问题</h3><ol><li>执行下列指令</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><ol><li>找到../node_modules/kramed/lib/rules/inline.js</li></ol><p>修改如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,      第11行，将其修改为</span></span><br><span class="line">escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,</span><br><span class="line"><span class="comment">//em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,    第20行，将其修改为</span></span><br><span class="line">em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br></pre></td></tr></table></figure></p><ol><li>对需要使用MathJax公式的文章，修改文章标签,增加mathjax: true</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">mathjax: <span class="keyword">true</span></span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;如何解决wiki中图片显示不全&quot;&gt;&lt;a href=&quot;#如何解决wiki中图片显示不全&quot; class=&quot;headerlink&quot; title=&quot;如何解决wiki中图片显示不全&quot;&gt;&lt;/a&gt;如何解决wiki中图片显示不全&lt;/h3&gt;&lt;p&gt;只需要把图片放在images文件夹下
      
    
    </summary>
    
      <category term="软件配置" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    
      <category term="hexo" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/hexo/"/>
    
    
      <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
      <category term="bug" scheme="http://example.com/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow2笔记-LeNet(经典卷积网络)</title>
    <link href="http://example.com/wiki/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Tensorflow%E7%AC%94%E8%AE%B0/%E7%BB%8F%E5%85%B8%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C/"/>
    <id>http://example.com/wiki/机器学习/Tensorflow笔记/经典卷积网络/</id>
    <published>2021-11-01T02:11:58.082Z</published>
    <updated>2021-11-02T02:56:20.465Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>这里主要介绍卷积神经网络的经典网络，然后通过tensorflow进行实现（以上章的卷积神经网络实现代码为基础，进行实现）。</p><p>统计卷积网络神经网络层数一般只统计卷积计算层和全连接计算层。</p><blockquote><p>ImageNet</p></blockquote><p>ImageNet 是一个计算机视觉系统识别项目,是目前世界上图像识别最大的数据库。是美国斯坦福的计算机科学家，模拟人类的识别系统建立的。能够从图片识别物体。ImageNet是一个非常有前景的研究项目，未来用在机器人身上，就可以直接辨认物品和人了。</p><h3 id="经典卷积网络"><a href="#经典卷积网络" class="headerlink" title="经典卷积网络"></a>经典卷积网络</h3><pre class="mermaid">   graph LR    A(LeNet 1998) --> B(AlexNet 2012)    B --> C(VGGNet 2014)     C --> D(Inception Net 2014)     D --> E(ResNet 2015)</pre><h4 id="LeNet"><a href="#LeNet" class="headerlink" title="LeNet"></a>LeNet</h4><p>由Yann LeCun于1998年提出，卷积网络开篇之作。通过共享卷积核减少了网络的参数。LeNet如下所示(C5画错了是F5)</p><p><img src="/images/LeNet.PNG" alt="aaa"></p><p>LeNet提出的时候还没提出BN和Dropout层，所以LeNet网络不具有BN和Dropout层。</p><p>根据上图实现LeNet代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLeNet</span>(<span class="params">Model</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(MyLeNet, self).__init__()</span><br><span class="line">        self.c1 = Conv2D(filters=<span class="number">6</span>,kernel_size=(<span class="number">5</span>,<span class="number">5</span>),activation=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line">        self.p1 = MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>),strides=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        self.c2 = Conv2D(filters=<span class="number">16</span>,kernel_size=(<span class="number">5</span>,<span class="number">5</span>),activation=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line">        self.p2 = MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>),strides=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        self.flatten = Flatten()</span><br><span class="line">        self.f1 = Dense(<span class="number">120</span>,activation=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line">        self.f2 = Dense(<span class="number">84</span>,activation=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line">        self.f3 = Dense(<span class="number">10</span>,activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        x = self.c1(x)</span><br><span class="line">        x = self.p1(x)</span><br><span class="line">        x = self.c2(x)</span><br><span class="line">        x = self.p2(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 提取的特征作为神经网络的输入特征</span></span><br><span class="line">        x = self.flatten(x)</span><br><span class="line">        x = self.f1(x)</span><br><span class="line">        x = self.f2(x)</span><br><span class="line">        y = self.f3(x)</span><br><span class="line">        <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><h4 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h4><p>AlexNet网络诞生于2012年，是Hinton代表作之一。使用relu激活函数，提升训练速度，使用Dropout缓解过拟合。<br><img src="/images/AlexNet.PNG" alt="a2"><br>AlexNet实现代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlexNet</span>(<span class="params">Model</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(AlexNet, self).__init__()</span><br><span class="line">        <span class="comment"># 第一层</span></span><br><span class="line">        self.c1 = Conv2D(filters=<span class="number">96</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line">        self.b1 = BatchNormalization()</span><br><span class="line">        self.a1 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.p1 = MaxPool2D(pool_size=(<span class="number">3</span>,<span class="number">3</span>),strides=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#第二层</span></span><br><span class="line">        self.c2 = Conv2D(filters=<span class="number">256</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line">        self.b2 = BatchNormalization()</span><br><span class="line">        self.a2 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.p2 = MaxPool2D(pool_size=(<span class="number">3</span>,<span class="number">3</span>),strides=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#第三层</span></span><br><span class="line">        self.c3 = Conv2D(filters=<span class="number">384</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>),padding=<span class="string">&#x27;same&#x27;</span>,activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#第四层</span></span><br><span class="line">        self.c4 = Conv2D(filters=<span class="number">384</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>),padding=<span class="string">&#x27;same&#x27;</span>,activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#第五层</span></span><br><span class="line">        self.c5 = Conv2D(filters=<span class="number">256</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>),padding=<span class="string">&#x27;same&#x27;</span>,activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.p3 = MaxPool2D(pool_size=(<span class="number">3</span>,<span class="number">3</span>),strides=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#神经网络计算层</span></span><br><span class="line">        self.flatten = Flatten()</span><br><span class="line">        self.f1 = Dense(<span class="number">2048</span>,activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.d1 = Dropout(<span class="number">0.5</span>)</span><br><span class="line">        self.f2 = Dense(<span class="number">84</span>,activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.d1 = Dropout(<span class="number">0.5</span>)</span><br><span class="line">        self.f3 = Dense(<span class="number">10</span>,activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        x = self.c1(x)</span><br><span class="line">        x = self.b1(x)</span><br><span class="line">        x = self.a1(x)</span><br><span class="line">        x = self.p1(x)</span><br><span class="line"></span><br><span class="line">        x = self.c2(x)</span><br><span class="line">        x = self.b2(x)</span><br><span class="line">        x = self.a2(x)</span><br><span class="line">        x = self.p2(x)</span><br><span class="line"></span><br><span class="line">        x = self.c3(x)</span><br><span class="line"></span><br><span class="line">        x = self.c4(x)</span><br><span class="line"></span><br><span class="line">        x = self.c5(x)</span><br><span class="line">        x = self.p3(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 提取的特征作为神经网络的输入特征</span></span><br><span class="line">        x = self.flatten(x)</span><br><span class="line">        x = self.f1(x)</span><br><span class="line">        x = self.d1(x)</span><br><span class="line">        x = self.f2(x)</span><br><span class="line">        x = self.d2(x)</span><br><span class="line">        y = self.f3(x)</span><br><span class="line">        <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><h4 id="VGGNet"><a href="#VGGNet" class="headerlink" title="VGGNet"></a>VGGNet</h4><p>CGGNet诞生于2014年，当年ImageNet竞赛的亚军。使用小尺寸卷积核，在减少的参数的同时，提高了识别准确率。VGGNet网络结构框图如下所示。<br><img src="/images/VGGnet.PNG" alt="a3"></p><p>VGGNet的网络结构是：两次CBA，CBAPD，三次CBA , CBA,CBAPD。<br>实现代码如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VGGNet</span>(<span class="params">Model</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(VGGNet, self).__init__()</span><br><span class="line">        <span class="comment"># 首先重复两次CBA CBAPD</span></span><br><span class="line">        <span class="comment">#1</span></span><br><span class="line">        self.c1 = Conv2D(filters=<span class="number">64</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>),padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.b1 = BatchNormalization()</span><br><span class="line">        self.a1 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.c2 = Conv2D(filters=<span class="number">64</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.b2 = BatchNormalization()</span><br><span class="line">        self.a2 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.p1 = MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>),strides=<span class="number">2</span>,padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.d1 = Dropout(<span class="number">0.2</span>)</span><br><span class="line">        <span class="comment">#2</span></span><br><span class="line">        self.c3 = Conv2D(filters=<span class="number">128</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.b3 = BatchNormalization()</span><br><span class="line">        self.a3 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.c4 = Conv2D(filters=<span class="number">128</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.b4 = BatchNormalization()</span><br><span class="line">        self.a4 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.p2 = MaxPool2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>), strides=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.d2 = Dropout(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 再重复三次 CBA CBA CBAPD</span></span><br><span class="line">        <span class="comment"># 1</span></span><br><span class="line">        self.c5 = Conv2D(filters=<span class="number">256</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.b5 = BatchNormalization()</span><br><span class="line">        self.a5 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.c6 = Conv2D(filters=<span class="number">256</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.b6 = BatchNormalization()</span><br><span class="line">        self.a6 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.c7 = Conv2D(filters=<span class="number">256</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.b7 = BatchNormalization()</span><br><span class="line">        self.a7 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.p3 = MaxPool2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>), strides=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.d3 = Dropout(<span class="number">0.2</span>)</span><br><span class="line">        <span class="comment"># 2</span></span><br><span class="line">        self.c8 = Conv2D(filters=<span class="number">512</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.b8 = BatchNormalization()</span><br><span class="line">        self.a8 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.c9 = Conv2D(filters=<span class="number">512</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.b9 = BatchNormalization()</span><br><span class="line">        self.a9 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.c10 = Conv2D(filters=<span class="number">512</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.b10 = BatchNormalization()</span><br><span class="line">        self.a10 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.p4 = MaxPool2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>), strides=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.d4 = Dropout(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3</span></span><br><span class="line">        self.c11 = Conv2D(filters=<span class="number">512</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.b11 = BatchNormalization()</span><br><span class="line">        self.a11 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.c12 = Conv2D(filters=<span class="number">512</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.b12 = BatchNormalization()</span><br><span class="line">        self.a12 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.c13 = Conv2D(filters=<span class="number">512</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.b13 = BatchNormalization()</span><br><span class="line">        self.a13 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.p5 = MaxPool2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>), strides=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">        self.d5 = Dropout(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 三个全连接层</span></span><br><span class="line">        self.flatten = Flatten()</span><br><span class="line">        self.f1 = Dense(<span class="number">512</span>,activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.d6 = Dropout(<span class="number">0.2</span>)</span><br><span class="line">        self.f2 = Dense(<span class="number">512</span>,activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.d6 = Dropout(<span class="number">0.2</span>)</span><br><span class="line">        self.f3 = Dense(<span class="number">10</span>,activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        <span class="comment"># 两次CBA CBAPD</span></span><br><span class="line">        <span class="comment">#1</span></span><br><span class="line">        x = self.c1(x)</span><br><span class="line">        x = self.b1(x)</span><br><span class="line">        x = self.a1(x)</span><br><span class="line"></span><br><span class="line">        x = self.c2(x)</span><br><span class="line">        x = self.b2(x)</span><br><span class="line">        x = self.a2(x)</span><br><span class="line">        x = self.p1(x)</span><br><span class="line">        x = self.d1(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#2</span></span><br><span class="line">        x = self.c3(x)</span><br><span class="line">        x = self.b3(x)</span><br><span class="line">        x = self.a3(x)</span><br><span class="line"></span><br><span class="line">        x = self.c4(x)</span><br><span class="line">        x = self.b4(x)</span><br><span class="line">        x = self.a4(x)</span><br><span class="line">        x = self.p2(x)</span><br><span class="line">        x = self.d2(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#三次 CBA CBA CBAPD</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1</span></span><br><span class="line">        x = self.c5(x)</span><br><span class="line">        x = self.b5(x)</span><br><span class="line">        x = self.a5(x)</span><br><span class="line"></span><br><span class="line">        x = self.c6(x)</span><br><span class="line">        x = self.b6(x)</span><br><span class="line">        x = self.a6(x)</span><br><span class="line"></span><br><span class="line">        x = self.c7(x)</span><br><span class="line">        x = self.b7(x)</span><br><span class="line">        x = self.a7(x)</span><br><span class="line">        x = self.p3(x)</span><br><span class="line">        x = self.d3(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2</span></span><br><span class="line">        x = self.c8(x)</span><br><span class="line">        x = self.b8(x)</span><br><span class="line">        x = self.a8(x)</span><br><span class="line"></span><br><span class="line">        x = self.c9(x)</span><br><span class="line">        x = self.b9(x)</span><br><span class="line">        x = self.a9(x)</span><br><span class="line"></span><br><span class="line">        x = self.c10(x)</span><br><span class="line">        x = self.b10(x)</span><br><span class="line">        x = self.a10(x)</span><br><span class="line">        x = self.p4(x)</span><br><span class="line">        x = self.d4(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">        x = self.c11(x)</span><br><span class="line">        x = self.b11(x)</span><br><span class="line">        x = self.a11(x)</span><br><span class="line"></span><br><span class="line">        x = self.c12(x)</span><br><span class="line">        x = self.b12(x)</span><br><span class="line">        x = self.a12(x)</span><br><span class="line"></span><br><span class="line">        x = self.c13(x)</span><br><span class="line">        x = self.b13(x)</span><br><span class="line">        x = self.a13(x)</span><br><span class="line">        x = self.p5(x)</span><br><span class="line">        x = self.d5(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 提取的特征作为神经网络的输入特征</span></span><br><span class="line">        x = self.flatten(x)</span><br><span class="line">        x = self.f1(x)</span><br><span class="line">        x = self.d5(x)</span><br><span class="line">        x = self.f2(x)</span><br><span class="line">        x = self.d6(x)</span><br><span class="line">        y = self.f3(x)</span><br><span class="line">        <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure></p><h4 id="Inception-Net"><a href="#Inception-Net" class="headerlink" title="Inception Net"></a>Inception Net</h4><p>InceptionNet诞生于2014年。当年ImageNet冠军。Inception引入了Inception结构快。<br>同一层网络使用不同尺寸的卷积核，提升了模型感知力，使用了批标准化，缓解了梯度消失。</p><blockquote><p>Inception结构快如图所示</p></blockquote><p><img src="/images/inter.PNG" alt="a14"></p><p>从图中可以看出，Inception包含四个卷积过程，分成四个不同的卷积核进行卷积操作。</p><blockquote><ol><li>1×1的卷积核</li><li>1×1的卷积核+3×3的卷积核</li><li>1×1的卷积核+5×5的卷积核</li><li>3×3的最大池+1×1的卷积核</li><li>最后将四个部分的输出结果，按照深度方向堆叠在一起，作为一个Inception结构快输出。</li></ol></blockquote><h4 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h4><p>ResNet（何凯明）于2015年提出，是当时的ImageNet竞赛冠军。ResNet提出了层间残差跳连，引入了前方信息，缓解梯度消失，使神经网络层数增加称为可能。</p><blockquote><p>单纯堆叠神经网络层数，会使神经网络模型退化，以致于后面的特征丢失了前边特征的原本模样。</p></blockquote><p>ResNet块的结构如下所示：<br><img src="/images/ResNet块.PNG" alt="ar"></p><p>ResNet的输出值包括两部分组成，一部分是由卷积过程提取出的特征输出F(x)，另一部分是直接由输入X得到的恒等映射X组成。将F(x)和x的对应元素相加得到输出特征H(x)。这样可以缓解神经网络堆叠导致的退化。使得神经网络层数增加称为可能。</p><p>对于X到跳过卷积层直接到输出特征有两种处理方式。</p><p><img src="/images/两种ResNet块.PNG" alt="ar1"></p><blockquote><ol><li>不做任何处理<br>H(x) = F(x) + x<br>由于不做任何处理，所以维度没有改变。</li><li>通过函数W(x)进行处理，其中W是1×1的卷积操作，用于调整X的维度。<br>H(x) = F(x) + W(x)<br>其中通过卷积步长可以改变输出特征图尺寸，通过卷积核的个数可以改变特征图的深度（类似Inception结构，多个卷积核，该变深度）。</li></ol></blockquote><p>ResNet网络结构如下所示：</p><p><img src="/images/ResNet.PNG" alt="ar1"></p><p>实现代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResentBlock</span>(<span class="params">Model</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,filters,strides=<span class="number">1</span>,residual_path=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(ResentBlock, self).__init__()</span><br><span class="line">        self.filters = filters</span><br><span class="line">        self.strides = strides</span><br><span class="line">        self.residual_path = residual_path</span><br><span class="line"></span><br><span class="line">        self.c1 = Conv2D(filters,(<span class="number">3</span>,<span class="number">3</span>),strides=strides,padding=<span class="string">&#x27;same&#x27;</span>,use_bias=<span class="literal">False</span>)</span><br><span class="line">        self.b1 = BatchNormalization()</span><br><span class="line">        self.a1 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.c2 = Conv2D(filters,(<span class="number">3</span>,<span class="number">3</span>),strides=<span class="number">1</span>,padding=<span class="string">&#x27;same&#x27;</span>,use_bias=<span class="literal">False</span>)</span><br><span class="line">        self.b2 = BatchNormalization()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#fesiders_path 为True时候，对输入进行采样，都用1×1的卷积核做卷积操作，保证x能和F(x)维度相同，顺利相加</span></span><br><span class="line">        <span class="keyword">if</span> residual_path:</span><br><span class="line">            self.down_c1 = Conv2D(filters,(<span class="number">1</span>,<span class="number">1</span>),strides=strides,padding=<span class="string">&#x27;same&#x27;</span>,use_bias=<span class="literal">False</span>)</span><br><span class="line">            self.down_b1 = BatchNormalization()</span><br><span class="line">        self.a2 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self,inputs</span>):</span></span><br><span class="line">        residual = inputs <span class="comment"># residual等于输入本身</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#将输入通过卷积层，BN层，激活层计算F(x)</span></span><br><span class="line">        x = self.c1(inputs)</span><br><span class="line">        x = self.b1(x)</span><br><span class="line">        x = self.a1(x)</span><br><span class="line"></span><br><span class="line">        x = self.c2(x)</span><br><span class="line">        y = self.b2(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.residual_path:</span><br><span class="line">            residual = self.down_c1(inputs)</span><br><span class="line">            residual = self.down_b1(residual)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 最后输出是两部分的和，即F(x)+x或F(x)+W(x),然后再过激活函数。</span></span><br><span class="line">        out = self.a2(y + residual)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由一层卷积网络+八个ResNet块组成</span></span><br><span class="line"><span class="comment"># 神经网络由一个全连接层构成</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResNet</span>(<span class="params">Model</span>):</span></span><br><span class="line">    <span class="comment"># block_list表示每个block有几个卷积层</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,block_list,initial_filters=<span class="number">64</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(ResNet, self).__init__()</span><br><span class="line">        self.num_blocks = <span class="built_in">len</span>(block_list)</span><br><span class="line">        self.block_list = block_list</span><br><span class="line">        self.out_filters = initial_filters</span><br><span class="line">        <span class="comment"># 对应图中第一个卷几层</span></span><br><span class="line">        self.c1 = Conv2D(self.out_filters,(<span class="number">3</span>,<span class="number">3</span>),strides=<span class="number">1</span>,padding=<span class="string">&#x27;same&#x27;</span>,use_bias=<span class="literal">False</span>,kernel_initializer=<span class="string">&#x27;he_normal&#x27;</span>)</span><br><span class="line">        self.b1 = BatchNormalization()</span><br><span class="line">        self.a1 = Activation(<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.blocks = tf.keras.models.Sequential()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对应图中的八个ResNet块</span></span><br><span class="line">        <span class="comment">#构建ResNet网络结构 4*2 = 8</span></span><br><span class="line">        <span class="keyword">for</span> block_id <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(block_list)):<span class="comment">#第几个resnet block</span></span><br><span class="line">            <span class="keyword">for</span> layer_id <span class="keyword">in</span> <span class="built_in">range</span>(block_list[block_id]):<span class="comment"># 第几个卷层</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> block_id != <span class="number">0</span> <span class="keyword">and</span> layer_id == <span class="number">0</span> : <span class="comment">#对除第一个block以外的每个Block的输入进行采样</span></span><br><span class="line">                    block = ResentBlock(self.out_filters,strides=<span class="number">2</span>,residual_path=<span class="literal">True</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    block = ResentBlock(self.out_filters,residual_path=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">                self.blocks.add(block)  <span class="comment"># 将构建好的blcok加入到renset</span></span><br><span class="line">            self.out_filters *=<span class="number">2</span>  <span class="comment">#下一个block卷积核数是上一个block的两倍</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 平均池</span></span><br><span class="line">        self.p1 = tf.keras.layers.GlobalAveragePooling2D()</span><br><span class="line">        <span class="comment"># 全连接层</span></span><br><span class="line">        self.f1 = tf.keras.layers.Dense(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self,inputs</span>):</span></span><br><span class="line">        x = self.c1(inputs)</span><br><span class="line">        x = self.b1(x)</span><br><span class="line">        x = self.a1(x)</span><br><span class="line">        x = self.blocks(x)</span><br><span class="line">        x = self.p1(x)</span><br><span class="line">        y = self.f1(x)</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">model = ResNet([<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>])</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>LeNet<br>通过共享卷积核，减少网络参数</li><li>AlexNet<br> 通过使用relu激活函数，提升训练速度。<br> 使用Dropout缓解过拟合。</li><li>VGGNet<br> 小尺寸卷积核减少参数，网络结构规整，适合并行加速。</li><li>InceptionNet<br> 一层内使用不同尺寸卷积核，提升感知力。使用批标准化，缓解梯度消失。</li><li>ResNet<br> 层间残差跳连，引入前方信息，缓解模型退化，使神经网络层数加深成为可能。</li></ol><blockquote><p>训练优化</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;一些训练方法和超参数的设定对模型训练结果的影响是相当显著的，如数据增强（对训练集图像进行旋转、偏移、翻转等多种操作，目的是增强训练集的随机性）、学习率策略（一般的策略是在训练过程中逐步减小学习率）、Batch size 的大小设置（每个 batch 包含训练集图片的数量）、模型参数初始化的方式等等。。所以，在神经网络的训练中，除了选择合适的模型以外，如何更好地训练一个模型也是一个非常值得探究的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;这里主要介绍卷积神经网络的经典网络，然后通过tensorflow进行实现（以上章的卷积神经网络实现代码为基础，进行实现）。&lt;/p&gt;
&lt;p&gt;统
      
    
    </summary>
    
      <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="TensorFlow2" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/TensorFlow2/"/>
    
    
      <category term="TensorFlow2" scheme="http://example.com/tags/TensorFlow2/"/>
    
      <category term="CNN" scheme="http://example.com/tags/CNN/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow2笔记-NN(全连接)</title>
    <link href="http://example.com/wiki/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Tensorflow%E7%AC%94%E8%AE%B0/NN/"/>
    <id>http://example.com/wiki/机器学习/Tensorflow笔记/NN/</id>
    <published>2021-10-29T06:05:38.694Z</published>
    <updated>2021-10-29T06:12:34.236Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>全连接NN：每个神经元与前后相邻层的每一个神经元都有连接关系，输入是特征，输出为预测的结果。<br>（可以类比于满射，前后层神经元之间都有联系）</p><blockquote><p>参数个数</p></blockquote><p>参数个数=$\displaystyle \sum^{}_{各层}{前层*后层(w)+后层(b)}$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;全连接NN：每个神经元与前后相邻层的每一个神经元都有连接关系，输入是特征，输出为预测的结果。&lt;br&gt;（可以类比于满射，前后层神经元之间都有联
      
    
    </summary>
    
      <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="TensorFlow2" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/TensorFlow2/"/>
    
    
      <category term="TensorFlow2" scheme="http://example.com/tags/TensorFlow2/"/>
    
      <category term="CNN" scheme="http://example.com/tags/CNN/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow2笔记-第四讲(网络八股扩展)</title>
    <link href="http://example.com/wiki/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Tensorflow%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1%E6%89%A9%E5%B1%95/"/>
    <id>http://example.com/wiki/机器学习/Tensorflow笔记/第四讲-网络八股扩展/</id>
    <published>2021-10-29T06:00:43.670Z</published>
    <updated>2021-10-29T06:01:12.943Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="TensorFlow2" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/TensorFlow2/"/>
    
    
      <category term="TensorFlow2" scheme="http://example.com/tags/TensorFlow2/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow2笔记-CNN(卷积神经网络)</title>
    <link href="http://example.com/wiki/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Tensorflow%E7%AC%94%E8%AE%B0/CNN/"/>
    <id>http://example.com/wiki/机器学习/Tensorflow笔记/CNN/</id>
    <published>2021-10-29T04:44:21.509Z</published>
    <updated>2021-11-01T08:56:31.980Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/多通道计算.PNG" alt="aaa"></p><h3 id="问题介绍"><a href="#问题介绍" class="headerlink" title="问题介绍"></a>问题介绍</h3><p>如果仅仅依靠全连接神经网络来训练模型，则在实际应用中，输入特征会非常多，参数十分复杂，让训练变得非常庞大。所以在实际应用时，会对原始图像进行特征提取再把提取到的特征送给全连接网络。流程如下所示：</p><pre class="mermaid">    graph LR        原始图片 --> 若干层特征提取        若干层特征提取 --> 全连接网络</pre><p>卷积计算是一种提取图片特征的有效方法。</p><h3 id="卷积计算过程"><a href="#卷积计算过程" class="headerlink" title="卷积计算过程"></a>卷积计算过程</h3><blockquote><blockquote><p>单通道卷积计算<br><img src="/images/卷积计算过程.PNG" alt="aaa"></p></blockquote><p>从上图可以看出,卷积神经网络计算的过程实际上就是将大的数据，根据区域提取其相关特征，减少了特征数目。从 5x5x1 的参数，经过 3x3x1的卷积核卷积计算后，转化为3x3x1的参数网络。<br>&gt;</p><blockquote><p>多通道卷积计算<br><img src="/images/多通道计算.PNG" alt="bb"><br>从图中可以看出，对于输入特征是多通道的，每个通道都通过卷积层计算相应的调整值。从图片看从5×5×3经过3×3×3的卷积核计算，对每个通道的重合区域，经过对应通道 的卷积核计算的结果作为输出调整图中的一个像素点。</p></blockquote><p>总结<br>对于卷积神经网络的计算过程，就是从左到右，从上到下，根据卷积核重叠的区域，依次计算结果，作为输出特征图的一个像素点。</p></blockquote><h3 id="用CNN实现离散数据的分类-以图像分类为例"><a href="#用CNN实现离散数据的分类-以图像分类为例" class="headerlink" title="用CNN实现离散数据的分类(以图像分类为例)"></a>用CNN实现离散数据的分类(以图像分类为例)</h3><h4 id="1-感受野-Receptive-Field"><a href="#1-感受野-Receptive-Field" class="headerlink" title="1. 感受野(Receptive Field)"></a>1. 感受野(Receptive Field)</h4><p>感受野：卷积神经网络各输出特征图中的每个像素点，在原始输入图片上映射区域的大小。</p><p>这里可以参考一下卷积神经网络的计算过程中，5×5×1 经过 3×3×1 卷积后得到一张3×3的特征图，那么最终3×3特征图中的一个像素点所对应在5×5×1输入特征图的区域大小，（大小只取正方形区域边的大小），称之为感受野，从图上可以看出对应的感受野为3。</p><blockquote><p>如果输出特征图的感受野都是一样的,但是选取的卷积核不一样（如刚刚的5×5×1的输入特征可以经过两层3×3×1的卷积核得到1的输出特征图，同样可以经过一层5×5×1的卷积核得到1的输出特征图，二者的感受野都是5）。</p></blockquote><p>这里就需要考虑选取不同的卷积核所带来的计算代价，计算越少越好。<br><img src="/images/选取卷积核.PNG" alt="ccc"></p><blockquote><p>对计算量的计算步骤，以两层3×3×1为例，对于输入特征图经过第一层卷积核的计算量-&gt;首先每次计算共有9次乘法运算，卷积核总共扫描的区域数很容易得出为(x-3+1)(x-3+1),总的计算数为9×(x-2)×(x-2)。同理经过第一层卷积核的输出特征图经过第二个卷积核的计算量为9×(x-2-3+1)×(x-2-3+1)。将两个卷积核计算量相加得到总的计算量：18$x^2$-108x+180</p></blockquote><h4 id="2-全零填充-Padding"><a href="#2-全零填充-Padding" class="headerlink" title="2. 全零填充(Padding)"></a>2. 全零填充(Padding)</h4><p>为了保证输入特征图的尺寸不变，通过0进行填充，在输入特征图周围填充0，如原来的5×5×1经过3×3×1后仍然还是5×5×1。</p><blockquote><p>填充公式(卷积输出特征图维度计算公式)</p></blockquote><script type="math/tex; mode=display">padding=\left\{     \begin{aligned}SAME(全0填充)\frac{入长}{步长} & ,(向上取整)    \\    VALID(不全0填充) \frac{入长-核长+1}{步长}&,(向上取整)    \end{aligned}    \right.</script><p>TF描述全0填充，用参数padding=’SAME’或padding=’VALID’表示。<br><img src="/images/零填充.PNG" alt="ccc"></p><h4 id="3-Tensorflow2描述卷积层"><a href="#3-Tensorflow2描述卷积层" class="headerlink" title="3. Tensorflow2描述卷积层"></a>3. Tensorflow2描述卷积层</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### TF描述卷积层的代码</span></span><br><span class="line"><span class="comment"># tf.keras.layers.Conv2D(</span></span><br><span class="line"><span class="comment">#     filters=卷积核个数,</span></span><br><span class="line"><span class="comment">#     kernel_size=卷积核尺寸,#正方形写核长整数,或（核高h,核宽w）</span></span><br><span class="line"><span class="comment">#     strides = 滑动步长,#横纵向相同写步长整数，或（纵向步长h，横向步长w）,默认1</span></span><br><span class="line"><span class="comment">#     padding = &quot;same&quot; or &quot;valid&quot;,#使用全0填充是same，不使用是valid(默认)</span></span><br><span class="line"><span class="comment">#     activation=&quot;relu&quot;or&quot;sigmoid&quot;or&quot;tanh&quot;or&quot;softmax&quot;等,#如有BN此处不写</span></span><br><span class="line"><span class="comment">#     input_shape=(高，宽，通道数) #输入特征图维度，可省略</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line">model = tf.keras.models.Sequential([</span><br><span class="line">    Conv2D(<span class="number">6</span>,<span class="number">5</span>,padding=<span class="string">&#x27;valid&#x27;</span>,activation=<span class="string">&#x27;sigmoid&#x27;</span>),</span><br><span class="line">    MaxPool2D(<span class="number">2</span>,<span class="number">2</span>),</span><br><span class="line">    Conv2D(<span class="number">6</span>,(<span class="number">5</span>,<span class="number">5</span>),padding=<span class="string">&#x27;valid&#x27;</span>,activation=<span class="string">&#x27;sigmoid&#x27;</span>),</span><br><span class="line">    MaxPool2D(<span class="number">2</span>,(<span class="number">2</span>,<span class="number">2</span>)),</span><br><span class="line">    Conv2D(filters=<span class="number">6</span>,kernel_size=(<span class="number">5</span>,<span class="number">5</span>),padding=<span class="string">&#x27;valid&#x27;</span>,activation=<span class="string">&#x27;sigmoid&#x27;</span>),</span><br><span class="line">    MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>),strides=<span class="number">2</span>),</span><br><span class="line">    Flatten(),</span><br><span class="line">    Dense(<span class="number">10</span>,activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h4 id="4-批标准化-Batch-Normalization-BN"><a href="#4-批标准化-Batch-Normalization-BN" class="headerlink" title="4. 批标准化(Batch Normalization , BN)"></a>4. 批标准化(Batch Normalization , BN)</h4><p>神经网络对0附件的数据更敏感。</p><p>标准化：使数据符合0均值，1为标准差的分布<br>批标准化：对一小批数据（batch），做标准化处理。<br>批标准化，第K个卷积核的输出特征图(feature map)中第i个像素点。</p><p><img src="/images/拟标准化.PNG" alt="a4"></p><blockquote><p>$H_{i}^{‘k}$ = $\frac{H_{i}^{k}-u_{batch}^{k}} {\sigma_{batch}^{k}}$<br>$H_{i}^{k}$：批标准化前，第K个卷积核，输出特征图中第i个像素点。<br>$u_{batch}^{k}$：批量化前，第k个卷积核，batch张输出特征图中所有像素点平均值。</p></blockquote><p>$u_{batch}^{k}$ = $\frac{1} {m} \displaystyle \sum^{m}_{i=1} H_{i}^{k}$</p><blockquote><p>$\sigma_{batch}^{k}$：批标准化前，第k个卷积核，batch张输出特征图中所有像素点标准差。</p></blockquote><p>$\sigma_{batch}^{k}$ = $\sqrt{\delta+\frac{1}{m}\displaystyle \sum^m_{i = 1}(H_i^k-u_{batch}^k)^2}$</p><p>通过BN操作，将数据标准化到0均值。如下图所示：<br><img src="/images/拟标准-1.PNG" alt="a41"></p><p>通过标准化使得输入特征的微小变化也能使得激活函数有明显的变化，提升激活函数对输入数据的区分力。</p><p>从图中可以看出，经过标准化的Sigmoid函数，特征数据$H_i^{‘k}$集中在0附近，但是从图中可以看出，Sigmoid函数在0区域附近的曲线接近线性函数，所以这样会导致激活函数的非线性特性丧失。为了解决这个问题，需要为每个卷积核引入可训练参数$\gamma$（缩放因子）和$\beta$（偏移因子）,用于调整归一化的力度,优化特征数据分布的宽窄和偏移量，保证了网络的非线性表达力。<br>调整后的数据$x_i^k$ = $\gamma_{k}H_{i}^{‘k}+\beta_k$。</p><p>从上面可以看出，BN层用于对数据的标准化处理，可以缓解梯度消失，所以BN层位于卷积层之后，激活层之前。</p><blockquote><p>TensorFlow描述批标准化的代码如下</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    TF通过tf.keras.layers.BatchhNormalization()描述BN层</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">model = tf.keras.models.Sequential([</span><br><span class="line">   Conv2D(padding=<span class="string">&#x27;same&#x27;</span>,kernel_size=(<span class="number">5</span>,<span class="number">5</span>),filters=<span class="number">6</span>),</span><br><span class="line">    BatchNormalization(),<span class="comment">#BN层</span></span><br><span class="line">    Activation(<span class="string">&#x27;relu&#x27;</span>),<span class="comment">#激活层</span></span><br><span class="line">    MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>),strides=<span class="number">2</span>,padding=<span class="string">&#x27;same&#x27;</span>),</span><br><span class="line">    Dropout(<span class="number">0.2</span>),<span class="comment">#droupt层</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure><h3 id="5-池化-Pooling"><a href="#5-池化-Pooling" class="headerlink" title="5. 池化(Pooling)"></a>5. 池化(Pooling)</h3><p>池化用于减少特征数据量。池化包含最大值池化和均值池化。最大值池化可以提取图片纹理，均值池化可以保留背景特征。</p><p>两种池化的计算如下图所示。<br><img src="/images/Pooling.PNG" alt="a6"><br>用池大小为2×2，步长为2的池进行处理。<br>从图中可以看出二者的计算过程。</p><blockquote><p>最大值池化</p></blockquote><p>选择被池包含区域内最大的特征值作为输出结果。</p><blockquote><p>均值池化</p></blockquote><p>选择被池包含区域内特征值的平均值作为输出结果。</p><blockquote><p>TensorFlow描述池化的代码如下</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        tf.keras.MaxPool2D(</span></span><br><span class="line"><span class="string">            pool_size=池化核尺寸,#正方形写核长整数，或用元组给出核的高和宽(核高h,核宽w)</span></span><br><span class="line"><span class="string">            strides=池化步长,#步长整数，或(纵向步长h，横向步长w),默认为pool_size</span></span><br><span class="line"><span class="string">            padding=&#x27;valid&#x27;or&#x27;same&#x27;#q全0填充是same,否则是&#x27;valid</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">        tf.keras.AveragePooling2D(</span></span><br><span class="line"><span class="string">        pool_size=池化核尺寸,#正方形写核长整数，或用元组给出核的高和宽(核高h,核宽w)</span></span><br><span class="line"><span class="string">            strides=池化步长,#步长整数，或(纵向步长h，横向步长w),默认为pool_size</span></span><br><span class="line"><span class="string">            padding=&#x27;valid&#x27;or&#x27;same&#x27;#q全0填充是same,否则是&#x27;valid</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    model = tf.keras.models.Sequential([</span><br><span class="line">        Conv2D(padding=<span class="string">&#x27;same&#x27;</span>,kernel_size=(<span class="number">5</span>,<span class="number">5</span>),filters=<span class="number">6</span>),<span class="comment">#卷积层</span></span><br><span class="line">        BatchNormalization(),<span class="comment">#BN层</span></span><br><span class="line">        Activation(<span class="string">&#x27;relu&#x27;</span>),<span class="comment">#激活层</span></span><br><span class="line">        MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>),strides=<span class="number">2</span>,padding=<span class="string">&#x27;same&#x27;</span>),<span class="comment">#池化层</span></span><br><span class="line">        Dropout(<span class="number">0.2</span>),<span class="comment">#droupt层</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure><h3 id="6-舍弃（Dropout）"><a href="#6-舍弃（Dropout）" class="headerlink" title="6. 舍弃（Dropout）"></a>6. 舍弃（Dropout）</h3><p>舍弃是为了缓解神经网络过拟合。舍弃也就是在神经网络训练的过程中，将一部分神经元按照一定概率从神经网络中暂时舍弃。神经网络使用时，被舍弃的神经元恢复链接。（也就是说在神经网络训练的过程中，一些神经元会被暂时踢出训练，等最后在加入到神经网络中。）。舍弃过程如图所示：<br><img src="/images/Dropout.PNG" alt="a7"></p><p>在训练的过程中，将一部分神经元暂时舍弃(类似于神经元死亡，也就是神经元的参数不再更新)。</p><blockquote><p>TensorFlow描述舍弃（Dropout）</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    tf描述舍弃：tf.keras.layers.Dropout(舍弃的概率)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">    model = tf.keras.models.Sequential([</span><br><span class="line">        Conv2D(padding=<span class="string">&#x27;same&#x27;</span>,kernel_size=(<span class="number">5</span>,<span class="number">5</span>),filters=<span class="number">6</span>),<span class="comment">#卷积层</span></span><br><span class="line">        BatchNormalization(),<span class="comment">#BN层</span></span><br><span class="line">        Activation(<span class="string">&#x27;relu&#x27;</span>),<span class="comment">#激活层</span></span><br><span class="line">        MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>),strides=<span class="number">2</span>,padding=<span class="string">&#x27;same&#x27;</span>),<span class="comment">#池化层</span></span><br><span class="line">        Dropout(<span class="number">0.2</span>),<span class="comment">#droupt层，随机舍弃掉20%的神经元</span></span><br><span class="line">    ])</span><br></pre></td></tr></table></figure><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><p>从上面介绍可以看出，卷积的过程就是对特征值的特征进行提取，来减少特征值的数量（卷积，池化）。通过用一个输出像素点来反映一块区域内像素点的特征。通过这样的方式有效的减少了特征值的数量。</p><blockquote><p>卷积神经网络的主要组成模块,卷积层，BN层，激活层，池化层,舍弃层(dropout层)，全连接层（Fully Connected）。<br>卷积层，BN层，激活层，池化层这四层用于对输入特征进行特征提取。</p></blockquote><pre class="mermaid">    graph LR        A("卷积&#40;Convolutional&#41;") --> B("批标准化&#40;BN&#41;")         B --> C("激活&#40;Activation&#41;")         C --> D("池化&#40;Pooling&#41;")         D --> F("舍弃层&#40;Dropout&#41;")        F --> E("全连接&#40;FC&#41;")</pre><blockquote><p>卷积是什么？</p></blockquote><p>卷积就是<font color=red>特征提取器</font>,就是CBAPD(D表示的是舍弃，Dropout)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/多通道计算.PNG&quot; alt=&quot;aaa&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;问题介绍&quot;&gt;&lt;a href=&quot;#问题介绍&quot; class=&quot;headerlink&quot; title=&quot;问题介绍&quot;&gt;&lt;/a&gt;问题介绍&lt;/h3&gt;&lt;p&gt;如果仅仅依靠全连接神经网络来训
      
    
    </summary>
    
      <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="TensorFlow2" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/TensorFlow2/"/>
    
    
      <category term="TensorFlow2" scheme="http://example.com/tags/TensorFlow2/"/>
    
      <category term="CNN" scheme="http://example.com/tags/CNN/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法</title>
    <link href="http://example.com/wiki/%E7%AE%97%E6%B3%95/Leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/KMP/"/>
    <id>http://example.com/wiki/算法/Leetcode/字符串/KMP/</id>
    <published>2021-10-28T09:15:08.580Z</published>
    <updated>2021-11-15T00:55:53.024Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#1-问题描述">1. 问题描述</a></li><li><a href="#2-解题思路">2. 解题思路</a></li></ul><h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h3><p>今天的问题很简单，就是给定两个字符串text和pattern，让你找出在text中是否存在一个序列等于pattern,如果存在就返回true,如果不存在就返回false 。</p><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h3><p>从题目描述上来看，很容易看出这题目是关于字符串匹配的问题，也就是从一段文本中，找出某个模式的全部出现位置的问题。</p><blockquote><ol><li>朴素的字符串匹配算法</li></ol></blockquote><p>用一个循环找出所有有效位移，对text每个字符进行检测，然后匹配pattern，如果匹配成功就返回下标。如果失败，就移动text下一个位置，重复操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len_h , len_s , i , j = <span class="number">0</span> ;</span><br><span class="line">        len_s = needle.length() ;</span><br><span class="line">        <span class="keyword">if</span>(len_s == <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        len_h = haystack.length() ;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt;= len_h - len_s ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(haystack.charAt(i)==needle.charAt(j))&#123;</span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;len_s;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(haystack.charAt(i+j)!=needle.charAt(j))</span><br><span class="line">                        <span class="keyword">break</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=len_s)</span><br><span class="line">                    <span class="keyword">return</span> i ;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    j = <span class="number">0</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><blockquote><ol><li>KMP算法</li></ol></blockquote><p>KMP算法的巧妙之处就是利用已经匹配字符串来确定下一次匹配开始的位置。这就是和朴素字符串匹配算法的区别，朴素字符串匹配算法每次匹配完毕之后，只是从下一个字符开始进行匹配，那么就浪费了已经匹配过字符串的有效信息，所以造成时间上的浪费。如何确定下一字符开始匹配的位置呢？假设已经匹配模式串pattern的位置为j,也就是从text的位置i开始 text[i…..,i+j] = pattern[0……,0+j]</p><blockquote><p>KMP算法的前缀函数(next)</p></blockquote><p>前缀函数 $\pi$(i)(0 $\leq$ i &lt; m)表示s 的子串 s[0:i] 的最长的相等的真前缀与真后缀的长度。特别地，如果不存在符合条件的前后缀，那么 $\pi$(i) = 0。其中真前缀与真后缀的定义为不等于自身的的前缀与后缀。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求解字符前缀函数</span></span><br><span class="line"><span class="comment"> * /</span></span><br><span class="line"><span class="comment"> public int[] getNext(String s)&#123;</span></span><br><span class="line"><span class="comment">        int len , k ,q ;</span></span><br><span class="line"><span class="comment">        len = s.length() ;</span></span><br><span class="line"><span class="comment">        int[] next = new int[len];</span></span><br><span class="line"><span class="comment">        next[0] = 0 ;</span></span><br><span class="line"><span class="comment">        for(q = 1,k=0 ; q&lt; len ; q++)&#123;  //长字符串的前缀建立在短字符前缀的匹配上。</span></span><br><span class="line"><span class="comment">            while (k&gt;0&amp;&amp;s.charAt(k)!=s.charAt(q))&#123;</span></span><br><span class="line"><span class="comment">                    k = next[k-1] ;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if(s.charAt(q) == s.charAt(k))&#123;</span></span><br><span class="line"><span class="comment">                k = k+1 ;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            next[q] = k ;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return next ;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过前缀函数进行字符串的匹配</span></span><br><span class="line"><span class="comment"> * /</span></span><br><span class="line"><span class="comment">    public int Matcher(String t , String p )&#123;</span></span><br><span class="line"><span class="comment">        int   q , i;</span></span><br><span class="line"><span class="comment">        int n = t.length(), m = p.length();</span></span><br><span class="line"><span class="comment">        if (m == 0) &#123;</span></span><br><span class="line"><span class="comment">            return 0;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        int[] next = getNext(p) ;</span></span><br><span class="line"><span class="comment">        q = 0 ;</span></span><br><span class="line"><span class="comment">        for(i = 0 ,q=0; i &lt; n ;i++)&#123;</span></span><br><span class="line"><span class="comment">            while(q&gt;0&amp;&amp;p.charAt(q)!=t.charAt(i))&#123;  //如果不匹配则移动到下一个位置</span></span><br><span class="line"><span class="comment">                q = next[q-1] ;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if(p.charAt(q) == t.charAt(i))&#123;</span></span><br><span class="line"><span class="comment">                q = q+1 ;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if(q == m)&#123;</span></span><br><span class="line"><span class="comment">                return i-m+1 ;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return -1 ;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure><blockquote><p>个人总结</p></blockquote><p>KMP算法主要在于计算前缀函数next，前缀函数的计算依据最长相同前后缀长度为依据来计算。通过next来获取到移动的位置。</p><p>对于next前缀函数的计算过程，patten(q) 和 patten(k) 不等说明了，在前一个（q-1）的最长前后缀匹配的位置，增加一个text(q)后，patten[0-&gt;next(q-1),next(q-1)+1] 和patten[(q-1)-next(q-1)-&gt;q]并不相等(因为新增的最后一个字符和前一个patten(q-1)字符串的最长前后缀并不相等)，所以需要进一步比较next[next(q-1)] 是否满足，patten[0-&gt;k+1] == patten[k-q,q] , 如果相等，则另k+1 , next[q] = k 。<br><img src="/images/时间复杂度.PNG" alt="a6"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-问题描述&quot;&gt;1. 问题描述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-解题思路&quot;&gt;2. 解题思路&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-问题描述&quot;&gt;&lt;a href=&quot;#1-问题描述&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="经典算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>48.旋转数组</title>
    <link href="http://example.com/wiki/%E7%AE%97%E6%B3%95/Leetcode/%E9%93%BE%E8%A1%A8/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>http://example.com/wiki/算法/Leetcode/链表/19.删除链表的倒数第N个结点/</id>
    <published>2021-10-28T08:36:32.058Z</published>
    <updated>2021-10-28T08:48:47.469Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。(进阶：你能尝试使用一趟扫描实现吗？)</p><blockquote><p>示例 1：</p></blockquote><pre><code>输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5]</code></pre><blockquote><p>示例 2：</p></blockquote><pre><code>输入：head = [1], n = 1输出：[]</code></pre><blockquote><p>示例 3：</p></blockquote><pre><code>输入：head = [1,2], n = 1输出：[1]</code></pre><h3 id="解法思路"><a href="#解法思路" class="headerlink" title="解法思路"></a>解法思路</h3><p>从题目分析，我们需要删除链表的倒数第N个结点，那么我们就必须知道哪个结点是倒数第N个结点。确定一个结点在列表中的位置大概有如下几种方法。</p><blockquote><p>方法一</p></blockquote><p>先确定整个列表的长度，然后就能够确定结点所在的位置(可以通过堆栈或者数组存放数据元素，通过数组有利于操作)。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;ListNode&gt; listNodes = <span class="keyword">new</span> ArrayList&lt;&gt;()  ;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span> ;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            len++ ;</span><br><span class="line">            listNodes.add(head) ;</span><br><span class="line">            head = head.next ;</span><br><span class="line">        &#125;</span><br><span class="line">        listNodes.add(head) ; </span><br><span class="line">        <span class="keyword">if</span>(len-n-<span class="number">1</span>&lt;<span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> listNodes.get(<span class="number">1</span>) ;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            listNodes.get(len-n-<span class="number">1</span>).next = listNodes.get(len-n).next ;</span><br><span class="line">            <span class="keyword">return</span> listNodes.get(<span class="number">0</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>方法二</p></blockquote><p>通过快慢指针法，让一个指针永远比当前指针快n个元素，那么当快指针到达末尾的时候，就能够确定倒数第N个元素。示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode p , q , pre ;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        p = head ; <span class="comment">// 快指针</span></span><br><span class="line">        q = head ;<span class="comment">// 慢指针</span></span><br><span class="line">        pre = q ; <span class="comment">//用于记录q的前一个元素，有利于元素的删除</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; n ; i++) <span class="comment">//让p比q快n个元素</span></span><br><span class="line">            p = p.next ;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            p = p.next ;</span><br><span class="line">            pre = q ;</span><br><span class="line">            q = q.next ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre == q)&#123;       <span class="comment">// 判断删除元素是否为头</span></span><br><span class="line">            <span class="keyword">return</span> q.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre.next = q.next ;</span><br><span class="line">            <span class="keyword">return</span> head ; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目介绍&quot;&gt;&lt;a href=&quot;#题目介绍&quot; class=&quot;headerlink&quot; title=&quot;题目介绍&quot;&gt;&lt;/a&gt;题目介绍&lt;/h3&gt;&lt;p&gt;给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。(进阶：你能尝试使用一趟扫描实现吗？)&lt;/p&gt;
&lt;bloc
      
    
    </summary>
    
      <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/Leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>3. Java控制流程</title>
    <link href="http://example.com/wiki/JavaSE/%E7%AC%AC%E4%B8%89%E7%AB%A0-Java%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/java%20controll%20followe/"/>
    <id>http://example.com/wiki/JavaSE/第三章-Java基本程序结构/java controll followe/</id>
    <published>2021-10-27T03:07:05.097Z</published>
    <updated>2021-10-27T06:48:04.804Z</updated>
    
    <content type="html"><![CDATA[<p>程序的控制流程一般包含，选择结构，循环结构，顺序结构。</p><blockquote><p>顺序结构</p><blockquote><p>顺序结构很简单，程序都具有顺序结构，依次按顺序执行。<br>Java的语法，不允许在嵌套的两个块(块一般是指，通过{}包含的代码区域，称为块)中，声明同名变量。示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">int</span> n; <span class="comment">// Error can&#x27;t redefine n in inner block</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>选择结构<br>选择结构也就是 if-else结构，通过条件语句来选择需要执行的语句。else与最近的if构成匹配。示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ifElseTemplemate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span> ,b = <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; b)</span><br><span class="line">            System.out.println(<span class="string">&quot;a大于b&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span>(a == b)</span><br><span class="line">                System.out.println(<span class="string">&quot;a 等于 b&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.println(<span class="string">&quot;a 小于 b&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果有多个选择情况，可以通过Switch-case语句进行实现。代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ifElseTemplemate</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> a = <span class="number">1</span> ,b = <span class="number">2</span> ;</span><br><span class="line">       <span class="keyword">if</span>(a &gt; b)</span><br><span class="line">           System.out.println(<span class="string">&quot;a大于b&quot;</span>);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">if</span>(a == b)</span><br><span class="line">               System.out.println(<span class="string">&quot;a 等于 b&quot;</span>);</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               System.out.println(<span class="string">&quot;a 小于 b&quot;</span>);</span><br><span class="line">       <span class="keyword">switch</span> (a)&#123;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">               System.out.println(a);<span class="keyword">break</span> ;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">               System.out.println(a);</span><br><span class="line">               <span class="keyword">break</span> ;</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               System.out.println(a);<span class="keyword">break</span> ;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br>switch语句将从与选项值相匹配的case标签处开始执行直到遇到 break 语句，或者执行到switch i吾句的结束处为止。如果没有相匹配的case标签,而有default子句,就执行这个子句。<br>case 标签可以是：</p></blockquote></blockquote><pre><code>•类型为 char、byte、 short 或 int 的常量表达式。•枚举常量。•从 Java SE 7开始， case 标签还可以是字符串字面量。</code></pre><blockquote><p>循环结构<br>循环执行某个代码块。一般包含for循环和while循环，do-while循环。示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forWhileStatement</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">// 计算1-100的和</span></span><br><span class="line">     <span class="keyword">int</span> sum = <span class="number">0</span> , i = <span class="number">0</span> ;</span><br><span class="line">     <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt;= <span class="number">100</span> ; i++)&#123;</span><br><span class="line">         sum +=i;</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(sum);</span><br><span class="line">     i = <span class="number">0</span> ;</span><br><span class="line">     sum = <span class="number">0</span> ;</span><br><span class="line">     <span class="keyword">while</span>(i&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">         sum+=i;</span><br><span class="line">         i++;</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(sum);</span><br><span class="line">     i = <span class="number">0</span> ;</span><br><span class="line">     sum = <span class="number">0</span> ;</span><br><span class="line">     <span class="keyword">do</span>&#123;</span><br><span class="line">         sum+=i;</span><br><span class="line">         i++;</span><br><span class="line">     &#125;<span class="keyword">while</span>(i&lt;=<span class="number">100</span>) ;</span><br><span class="line">     System.out.println(sum);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>还有一种循环方式为for-each循环，参考数组的循环。</p></blockquote><p>如果想跳出循环可以使用break;，如果想要跳出某个执行过程可以用continue。Java也支持类似于goto的语法，通过break 标签来结束循环。示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forWhileStatement</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>   i = <span class="number">0</span>, j  ;</span><br><span class="line">        lables:</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;in&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span> lables;<span class="comment">//跳出指定的循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;程序的控制流程一般包含，选择结构，循环结构，顺序结构。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;顺序结构&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;顺序结构很简单，程序都具有顺序结构，依次按顺序执行。&lt;br&gt;Java的语法，不允许在嵌套的两个块(块一般是指，通过{}包含的代码
      
    
    </summary>
    
      <category term="JavaSE" scheme="http://example.com/categories/JavaSE/"/>
    
    
      <category term="JAVA" scheme="http://example.com/tags/JAVA/"/>
    
      <category term="JAVASE" scheme="http://example.com/tags/JAVASE/"/>
    
  </entry>
  
  <entry>
    <title>2. Java基本语法</title>
    <link href="http://example.com/wiki/JavaSE/%E7%AC%AC%E4%B8%89%E7%AB%A0-Java%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/java%20basic%20statment/"/>
    <id>http://example.com/wiki/JavaSE/第三章-Java基本程序结构/java basic statment/</id>
    <published>2021-10-26T09:21:11.459Z</published>
    <updated>2021-10-27T07:14:45.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Java注释"><a href="#1-Java注释" class="headerlink" title="1. Java注释"></a><a href="#one">1. Java注释</a></h2><h2 id="2-Java数据类型"><a href="#2-Java数据类型" class="headerlink" title="2. Java数据类型"></a><a href="#two">2. Java数据类型</a></h2><h2 id="3-Java变量"><a href="#3-Java变量" class="headerlink" title="3. Java变量"></a><a href="#three">3. Java变量</a></h2><h2 id="4-Java运算符"><a href="#4-Java运算符" class="headerlink" title="4. Java运算符"></a><a href="#four">4. Java运算符</a></h2><h2 id="5-Java字符串"><a href="#5-Java字符串" class="headerlink" title="5. Java字符串"></a><a href="#five">5. Java字符串</a></h2><h2 id="6-Java输入流"><a href="#6-Java输入流" class="headerlink" title="6. Java输入流"></a><a href="#six">6. Java输入流</a></h2><h2 id="7-Java数组"><a href="#7-Java数组" class="headerlink" title="7. Java数组"></a><a href="#seven">7. Java数组</a></h2><h2 id="8-大数值"><a href="#8-大数值" class="headerlink" title="8. 大数值"></a><a href="#eight">8. 大数值</a></h2><p>一般我们在学习一门语言的时候，总是从hello world入门，所以我们也是从hello world开始入门。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstSample</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果你想运行一个java程序，那么需要在类里面加上main方法，作为程序的入口让程序运行起来。格式如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String口 args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        program statements</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="1-注释"><a href="#1-注释" class="headerlink" title="1. 注释"></a>1.<a id="one"></a> 注释</h3><p>注释一般用于书写一些关于程序或者变量，算法的说明。用于辅助他人阅读你的程序代码，增加代码的可读性。</p><p>Java的注释可以分成三种注释。</p><blockquote><ol><li>以双反斜杠标记的注释 //</li></ol></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;如下代码所示，通过//注释对变量进行解释说明。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String口 args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i , j ; <span class="comment">// i和j为临时变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>2, 以/<em> TO-DO </em>/,将一段内容进行注释。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;这个注释和//注释的区别在于。//是单行注释，而/<em>….</em>/可以表示多行注释。示例如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String口 args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这是多行注释。</span></span><br><span class="line"><span class="comment">            可以注释多行。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="keyword">int</span> i , j ; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>第三种是/<em>* </em>/注释，称为文档注释，用于生成程序说明文档。一般在类上或者方法上进行注释。</li></ol></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;示例如下：通过文档注释，标明了类创建的时间。关于文档注释的其它声明，可以查阅相关资料。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021-10-26 19:44</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java</span>基本数据类型 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果想要程序在执行中间退出，则通过System.exit()退出程序</span></span><br><span class="line">        System.exit(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;程序中止返回&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. <a id="two"></a>数据类型</h3><p>Java是一种强类型语言，Java的变量在使用前，都需要进行变量的声明。Java有8种基本数据类型。分别为4种整型，2种浮点型，1种字符型，1种布尔型(boolean).</p><blockquote><p>1, 整型</p></blockquote><p>整型也就是常说的整数。用于表示数据为整数。</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">字长</th><th style="text-align:center">取值</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">1</td><td style="text-align:center">-128-127</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">2</td><td style="text-align:center">-2^15-(2^15-1)</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">4</td><td style="text-align:center">-2^31-(2^31-1)</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">8</td><td style="text-align:center">-2^63-(2^63-1)</td></tr></tbody></table></div><p>示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">basicType</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">byte</span> a ;</span><br><span class="line">       <span class="keyword">short</span> b ;</span><br><span class="line">       <span class="keyword">int</span> c;</span><br><span class="line">       <span class="keyword">long</span> d  ;</span><br><span class="line">       d = <span class="number">10000000L</span> ; <span class="comment">//通过L表示为长整型数据</span></span><br><span class="line">       c = <span class="number">0x123</span> ; <span class="comment">//通过0x表示为十六进制</span></span><br><span class="line">       c = <span class="number">0b1001</span> ; <span class="comment">//通过0b表示二进制数据</span></span><br><span class="line">       c = <span class="number">010</span> ; <span class="comment">//通过0开头，表示为八进制数据。</span></span><br><span class="line">   &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure></p><blockquote><ol><li>浮点类型</li></ol></blockquote><p>浮点类型的数据也就是我们常说的小数。</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">字长</th><th style="text-align:center">取值</th></tr></thead><tbody><tr><td style="text-align:center">float</td><td style="text-align:center">4</td><td style="text-align:center">大约 ± 3.402 823 47E+38F (有效位数为 6 ~ 7 位）</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8</td><td style="text-align:center">大约 ± 1.797 693 134 862 315 70E+308 (有效位数为 15 位)</td></tr></tbody></table></div><p>double 表示这种类型的数值精度是 float 类型的两倍（有人称之为双精度数值)。绝大部分应用程序都采用 double 类型。float 类型的数值有一个后缀 F 或 f (例如，3.14F。) 没有后缀 F 的浮点数值（如 3.14 ) 默认为double 类型。当然，也可以在浮点数值后面添加后缀 D 或 d (例如，3.14D)<br>。</p><blockquote><ol><li>字符类型<br>字符类型char采用unicode编码格式。char 类型的字面量值要用单引号括起来。, char 类型的值可以表示为十六进制值，其范围从 \u0000 到 \Uffff。例如：W2122 表示注册符号 ( ), \u03C0 表示希腊字母 it。在Java中，char类型占用两个字节（采用16位的Unicode字符集）。示例代码如下，用于输出显示两个特殊的字符。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">basicType</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">char</span> g = <span class="string">&#x27;\u2122&#x27;</span>; <span class="comment">//注册符号 Tm</span></span><br><span class="line">      System.out.println(g);</span><br><span class="line">      g = <span class="string">&#x27;\u03C0&#x27;</span> ;</span><br><span class="line">      System.out.println(g);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li>Boolean类型<br>boolean(布尔)类型一般有两个值:true和false,用来判定逻辑条件。在Java中整型不能替代布尔类型(这在C/c++却是可以的。)</li></ol></blockquote><p>对于数据类型，我们可以在不同的数据类型之间进行转化(强制类型转换)。</p><h3 id="3-变量"><a href="#3-变量" class="headerlink" title="3.  变量"></a>3. <a id="three"></a> 变量</h3><p>变量的声明在前面数据类型也可以看到。一般格式为：数据类型  变量名; </p><blockquote><p>变量名的命名格式</p></blockquote><p>变量名必须是一个以字母开头并由字母或数字构成的序列。需要注意，与大多数程序设<br>计语言相比，Java 中“ 字母” 和“ 数字” 的范围更大。字母包括“A’~Z”、“a~z”、或在某种语言中表示字母的任何 Unicode 字符。</p><blockquote><p>变量的初始化和赋值操作</p></blockquote><p>初始化一般是在变量的声明时候，给变量一个初始值(这是一个好的编程习惯)。变量的赋值一般通过=对变量进行赋值操作。示例代码如下所示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">30</span> , b ; <span class="comment">//对变量进行初始化</span></span><br><span class="line">      b = <span class="number">20</span> ; <span class="comment">//对变量进行赋值</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>常量</p></blockquote><p>常量也就是一直不变的量，只能被赋值一次。一般我们通过final来指示常量(一般用纯大写作为变量名，下划线进行分割)。示例代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">30</span> , b ; <span class="comment">//对变量进行初始化</span></span><br><span class="line">    b = <span class="number">20</span> ; <span class="comment">//对变量进行赋值</span></span><br><span class="line">    <span class="keyword">final</span>  <span class="keyword">double</span> PI = <span class="number">3.1415962</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于类常量，一般是作为类的成员变量，并且访问修饰符为static。可以理解为，加了sttic外部就能直接引用该变量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.1415926</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4. 运算符"></a>4. <a id="four"></a>运算符</h3><p>运算符一般就是加减乘除这些运算符，以及一些特殊操作。+,-,*./,%(取余)。</p><p>对于取余有一个技巧，保证不取负数。通过（(position +<br>adjustment) % 12 + 12) % 12。公式进行取余操作，就保证了余数在0-11之间，不出现负数的情况。</p><p>还有一些运算符属于双目运算符，如 +=,-=,*=…。这写运算符和前面的运算符类似只不过，多了赋值操作。a += b; 等价于 a = a+b 。可以编程进行验证。</p><p>自增运算符：++和—, x++也就等价于 x += 1; </p><p>关系运算符：主要是用于比较数值的大小，如&gt;=,&lt;=,&gt;,&lt;，!= 等关系运算。简单的例子就是：a&gt;b ,比较a和b的大小。</p><p>逻辑运算符：也就是与，或，非三个运算。&amp;&amp; 表示与， || 表示或，！表示非。一般用于条件表达式表示多条件的情况。如表示 a&gt; b 且 a&gt; c的情况,可以写成 a&gt;b &amp;&amp; a&gt;c </p><p>三元操作符?: 用法 a&gt;b?a:b 。如果a&gt;b则执行a,反之执行b</p><p>位运算符：&amp;,|,^（异或）,~(非)。一般用于对整数各个位(二进制)进行位运算。&gt;&gt;和&lt;&lt;运算符，用于将数据左移和右移。需要建立位模式来完成位掩码时， 这两个运算符会很方便。&gt;&gt;&gt;会用0填充高位，而&gt;&gt;则是用符号位填充高位。移位运算符的右操作数要完成模 32 的运算（除非左操作数是 long 类型， 在这种情况下需要对右操作數模 64 )。例如， 1 «35 的值等同于 1 «3 或 8。也就是最多不会超过int类型，如果超过那么就等同于模32后再右移动。</p><blockquote><p>运算符优先级<br>运算符优先级也就是运算符的优先执行顺序。如果不确定优先级，我们可以用括号包含起来。<br>运算符优先级 单目运算(!,~,++,new,强制类型转换) &gt; (*，/,%) &gt; (+,-) &gt; (&lt;&lt;, &gt;&gt; , &gt;&gt;&gt;) &gt; (&lt; , &gt;  , &gt;= , instanceof) &gt; (==,!=) &gt; (&amp;) &gt; (^) &gt;(|) &gt; (&amp;&amp;) &gt; (||) &gt; (?) &gt; (=,+=,-=……)。</p><p>枚举类型<br>通过enum 进行枚举类型的声明，包括有限个命名的值。示例代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> 枚举类型 </span>&#123;</span><br><span class="line">    SMALL(<span class="number">1</span>,<span class="string">&quot;小号&quot;</span>),</span><br><span class="line">    MEDIUM(<span class="number">2</span>,<span class="string">&quot;中号&quot;</span>),;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code ;</span><br><span class="line">    <span class="keyword">private</span> String message ;</span><br><span class="line">    枚举类型(<span class="keyword">int</span> code , String message)&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code ;</span><br><span class="line">        <span class="keyword">this</span>.message = message ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">(String define)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 返回枚举类型的code,根据Message</span></span><br><span class="line">        <span class="keyword">return</span> 枚举类型.valueOf(define).code ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMessage</span><span class="params">(String define)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> 枚举类型.valueOf(define).message ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="5-字符串"><a href="#5-字符串" class="headerlink" title="5. 字符串"></a>5. <a id="five"></a>字符串</h3><p>字符串也就是一串字符，通常用””包含。一般我们使用String表示字符类型。示例: String str = “hello world” ; , 字串则是字符串的一串连续的字符，如”worl”就是str的一个字串。如果需要拼接字符，可以通过+号进行拼接。如果需要拼接多个，可以通过定界符(，)分割，然后用静态join方法拼接。如:String str = String.join(“h”,”ello”,”w”,”rold”) ; </p><p>Java如果要修改某个字符，一般需要创建新的字符常量对象。Java的String类似于指针，指向字串常量在存储池（堆）的相应位置。如果指向相同的字符常量， 则这两个变量是相同的。可以运行如下代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">byteString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String a = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        String b = <span class="string">&quot;123&quot;</span> ;</span><br><span class="line">        String c = <span class="keyword">new</span> String(<span class="string">&quot;123&quot;</span>) ;</span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">        System.out.println(a.equals(b));</span><br><span class="line">        System.out.println(a == c);</span><br><span class="line">        System.out.println(a.equals(c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面的代码中两个变量 a == b 比较的是两个变量是否相同(类比于比较地址是否相同)，a.equeals(b)检测的是两个字符串是否相等。<br>检查一个字符串既不是 null 也不为空串，这种情况下就需要使用以下条件：if (str != null &amp;&amp; str.length()!= 0),先检测变量是否为空，在判断长度是否为空。</p><blockquote><p>StringBuffer和StringBuilder的区别</p></blockquote><p>StringBuilder支持单线程，StringBuffer支持多线程。就效率而言,StringBuilder快于StringBuffer，所以在单线程程序中采用StringBuilder较好，多线程程序采用StringBuffer。</p><h3 id="6-输入输出流"><a href="#6-输入输出流" class="headerlink" title="6. 输入输出流"></a>6. <a id="six"></a>输入输出流</h3><p>java输入输出流，通过Scanner对象和标准输入流（System.in）相关联进行获取。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ioStream</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// Java构建输入流，通过Scanner对象和标准输入流Sytem.in对象关联。</span></span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in) ;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;输入字符：&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String text = in.nextLine() ;</span><br><span class="line"></span><br><span class="line">        System.out.println(text);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因为输入是可见的， 所以 Scanner 类不适用于从控制台读取密码。Java SE 6 特别<br>引入了 Console 类实现这个目的。要想读取一个密码， 可以采用下列代码：</p><pre><code>Console cons = System.console();String username = cons.readLine(&quot;User name: &quot;)；char [] passwd = cons.readPassword(&quot;Password:&quot;);</code></pre><p>为了安全起见， 返回的密码存放在一维字符数组中， 而不是字符串中。在对密码进<br>行处理之后，应该马上用一个填充值覆盖数组元素（数组处理将在 3.10 节介绍）。<br>采用 Console 对象处理输入不如采用 Scanner 方便。每次只能读取一行输入， 而没有<br>能够读取一个单词或一个数值的方法。</p><blockquote><p>格式化输出<br>最简单的方法是采用C语言的方法进行输出System.printf就可以通过C语言的printf输出方式进行输出。</p><p>文件输入与输出<br>通过File对象构建Scanner对象进行文件的读取，通过PrintWriter进行文件的输出。示例代码如下所：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileIO</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//文件输入流 , get路径为文件路径</span></span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(Paths.get(<span class="string">&quot;javase/src/main/java/Java核心技术/第三章Java的基本程序设计/myfile.txt&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>) ;</span><br><span class="line">        <span class="keyword">while</span>(in.hasNext())&#123;</span><br><span class="line">            System.out.println(in.next());</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">        System.out.println();</span><br><span class="line">        in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">&quot;javase/src/main/java/Java核心技术/第三章Java的基本程序设计/myfile.txt&quot;</span>)) ;</span><br><span class="line">        <span class="keyword">while</span>(in.hasNextLine())&#123;</span><br><span class="line">            System.out.println(in.nextLine());</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文件输出流，路径填写文件路径</span></span><br><span class="line">        PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> File(<span class="string">&quot;javase/src/main/java/Java核心技术/第三章Java的基本程序设计/myfile.txt&quot;</span>) ) ;</span><br><span class="line">        out.write(<span class="string">&quot;this is a test two&quot;</span>);</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="7-数组"><a href="#7-数组" class="headerlink" title="7.数组"></a>7.<a id="seven"></a>数组</h3><p>数组存储了一串连续地址的元素，通过元素下标可以访问到数组元素。数组有如下几种声明方式。</p><pre><code>int[] a ;int[] a = new int[100] ; int a[] ; int[] a = &#123;1,2,3,4,5&#125; ; new int[] &#123;17,19,23,29&#125; ; //匿名数组</code></pre><blockquote><p>数组的迭代方法</p><ol><li>for，while循环<br>通过遍历数组下标来遍历数组的元素</li><li>for-each循环<br>通过for-each遍历数组的每一个元素。for-each的一般形式为：for (variable : collection) statement。如果要遍历集合，那么对应的集合必须是数组或者实现了Iterable接口的类对象。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">array</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i ;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125; ;</span><br><span class="line">        <span class="comment">//for循环遍历</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; a.length ; i++)&#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for-each循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> temp : a)&#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>打印数组<br>通过Arrays类的toString方法，可以打印一个数组。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">array</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i ;</span><br><span class="line">       <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125; ;</span><br><span class="line">       <span class="comment">//for循环遍历</span></span><br><span class="line">       <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; a.length ; i++)&#123;</span><br><span class="line">           System.out.println(a[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//for-each循环</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> temp : a)&#123;</span><br><span class="line">           System.out.println(temp);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//打印数组</span></span><br><span class="line">       System.out.println(Arrays.toString(a) );;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br>数组拷贝<br>简单的数组赋值，只是浅拷贝，二者指向的还是一个堆栈空间。如果需要进行数值拷贝，则通过Arrays.copyOf进行数据的拷贝。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125; ; </span><br><span class="line"><span class="keyword">int</span>[] b ; </span><br><span class="line">b = a ; <span class="comment">//这是简单的赋值，浅拷贝</span></span><br><span class="line">b[<span class="number">1</span>] = <span class="number">10</span> ;<span class="comment">// 则a[1]也变为10 </span></span><br><span class="line">b = Arrays.copyOf(a,a.length) ; <span class="comment">//</span></span><br><span class="line">b[<span class="number">1</span>] = <span class="number">2</span> ; <span class="comment">//则a[1] 还是为10并不影响。</span></span><br></pre></td></tr></table></figure><br>Arrays包含许多关于数组的操作,包括数组的打印，数组的拷贝，排序等功能。</p><p>数组排序<br>通过Arrays.sort（a），可以对数组a进行排序（无返回值）。该排序方法使用了优化的快速排序算法(可以阅读源码，理解排序方法)。</p><p>数组填充<br>通过Arrays.fill（a,value），用数据填充数组。</p><p>多维数组<br>多维数组的初始化方法：<br>    double[][] balances ;<br>    balances = new double[NYEARS] [NRATES];<br>    int[][] magicSquare =<br>            {<br>                {16, 3, 2, 13}， {5, 10, 11, 8},<br>                (9, 6, 7, 12},<br>                {4, 15, 14, 1}<br>            };<br>多维数组的迭代<br>for循环迭代，只需要通过下标进行迭代即可。<br>for-each迭代格式如下：</p></blockquote><pre><code>for (doubleG row : a)    for (double value : row)        do something with value        </code></pre><blockquote><p>多维数组的打印<br>通过Arrays.deepToString进行多为数组的打印。</p><p>不规则的数组<br>不规则数组一般是多维的维数可能不一致。如果需要创建多维数组，必须先分配具有所含行数的数组，然后再分配行数组的长度。</p><h3 id="8-大数值-1"><a href="#8-大数值-1" class="headerlink" title="8. 大数值"></a>8. <a id="eight"></a>大数值</h3><p>如果基本的整数和浮点数精度不能够满足需求， 那么可以使用jaVa.math 包中的两个<br>很有用的类：Biglnteger 和 BigDecimaL 这两个类可以处理包含任意长度数字序列的数值。<br>Biglnteger 类实现了任意精度的整数运算， BigDecimal 实现了任意精度的浮点数运算。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bigData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//通过BigInter和BigDecimal可以实现大数的运算,需要将数据转化为大数对象，再进行运算。</span></span><br><span class="line">        BigInteger a = BigInteger.valueOf(<span class="number">1</span>) ;</span><br><span class="line">        a = a.add(BigInteger.valueOf(Long.MAX_VALUE));</span><br><span class="line">        System.out.println(a.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Java注释&quot;&gt;&lt;a href=&quot;#1-Java注释&quot; class=&quot;headerlink&quot; title=&quot;1. Java注释&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#one&quot;&gt;1. Java注释&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;2-Java数据类型&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="JavaSE" scheme="http://example.com/categories/JavaSE/"/>
    
    
      <category term="JAVA" scheme="http://example.com/tags/JAVA/"/>
    
      <category term="JAVASE" scheme="http://example.com/tags/JAVASE/"/>
    
  </entry>
  
  <entry>
    <title>1. Java介绍</title>
    <link href="http://example.com/wiki/JavaSE/%E7%AC%AC%E4%B8%89%E7%AB%A0-Java%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/java%20introduce/"/>
    <id>http://example.com/wiki/JavaSE/第三章-Java基本程序结构/java introduce/</id>
    <published>2021-10-26T06:59:14.834Z</published>
    <updated>2021-11-15T01:54:07.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Java语言的特性"><a href="#1-Java语言的特性" class="headerlink" title="1. Java语言的特性"></a><a href="#one">1. Java语言的特性</a></h2><h2 id="2-JAVA8新特性"><a href="#2-JAVA8新特性" class="headerlink" title="2. JAVA8新特性"></a><a href="#two">2. JAVA8新特性</a></h2><h3 id="1-Java语言的特性-1"><a href="#1-Java语言的特性-1" class="headerlink" title="1. Java语言的特性"></a>1. <a id="one"></a>Java语言的特性</h3><p>1 ) 简单性</p><p>Java语法相对于C++而言，少了很多复杂与语法，如头文件，指针运算，结构，联合，操作符重载，虚基类等。</p><p>2 ) 面向对象</p><p>面向对象是一种程序设计技术，与之相对应的技术为面向过程。面向对象的程序设计在设计方法上着重于事物的属性和行为的设计，而不是具体的过程上进行设计。</p><p>3 ) 分布式</p><p>分布式也就是将一个任务分到多个服务器进行解决。Java提供了丰富的例程库，用于处理TCP/IP协议。</p><p>4 ) 健壮性</p><p>Java在对程序错误的检测包括，编译时错误和运行时错误，消除了容易出错的情况。并且对于Java采用的指针模型，可以消除重写内存和损坏数据的可能性。</p><p>5 ) 安全性</p><p> 从一开始，Java 就设计成能够防范各种攻击，其中包括：</p><pre><code>•运行时堆栈溢出。 如蠕虫和病毒常用的攻击手段。•破坏自己的进程空间之外的内存。•未经授权读写文件</code></pre><p>Java 浏览器插件不再信任远程代码，除非代码有数字签名而且用户同意执行这个代码</p><p>6 ) 体系结构中立</p><p>编译器生成字节码文件(类似于用一个新语言进行解释),只要有java运行环境，就能够在计算机上运行程序。虚拟机可以将执行最频繁的字节码序列翻译成机器码(即时编译)，加快运行速度。(字节码的解释程序由C语言进行实现。)</p><p>Java源程序-编译器&gt;生成字节码文件(出现频繁的字节码序列会被翻译成机器码)-java虚拟机&gt;运行字节码文件，运行Java程序。</p><p>7 ) 可移植性</p><p>Java中的int永远为32位的整数，与平台无关。字符数据通过Unicode格式存储。</p><p>8 ) 解释型</p><p>Java 解释器可以在任何移植了解释器的机器上执行 Java 字节码。Java是解释型语言。</p><p>9 ) 高性能</p><p>即时编译器可以监控经常执行哪些代码并优化这些代码以提高速度。更为复杂的优化是消除函数调用（即“ 内联”）。即时编译器知道哪些类已经加载。基于当前加载的类集， 如果特定的函数不会被覆盖，就可以使用内联。必要时，还可以撤销优化。</p><p>10 ) 多线程</p><p>多线程可以带来更好的交互响应和实时行为。</p><p>11 ) 动态性</p><p>从各种角度看， Java 与 C 或 C++ 相比更加具有动态性。它能够适应不断发展的环境库中可以自由地添加新方法和实例变量， 而对客户端却没有任何影响。在Java 中找出运行时类型信息十分简单。当需要将某些代码添加到正在运行的程序中时， 动态性将是一个非常重要的特性。</p><blockquote><p>总结Java特性：Java采用字节码文件作为编译后的文件，通过JVM生成字节码文件，并且对于常用出现的字节码序列会转化为机器码(即时编译器))，加快程序编译运行速度。并且Java与平台无关，拥有丰富的库，能够支持分布式，动态式，多线程。并且很安全。</p></blockquote><h3 id="2-JAVA8新特性-1"><a href="#2-JAVA8新特性-1" class="headerlink" title="2. JAVA8新特性"></a>2. <a id="two"></a>JAVA8新特性</h3><pre><code>Lambda表达式，包含默认方法的接口，流和时间/日期库</code></pre><h3 id="JAVA开发环境"><a href="#JAVA开发环境" class="headerlink" title="JAVA开发环境"></a>JAVA开发环境</h3><blockquote><h4 id="一些Java环境术语"><a href="#一些Java环境术语" class="headerlink" title="一些Java环境术语"></a>一些Java环境术语</h4><blockquote><ul><li><p>JDK（Java Development Kit）: 编写Java程序的程序员使用的软件。在Java 1.2-1.4版本被称为Java SDK (软件开发包,Software Development Kit)。我们现在经常看到关于JDK1.8,以及Java8，那么二者之间是什么关系呢？Java早期发布版本是直接增加小数点后面的数值。例如1.3，1.4，1.5等。而在2006年后版本号进行简化，开始次啊用Java SE6,Java SE 7 ,Java SE 8 作为版本号，这就是我们常熟悉的版本号。但是对于其内部的版本号，分别是1.6.0，1.7.0，1.8.0。对于版本号为1.8.0_31（Java SE 8u31）表示的是对Java SE 8 的第31次修改后的版本。</p></li><li><p>JRE（Java Runtime Enviroment）:运行Java程序的用户使用的软件。</p></li><li>SE(Standard Edition): 用于桌面或简单服务器应用的Java平台。</li><li>EE(Enterprise Edition):用于复杂服务器应用的Java平台。</li><li>ME(Micro Edition):用于手机和其它小型设备的Java平台。 </li></ul></blockquote></blockquote><h4 id="命令行操作"><a href="#命令行操作" class="headerlink" title="命令行操作"></a>命令行操作</h4><ol><li>通过命令行命令查看Java版本号 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -version</span><br></pre></td></tr></table></figure></li><li>通过命令行运行Java程序<br> 通过javac编译java源程序，通过java程序启动java虚拟机，虚拟机执行编译器放在class文件的字节码。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac xxxx.java</span><br><span class="line">java xxxx</span><br></pre></td></tr></table></figure> 在编译运行java程序的时候，会将程序中包含main方法的类名提供给字节码解释器，以便启动程序。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Java语言的特性&quot;&gt;&lt;a href=&quot;#1-Java语言的特性&quot; class=&quot;headerlink&quot; title=&quot;1. Java语言的特性&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#one&quot;&gt;1. Java语言的特性&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;2-JAVA8新
      
    
    </summary>
    
      <category term="JavaSE" scheme="http://example.com/categories/JavaSE/"/>
    
    
      <category term="JAVA" scheme="http://example.com/tags/JAVA/"/>
    
      <category term="JAVASE" scheme="http://example.com/tags/JAVASE/"/>
    
  </entry>
  
  <entry>
    <title>48.旋转数组</title>
    <link href="http://example.com/wiki/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/48.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <id>http://example.com/wiki/算法/Leetcode/数组/48.旋转数组/</id>
    <published>2021-10-26T04:21:45.745Z</published>
    <updated>2021-10-26T04:48:30.703Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  通过辅助数组进行实现</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[][] totataMatrix = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix.length] ;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span> , j = <span class="number">0</span> , len = matrix.length;</span><br><span class="line">      <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; len ; j++)&#123;</span><br><span class="line">              totataMatrix[j][len-i-<span class="number">1</span>] = matrix[i][j];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; len ; j++)&#123;</span><br><span class="line">              matrix[i][j] = totataMatrix[i][j];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果需要原地旋转，那就必须需要考虑数组下标之间的关系，然后进行旋转操作</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotateTwo</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span> , j = <span class="number">0</span> , len = matrix.length;</span><br><span class="line">      <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; len / <span class="number">2</span>; i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; (len+<span class="number">1</span>) /<span class="number">2</span> ; j++)&#123;</span><br><span class="line">              <span class="keyword">int</span> temp = matrix[i][j] ;</span><br><span class="line">              matrix[i][j] = matrix[len-j-<span class="number">1</span>][i] ;</span><br><span class="line">              matrix[len-j-<span class="number">1</span>][i] = matrix[len-i-<span class="number">1</span>][len-j-<span class="number">1</span>] ;</span><br><span class="line">              matrix[len-i-<span class="number">1</span>][len-j-<span class="number">1</span>] = matrix[j][len-i-<span class="number">1</span>] ;</span><br><span class="line">              matrix[j][len-i-<span class="number">1</span>] = temp ;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数组选择90度又可以转换为数组翻转问题，首先进行上下翻转，然后再根据主对角线进行翻转。</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotateThree</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span> , j = <span class="number">0</span> , len = matrix.length;</span><br><span class="line">      <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; len / <span class="number">2</span>; i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; (len+<span class="number">1</span>) /<span class="number">2</span> ; j++)&#123;</span><br><span class="line">              <span class="keyword">int</span> temp = matrix[i][j] ;</span><br><span class="line">              matrix[i][j] = matrix[len-j-<span class="number">1</span>][i] ;</span><br><span class="line">              matrix[len-j-<span class="number">1</span>][i] = matrix[len-i-<span class="number">1</span>][len-j-<span class="number">1</span>] ;</span><br><span class="line">              matrix[len-i-<span class="number">1</span>][len-j-<span class="number">1</span>] = matrix[j][len-i-<span class="number">1</span>] ;</span><br><span class="line">              matrix[j][len-i-<span class="number">1</span>] = temp ;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>36.有效数独</title>
    <link href="http://example.com/wiki/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/36.%E6%9C%89%E6%95%88%E6%95%B0%E7%8B%AC/"/>
    <id>http://example.com/wiki/算法/Leetcode/数组/36.有效数独/</id>
    <published>2021-10-26T02:09:42.061Z</published>
    <updated>2021-10-26T04:48:10.980Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public boolean <span class="function"><span class="title">isValidSudokuTwo</span>(<span class="params">char[][] board</span>)</span> &#123;</span><br><span class="line">        int i = <span class="number">0</span> , j = <span class="number">0</span> , k = <span class="number">0</span> , l = <span class="number">0</span> , idx  ;</span><br><span class="line">        HashMap&lt;Integer, HashSet&lt;Character&gt;&gt; area = <span class="keyword">new</span> HashMap&lt;Integer, HashSet&lt;Character&gt;&gt;() ;</span><br><span class="line">        <span class="comment">//判断行列是否符合数独条件</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; board.length ; i++)&#123;</span><br><span class="line">            HashMap&lt;Character, Integer&gt; row = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;() ;</span><br><span class="line">            HashMap&lt;Character, Integer&gt; col = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;() ;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; board.length ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] != <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(row.containsKey(board[i][j]))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        row.put(board[i][j],<span class="number">1</span>) ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(board[j][i] != <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(col.containsKey(board[j][i]))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        col.put(board[j][i],<span class="number">1</span>) ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                idx = (i/<span class="number">3</span>)*<span class="number">3</span> + j/<span class="number">3</span> ;</span><br><span class="line">                <span class="keyword">if</span>(!area.containsKey(idx))&#123;</span><br><span class="line">                    area.put(idx,<span class="keyword">new</span> HashSet&lt;Character&gt;()) ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(area.get(idx).contains(board[i][j]))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    area.get(idx).add(board[i][j]) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>  ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
      <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Git常见的问题及解决方案</title>
    <link href="http://example.com/wiki/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/Git/%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/wiki/程序技术/Git/问题/</id>
    <published>2021-10-25T11:43:34.168Z</published>
    <updated>2021-11-04T06:51:28.358Z</updated>
    
    <content type="html"><![CDATA[<!--编写md文件的时候，需要指明文章名称title,文章分类categroies,文章标签tags--><h3 id="Git使用教程"><a href="#Git使用教程" class="headerlink" title="Git使用教程"></a>Git使用教程</h3><h2 id="Git常见问题"><a href="#Git常见问题" class="headerlink" title="Git常见问题"></a>Git常见问题</h2><h3 id="1-当能够正常运行的项目突然无法运行，出现找不到资源文件错误的时候。"><a href="#1-当能够正常运行的项目突然无法运行，出现找不到资源文件错误的时候。" class="headerlink" title="1. 当能够正常运行的项目突然无法运行，出现找不到资源文件错误的时候。"></a>1. 当能够正常运行的项目突然无法运行，出现找不到资源文件错误的时候。</h3><pre><code>首先，能运行就标明项目本身并没有问题。对于资源文件找不到，可能就和系统的缓存加载有关。</code></pre><p>所以这个时候，可以对项目的依赖文件进行重新的审查，如果没有问题，再查看依赖是否有问题。对于Maven项目的依赖问题，<br>可以重新clean被依赖的工程，再重新install被依赖的工程。重新加载资源文件。</p><h3 id="2-git提交代码到Github时候，出现fatal-unable-to-access-‘https-github-com-zzcpage-zzcpage-github-io-git-‘-OpenSSL-SSL-read-Connection-was-reset-errno-10054"><a href="#2-git提交代码到Github时候，出现fatal-unable-to-access-‘https-github-com-zzcpage-zzcpage-github-io-git-‘-OpenSSL-SSL-read-Connection-was-reset-errno-10054" class="headerlink" title="2. git提交代码到Github时候，出现fatal: unable to access ‘https://github.com/zzcpage/zzcpage.github.io.git/‘: OpenSSL SSL_read: Connection was reset, errno 10054"></a>2. git提交代码到Github时候，出现<font color="red">fatal: unable to access ‘<a href="https://github.com/zzcpage/zzcpage.github.io.git/">https://github.com/zzcpage/zzcpage.github.io.git/</a>‘: OpenSSL SSL_read: Connection was reset, errno 10054</font></h3><p>产生的原因：一般是这是因为服务器的SSL证书没有经过第三方机构的签署，所以才报错。</p><p>解决方法：解除ssl验证后，再次git即可。</p><p>通过<font color="red">git config —global http.sslVerify “false”</font>命令进行解除SSL验证，解除完之后，再次Git即可提交成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!--编写md文件的时候，需要指明文章名称title,文章分类categroies,文章标签tags--&gt;
&lt;h3 id=&quot;Git使用教程&quot;&gt;&lt;a href=&quot;#Git使用教程&quot; class=&quot;headerlink&quot; title=&quot;Git使用教程&quot;&gt;&lt;/a&gt;Git使用教程&lt;/h
      
    
    </summary>
    
      <category term="程序技术" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Git" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/Git/"/>
    
    
      <category term="Git" scheme="http://example.com/tags/Git/"/>
    
      <category term="Bug解决方案" scheme="http://example.com/tags/Bug%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/wiki/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/hello-world/"/>
    <id>http://example.com/wiki/程序技术/hello-world/</id>
    <published>2021-10-25T08:23:20.423Z</published>
    <updated>2021-11-03T03:10:49.773Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><!--绝对路径进行图片的访问--><p><img src="/images/14.jpg" alt="aaa"><br><img src="/images/14.jpg"/><br><!--相对路径需要再posts里面创建相同的文件夹，然后在引用文件夹里面的图片路径--></p><h3 id="如何科学有效上网"><a href="#如何科学有效上网" class="headerlink" title="如何科学有效上网"></a>如何科学有效上网</h3><p>借助Edge的有效的扩展工具，进行安全上网</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for
      
    
    </summary>
    
      <category term="程序技术" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
</feed>
