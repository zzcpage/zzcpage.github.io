<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-12-17T06:41:43.621Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>ZZC</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python数据处理-阅读笔记三——数据分析</title>
    <link href="http://example.com/wiki/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/Python/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B8%89/"/>
    <id>http://example.com/wiki/程序技术/Python/数据处理/python数据处理/Python数据处理-阅读笔记三/</id>
    <published>2021-12-16T07:58:56.459Z</published>
    <updated>2021-12-17T06:41:43.621Z</updated>
    
    <content type="html"><![CDATA[<p>agate是Python中的一个数据分析库，这里将使用agate对数据进行分析。<br>agate接受三个参数，表格数据，数据列标题，数据列类型。<br>所以创建一个agate需要提供以上三个参数。<br>例如：table = agate.Table(country_rows , titles, types)。其中country_rows就是数据，titles就是每列的标题，types就是每列的数据类型。</p><p>agate有如下几种数据类型：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">text_type = agate.Text()</span><br><span class="line">number_type = agate.Number()</span><br><span class="line">boolean_type = agate.Boolean()</span><br><span class="line">data_type = agate.Date()</span><br></pre></td></tr></table></figure><br>对于Excel，如果要获取列的数据类型，可以根据映射表进行获取，Excel的映射表为ctype_text。获取实例如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">types = []</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> example_row:  <span class="comment"># 获取每列元素的类型</span></span><br><span class="line">    value_type = ctype_text[v.ctype]  <span class="comment"># 根据映射表获取类型</span></span><br><span class="line">    <span class="keyword">if</span> value_type == <span class="string">&#x27;text&#x27;</span>:</span><br><span class="line">        types.append(text_type)</span><br><span class="line">    <span class="keyword">elif</span> value_type == <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">        types.append(number_type)</span><br><span class="line">    <span class="keyword">elif</span> value_type == <span class="string">&#x27;xldate&#x27;</span>:</span><br><span class="line">        types.append(data_type)</span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 其它类型都以文本类型处理</span></span><br><span class="line">        types.append(text_type)</span><br></pre></td></tr></table></figure></p><h4 id="agate的常用方法"><a href="#agate的常用方法" class="headerlink" title="agate的常用方法"></a>agate的常用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#agate的内置方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1. 获取表属性</span></span><br><span class="line"><span class="built_in">print</span>(table.column_names) <span class="comment">#获取列名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2. 数据显示</span></span><br><span class="line">table.print_table(max_columns=<span class="number">7</span>)</span><br><span class="line">table.print_json()</span><br><span class="line">table.print_csv()</span><br><span class="line"></span><br><span class="line"><span class="comment">#3. 排序方法</span></span><br><span class="line"><span class="comment"># 显示根据列Total (%) 最高值的前十个数据</span></span><br><span class="line">most_egregious = table.order_by(<span class="string">&#x27;Total (%)&#x27;</span>,reverse=<span class="literal">True</span>).limit(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> most_egregious:</span><br><span class="line">    <span class="built_in">print</span>(r)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The max rate in Female&#x27;</span>)</span><br><span class="line">most_females = table.order_by(<span class="string">&#x27;Female&#x27;</span>,reverse=<span class="literal">True</span>).limit(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> most_females:</span><br><span class="line">    <span class="built_in">print</span>(r)</span><br><span class="line"></span><br><span class="line"><span class="comment">#4. 条件搜索</span></span><br><span class="line">female_data = table.where(<span class="keyword">lambda</span> r:r[<span class="string">&#x27;Female&#x27;</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>)<span class="comment">#通过where条件搜索</span></span><br><span class="line">most_females = female_data.order_by(<span class="string">&#x27;Female&#x27;</span>,reverse=<span class="literal">True</span>).limit(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> most_females:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;: &#123;&#125;%&#x27;</span>.<span class="built_in">format</span>(r[<span class="string">&#x27;Countries and areas&#x27;</span>], r[<span class="string">&#x27;Female&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment">#查找,通过find方法,查找第一个匹配的数据</span></span><br><span class="line">has_por = table.where(<span class="keyword">lambda</span> r:r[<span class="string">&#x27;Rural&#x27;</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>)</span><br><span class="line">first_match = has_por.find(<span class="keyword">lambda</span> x:x[<span class="string">&#x27;Rural&#x27;</span>]&gt;<span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(first_match[<span class="string">&#x27;Countries and areas&#x27;</span>])</span><br><span class="line"><span class="comment"># 5. 统计学方法</span></span><br><span class="line"><span class="comment"># 计算平均值的方法</span></span><br><span class="line"><span class="comment">#agate.Mean() 统计学方法和列名称来返回列的数学均值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#has_por的作用（去除空列，计算剩下数据的平均值）</span></span><br><span class="line">has_por = table.where(<span class="keyword">lambda</span> r:r[<span class="string">&#x27;Place of residence (%) Urban&#x27;</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>)</span><br><span class="line"><span class="built_in">print</span>(has_por.aggregate(agate.Mean(<span class="string">&#x27;Place of residence (%) Urban&#x27;</span>)))</span><br><span class="line"><span class="comment">#计算最大值</span></span><br><span class="line"><span class="built_in">print</span>(has_por.aggregate(agate.Max(<span class="string">&#x27;Place of residence (%) Urban&#x27;</span>)))</span><br><span class="line"><span class="comment">#计算最小值</span></span><br><span class="line"><span class="built_in">print</span>(has_por.aggregate(agate.Min(<span class="string">&#x27;Place of residence (%) Urban&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#6. 计算新的排序列,计算排名</span></span><br><span class="line"><span class="comment"># 通过compute和agate.Rank()方法</span></span><br><span class="line"><span class="comment">#，compute 是一个非常好用的工具，它基于一个数据列（或多个数据列）来计算一个新的数据列。</span></span><br><span class="line"><span class="comment">#这里创建新的表格，表格包含Total Child Labor Rank和Total (%)两个字段，根据Total (%)列进行排序</span></span><br><span class="line">ranked = table.compute([(<span class="string">&#x27;Total Child Labor Rank&#x27;</span>,agate.Rank(<span class="string">&#x27;Total (%)&#x27;</span>,reverse=<span class="literal">True</span>)),])</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> ranked.order_by(<span class="string">&#x27;Total (%)&#x27;</span>,reverse=<span class="literal">True</span>).limit(<span class="number">20</span>).rows:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(row[<span class="string">&#x27;Total (%)&#x27;</span>])+<span class="string">&quot; &quot;</span>+<span class="built_in">str</span>(row[<span class="string">&#x27;Total Child Labor Rank&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#自定义排序方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_percent</span>(<span class="params">row</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>-row[<span class="string">&#x27;Total (%)&#x27;</span>]</span><br><span class="line"></span><br><span class="line">ranked = table.compute([(<span class="string">&#x27;Children not working (%)&#x27;</span>,agate.Formula(number_type,reverse_percent)),])</span><br><span class="line"></span><br><span class="line">ranked = ranked.compute([(<span class="string">&#x27;Total Child Labor Rank&#x27;</span>,agate.Rank(<span class="string">&#x27;Children not working (%)&#x27;</span>)),])</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> ranked.order_by(<span class="string">&#x27;Total (%)&#x27;</span>,reverse=<span class="literal">True</span>).limit(<span class="number">20</span>).rows:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(row[<span class="string">&#x27;Total (%)&#x27;</span>])+<span class="string">&quot; &quot;</span>+<span class="built_in">str</span>(row[<span class="string">&#x27;Total Child Labor Rank&#x27;</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;agate是Python中的一个数据分析库，这里将使用agate对数据进行分析。&lt;br&gt;agate接受三个参数，表格数据，数据列标题，数据列类型。&lt;br&gt;所以创建一个agate需要提供以上三个参数。&lt;br&gt;例如：table = agate.Table(country_row
      
    
    </summary>
    
      <category term="Python数据处理" scheme="http://example.com/categories/Python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
    
      <category term="Python" scheme="http://example.com/tags/Python/"/>
    
      <category term="数据处理" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python数据处理-阅读笔记二——标准化和脚本化</title>
    <link href="http://example.com/wiki/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/Python/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%BA%8C%E2%80%94%E2%80%94%E6%A0%87%E5%87%86%E5%8C%96%E5%92%8C%E8%84%9A%E6%9C%AC%E5%8C%96/"/>
    <id>http://example.com/wiki/程序技术/Python/数据处理/python数据处理/Python数据处理-阅读笔记二——标准化和脚本化/</id>
    <published>2021-12-16T07:06:03.485Z</published>
    <updated>2021-12-16T07:54:00.141Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数据归一化和标准化"><a href="#数据归一化和标准化" class="headerlink" title="数据归一化和标准化"></a>数据归一化和标准化</h4><p>数据归一化：归一化通常需要对数据集进行计算，使得数据都位于一个特定的范围。<br>简单的说归一化达到的效果可以使得结果数据归一化到0-1区间。举个例子，要分析一个班级分数的分布情况，<br>那么我们可以对成绩归一化，横坐标0-1，最高分100对应1，也就是说以(分数/100,得分人数)作为坐标，分析得分情况。</p><p>数据标准化：</p><blockquote><p>借助数据归一化和标准化，能够使使用者确定数据的分布，明白该分布对后续研究或计算的含义。</p></blockquote><p>数据标准化和归一化有时还需要删除离群值，这样你才能更好地发现数据的规律和分布。也就是说对于异常数据<br>的去除。例如偶然因素出现的黑马，所以根据实际情况，剔除离群值的可以根据具体情况进行抉择。</p><h4 id="数据清洗脚本化"><a href="#数据清洗脚本化" class="headerlink" title="数据清洗脚本化"></a>数据清洗脚本化</h4><p>对于清洗代码具有固定规律，不太可能发生变化，则可以将整个清洗过程脚本化。</p><p>脚本化（scripting）的意思是，确定代码的结构，用于后续使用、学<br>习和分享。<br>Python 之禅不仅适用于编写代码，还适用于组织代码，函数、变量和类的命名，等等。最<br>好在选择命名上花点时间，判断哪些名字可以让你和他人都一目了然。注释和文档可以帮<br>助理解，但代码本身也应该具有较强的可读性。</p><p>通俗讲脚本化就是让代码能够长时间使用，过了若干时间后，依然奏效。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;数据归一化和标准化&quot;&gt;&lt;a href=&quot;#数据归一化和标准化&quot; class=&quot;headerlink&quot; title=&quot;数据归一化和标准化&quot;&gt;&lt;/a&gt;数据归一化和标准化&lt;/h4&gt;&lt;p&gt;数据归一化：归一化通常需要对数据集进行计算，使得数据都位于一个特定的范围。&lt;br&gt;简
      
    
    </summary>
    
      <category term="Python数据处理" scheme="http://example.com/categories/Python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
    
      <category term="Python" scheme="http://example.com/tags/Python/"/>
    
      <category term="数据处理" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python数据处理-阅读笔记二——数据清洗之匹配与格式化</title>
    <link href="http://example.com/wiki/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/Python/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(%E4%B8%89)/"/>
    <id>http://example.com/wiki/程序技术/Python/数据处理/python数据处理/python数据处理-阅读笔记(三)/</id>
    <published>2021-12-15T06:54:21.574Z</published>
    <updated>2021-12-16T07:05:04.670Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么要清洗数据"><a href="#为什么要清洗数据" class="headerlink" title="为什么要清洗数据"></a>为什么要清洗数据</h4><p>数据清洗可以让数据更容易存储，搜索和复用。通常我们获取到的数据可能会存在格式不一致的问题，由其是当数据来源于多个数据集的时候，需要对数据进行格式化处理。</p><h4 id="什么是数据清洗"><a href="#什么是数据清洗" class="headerlink" title="什么是数据清洗"></a>什么是数据清洗</h4><p>数据清洗也就是修改数据使其满足新的标准化数据格式。</p><h4 id="数据清洗过程"><a href="#数据清洗过程" class="headerlink" title="数据清洗过程"></a>数据清洗过程</h4><blockquote><ol><li>简单的目视分析，观察文件的结构</li></ol></blockquote><p>观察数据字段，寻找不一致的地方。</p><blockquote><ol><li>数据格式化</li></ol></blockquote><p>将杂乱无章的数据转化为可读性较强的格式。</p><blockquote><ol><li>找出离群值和不良数据</li></ol></blockquote><ol><li>离群值：也就是指和数据集不一致的数据。</li></ol><p>判断数据的有效性，通过过数据的来源来判断数据的偏差。对于获取的数据集，检查数据是否有不一致的地方？也就是说数据值里面是否存在错误。可以通过过遍历数据集，判断数据类型是否匹配，是否缺失数据。</p><p>类型离群值（type outlier）：如果存在数据的类型不匹配，则出现了类型离群值。如果要判断数据集中的类型离群情况，则可以对对应的字段进行分析，然后统计各个类型出现的次数，用于分析比对。</p><ol><li>重复值：重复的原始数据</li></ol><p>对于重复的数据一般需要删除。删除的方法可以考虑如下方法：</p><blockquote><ol><li><p>通过set集合进行去重</p></li><li><p>模糊匹配</p></li></ol></blockquote><p>通过模糊匹配进行寻找和合并重复值。脏数据可以是用户输入时粗心所造成的拼写和语法错误。<br>可以借助fuzzywuzzy库进行模糊匹配。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提供模糊匹配</span></span><br><span class="line"><span class="keyword">from</span> fuzzywuzzy <span class="keyword">import</span> fuzz</span><br><span class="line"><span class="keyword">from</span> fuzzywuzzy <span class="keyword">import</span> process</span><br><span class="line">my_records = [&#123;</span><br><span class="line">    <span class="string">&#x27;favorite_book&#x27;</span>: <span class="string">&#x27;Grapes of Wrath&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;favorite_movie&#x27;</span>: <span class="string">&#x27;Free Willie&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;favorite_show&#x27;</span>: <span class="string">&#x27;Two Broke Girls&#x27;</span>,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="string">&#x27;favorite_book&#x27;</span>: <span class="string">&#x27;The Grapes of Wrath&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;favorite_movie&#x27;</span>: <span class="string">&#x27;Free Williy&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;favorite_show&#x27;</span>: <span class="string">&#x27;2 Broke Girls&#x27;</span>,</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过fuzz模块的ratio函数，接受两个字符串作比较，返回两个字符串序列的相似程度(1-100)。</span></span><br><span class="line"><span class="built_in">print</span>(fuzz.ratio(my_records[<span class="number">0</span>].get(<span class="string">&#x27;favorite_book&#x27;</span>), my_records[<span class="number">1</span>].get(<span class="string">&#x27;favorite_book&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(fuzz.ratio(my_records[<span class="number">0</span>].get(<span class="string">&#x27;favorite_movie&#x27;</span>), my_records[<span class="number">1</span>].get(<span class="string">&#x27;favorite_movie&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(fuzz.ratio(my_records[<span class="number">0</span>].get(<span class="string">&#x27;favorite_show&#x27;</span>), my_records[<span class="number">1</span>].get(<span class="string">&#x27;favorite_show&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回更加准确的匹配结果（根据子字符串进行匹配），建议采用第一种匹配方法</span></span><br><span class="line"><span class="built_in">print</span>(fuzz.partial_ratio(my_records[<span class="number">0</span>].get(<span class="string">&#x27;favorite_book&#x27;</span>), my_records[<span class="number">1</span>].get(<span class="string">&#x27;favorite_book&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># token_sort_ratio函数，匹配字符串时，不考虑单词顺序。</span></span><br><span class="line">my_records = [&#123;<span class="string">&#x27;favorite_food&#x27;</span>: <span class="string">&#x27;cheeseburgers with bacon&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;favorite_drink&#x27;</span>: <span class="string">&#x27;wine, beer, and tequila&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;favorite_dessert&#x27;</span>: <span class="string">&#x27;cheese or cake&#x27;</span>,</span><br><span class="line">               &#125;,</span><br><span class="line">              &#123;<span class="string">&#x27;favorite_food&#x27;</span>: <span class="string">&#x27;burgers with cheese and bacon&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;favorite_drink&#x27;</span>: <span class="string">&#x27;beer, wine, and tequila&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;favorite_dessert&#x27;</span>: <span class="string">&#x27;cheese cake&#x27;</span>,</span><br><span class="line">               &#125;]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fuzz.token_sort_ratio(my_records[<span class="number">0</span>].get(<span class="string">&#x27;favorite_food&#x27;</span>), my_records[<span class="number">1</span>].get(<span class="string">&#x27;favorite_food&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(fuzz.token_set_ratio(my_records[<span class="number">0</span>].get(<span class="string">&#x27;favorite_food&#x27;</span>), my_records[<span class="number">1</span>].get(<span class="string">&#x27;favorite_food&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#对于有限选项的数据的匹配,返回的是最有可能的选项列表</span></span><br><span class="line"><span class="comment">#最佳匹配，通过extractone选择</span></span><br><span class="line">choice = [<span class="string">&#x27;Yes&#x27;</span>,<span class="string">&#x27;No&#x27;</span>,<span class="string">&#x27;Maybe&#x27;</span>,<span class="string">&#x27;N/A&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(process.extract(<span class="string">&#x27;ya&#x27;</span>,choice,limit=<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(process.extract(<span class="string">&#x27;ya&#x27;</span>,choice))</span><br><span class="line"><span class="built_in">print</span>(process.extract(<span class="string">&#x27;nope&#x27;</span>,choice,limit=<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(process.extract(<span class="string">&#x27;nope&#x27;</span>,choice))</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><ol><li>正则匹配</li></ol></blockquote><p>\w:匹配任意字母和数字和下划线。\d:匹配数字。\s:匹配任意一个空格。<br>+:匹配一个或多个模式或字符。.:匹配.字符。*:匹配零个或多个字符或模式。<br>|：匹配多个模式中的一个。[]或()：字符类和字符组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">word = <span class="string">&#x27;\w+&#x27;</span></span><br><span class="line">sentence = <span class="string">&#x27;Here is my sentence&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(re.findall(word,sentence)) <span class="comment">#任意位置开始匹配</span></span><br><span class="line">search_result = re.search(word,sentence) <span class="comment">#任意位置开始匹配</span></span><br><span class="line"><span class="built_in">print</span>(search_result.group())</span><br><span class="line">match_result = re.match(word,sentence) <span class="comment">#从字符串开头匹配</span></span><br><span class="line"><span class="built_in">print</span>(match_result.group())</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;为什么要清洗数据&quot;&gt;&lt;a href=&quot;#为什么要清洗数据&quot; class=&quot;headerlink&quot; title=&quot;为什么要清洗数据&quot;&gt;&lt;/a&gt;为什么要清洗数据&lt;/h4&gt;&lt;p&gt;数据清洗可以让数据更容易存储，搜索和复用。通常我们获取到的数据可能会存在格式不一致的问题，由
      
    
    </summary>
    
      <category term="Python数据处理" scheme="http://example.com/categories/Python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
    
      <category term="Python" scheme="http://example.com/tags/Python/"/>
    
      <category term="数据处理" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/wiki/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/Python/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BD%91%E7%AB%99/"/>
    <id>http://example.com/wiki/程序技术/Python/机器学习/深度学习/数据集网站/</id>
    <published>2021-12-15T06:34:25.387Z</published>
    <updated>2021-12-15T06:34:40.359Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>• UCI 机器学习数据集（<a href="http://archive.ics.uci.edu/ml/）">http://archive.ics.uci.edu/ml/）</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;• UCI 机器学习数据集（&lt;a href=&quot;http://archive.ics.uci.edu/ml/）&quot;&gt;http://archive.ics.uci.edu/ml/）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
      <category term="程序技术" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/Python/"/>
    
      <category term="机器学习" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/Python/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/Python/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>Python数据处理-阅读笔记二——数据获取和存储</title>
    <link href="http://example.com/wiki/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/Python/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(%E4%BA%8C)/"/>
    <id>http://example.com/wiki/程序技术/Python/数据处理/python数据处理-阅读笔记(二)/</id>
    <published>2021-12-15T05:39:44.566Z</published>
    <updated>2021-12-15T06:51:41.785Z</updated>
    
    <content type="html"><![CDATA[<p>数据处理的先决条件就是找到要研究的数据集。</p><p>数据集因该具备如下几个性质。</p><blockquote><ol><li>可信性</li></ol></blockquote><p>找到的数据集因该是可靠的，可信的。</p><blockquote><ol><li>真实性</li></ol></blockquote><p>找到的数据因该是真实的。</p><blockquote><ol><li>可读性</li></ol></blockquote><p>数据容易获取。</p><blockquote><ol><li>数据寿命</li></ol></blockquote><p>了解数据更新的频率。</p><h4 id="数据的获取方式"><a href="#数据的获取方式" class="headerlink" title="数据的获取方式"></a>数据的获取方式</h4><blockquote><ol><li>政府网站获取</li></ol></blockquote><p>如果需要分析研究某个城市或者某个国家的问题，可以通过政府网站寻找到相关的数据信息。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">• 开放城市项目（http://www.opencitiesproject.org/）</span><br><span class="line">• 开放尼泊尔（http://data.opennepal.net/）</span><br><span class="line">• 中国国家统计局（http://www.stats.gov.cn/english/）</span><br><span class="line">• 香港开放数据（https://opendatahk.com/）</span><br><span class="line">• 印尼政府开放数据（http://data.go.<span class="built_in">id</span>/</span><br><span class="line">• 加拿大统计数据（http://www.rdc-cdr.ca/datasets-<span class="keyword">and</span>-surveys）</span><br><span class="line">• 加拿大开放数据（http://<span class="built_in">open</span>.canada.ca/en）</span><br></pre></td></tr></table></figure></p><blockquote><ol><li>组织数据或非政府组织数据</li></ol></blockquote><p>如果需要获取某领域的数据，可以查看相关领域的组织机构是否提供了相应的数据。例如气候变化数据，国际商贸数据和全球运输数据等，可以通过国际组织进行信息数据的获取。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">• 联合国开放数据（http://data.un.org/）</span><br><span class="line">• 联合国发展计划署数据（http://<span class="built_in">open</span>.undp.org/）</span><br><span class="line">• 开放知识基金会（https://okfn.org/）</span><br><span class="line">• 世界银行数据（http://data.worldbank.org/）</span><br><span class="line">• 维基解密（https://wikileaks.org/）</span><br><span class="line">• 国际援助透明度数据集（http://www.iatiregistry.org/）</span><br><span class="line">• DataHub（https://datahub.io/）</span><br><span class="line">• 人口资料局（http://www.prb.org/DataFinder.aspx）</span><br></pre></td></tr></table></figure></p><blockquote><ol><li>教育数据和大学数据</li></ol></blockquote><p>通过世界各地大学和研究生部获取数据集。例如<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">• Lexis Nexis（http://www.lexisnexis.com/）</span><br><span class="line">• 谷歌学术搜索（https://scholar.google.com/）</span><br><span class="line">• 康奈尔大学 arXiv 项目（http://arxiv.org/）</span><br><span class="line">• UCI 机器学习数据集（http://archive.ics.uci.edu/ml/）</span><br><span class="line">• 通用数据集倡议（http://www.commondataset.org/）</span><br></pre></td></tr></table></figure></p><blockquote><ol><li>医学数据和科学数据</li></ol></blockquote><p>通过一些医学研究部门和组织可以获取优质的数据资源。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">• 开放科学数据云（https://www.opensciencedatacloud.org/publicdata/）</span><br><span class="line">• 开放科学目录（http://www.opensciencedirectory.net/）</span><br><span class="line">• 世界卫生组织数据（http://www.who.<span class="built_in">int</span>/gho/database/en/）</span><br><span class="line">• Broad 研究所开放数据（http://www.broadinstitute.org/scientific-community/data）</span><br><span class="line">• 人类连接组项目（神经通路映射）（http://www.humanconnectomeproject.org/）</span><br><span class="line">• UNC 精神病基因组协会（http://www.med.unc.edu/pgc/）</span><br><span class="line">• 社会科学数据集（http://3stages.org/idata/）</span><br><span class="line">• CDC 医学数据（http://www.cdc.gov/nchs/fastats/）</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><blockquote><ol><li>众包数据和API</li></ol></blockquote><p>一些社交网络和论坛能够提供大量的数据记录。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">• Broad 研究所开放数据（http://www.broadinstitute.org/scientific-community/data）</span><br><span class="line">• 人类连接组项目（神经通路映射）（http://www.humanconnectomeproject.org/）</span><br><span class="line">• UNC 精神病基因组协会（http://www.med.unc.edu/pgc/）</span><br><span class="line">• 社会科学数据集（http://3stages.org/idata/）</span><br><span class="line">• CDC 医学数据（http://www.cdc.gov/nchs/fastats/）</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="数据的存储"><a href="#数据的存储" class="headerlink" title="数据的存储"></a>数据的存储</h4><blockquote><ol><li>关系数据库</li></ol></blockquote><p>MySQL和PostgreSQL</p><blockquote><ol><li>非关系数据库</li></ol></blockquote><p>NoSQL和MongoDB</p><blockquote><ol><li>云存储</li></ol></blockquote><p>通过云服务器进行数据存储</p><blockquote><ol><li>其他数据存储</li></ol></blockquote><p>层次型数据格式(HDF)：HDF是基于文件的可扩展数据解决方案，可将大型数据库快速存储至文件系统(本地或其他位置)。</p><p>Hadoop:Hadoop是一个大数据分布式存储系统，可以跨集群存储并处理数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据处理的先决条件就是找到要研究的数据集。&lt;/p&gt;
&lt;p&gt;数据集因该具备如下几个性质。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;可信性&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;找到的数据集因该是可靠的，可信的。&lt;/p&gt;
&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="Python数据处理" scheme="http://example.com/categories/Python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
    
      <category term="Python" scheme="http://example.com/tags/Python/"/>
    
      <category term="数据处理" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/wiki/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/BUG%E9%9B%86%E9%94%A6/python/%E5%B8%B8%E8%A7%81/"/>
    <id>http://example.com/wiki/程序技术/BUG集锦/python/常见/</id>
    <published>2021-12-15T02:55:56.559Z</published>
    <updated>2021-12-15T02:57:30.633Z</updated>
    
    <content type="html"><![CDATA[<h4 id="xlrd读取xlsx文件失败-出现xlrd-biffh-XLRDError-Excel-xlsx-file；-not-supported错误"><a href="#xlrd读取xlsx文件失败-出现xlrd-biffh-XLRDError-Excel-xlsx-file；-not-supported错误" class="headerlink" title="xlrd读取xlsx文件失败,出现xlrd.biffh.XLRDError: Excel xlsx file； not supported错误"></a>xlrd读取xlsx文件失败,出现xlrd.biffh.XLRDError: Excel xlsx file； not supported错误</h4><p>原因是最近xlrd更新到了2.0版本，只支持.xls文件。所以读取xlsx需要下载旧版本在cmd中运行：<br>pip uninstall xlrd<br>pip install xlrd==1.2.0</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;xlrd读取xlsx文件失败-出现xlrd-biffh-XLRDError-Excel-xlsx-file；-not-supported错误&quot;&gt;&lt;a href=&quot;#xlrd读取xlsx文件失败-出现xlrd-biffh-XLRDError-Excel-xlsx-f
      
    
    </summary>
    
      <category term="程序技术" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/"/>
    
      <category term="BUG集锦" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/BUG%E9%9B%86%E9%94%A6/"/>
    
      <category term="python" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/BUG%E9%9B%86%E9%94%A6/python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python数据处理-阅读笔记一——数据处理介绍</title>
    <link href="http://example.com/wiki/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/Python/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <id>http://example.com/wiki/程序技术/Python/数据处理/python数据处理/python数据处理-阅读笔记(一)/</id>
    <published>2021-12-14T08:55:49.108Z</published>
    <updated>2021-12-17T01:04:15.832Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><p>数据处理是指将杂乱的或未加工的数据源转换成有用的信息。先寻找原始数据源，并判断<br>其价值：这些数据集的数据质量有多好？它们与你的目标是否相关？能否找到更好的数<br>据源？在对数据进行解析与清洗后，数据集变得可用，这时你可以利用工具和方法（如<br>Python 脚本）来帮你分析数据，并以报告的形式展示结果。这样你可以将无人问津的数据<br>变得清晰可用。</p><h4 id="数据处理的作用"><a href="#数据处理的作用" class="headerlink" title="数据处理的作用"></a>数据处理的作用</h4><p>通过编程进行分析数据，得出结论，并将结论清楚的传达给别人。</p><h4 id="数据处理的流程"><a href="#数据处理的流程" class="headerlink" title="数据处理的流程"></a>数据处理的流程</h4><p>分析问题-&gt;收集数据，数据存储-&gt;数据清洗(研究，匹配，格式化，归一化和标准化，脚本化)-&gt;数据分析</p><p><img src="/images/datawranling/数据清洗.PNG" alt="a1"></p><h4 id="常见格式化数据"><a href="#常见格式化数据" class="headerlink" title="常见格式化数据"></a>常见格式化数据</h4><ol><li>CSV数据</li></ol><p>CSV文件是指将数据列用逗号分隔的文件，文件的扩展名是.csv。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CSV数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csv</span>():</span></span><br><span class="line">    <span class="keyword">import</span> csv</span><br><span class="line">    <span class="comment">#读取csv文件</span></span><br><span class="line">    csvfile = <span class="built_in">open</span>(<span class="string">&#x27;data-text.csv&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">    reader = csv.reader(csvfile)</span><br><span class="line">    <span class="comment"># 以字典形式读取</span></span><br><span class="line">    reader = csv.DictReader(csvfile)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        <span class="built_in">print</span>(row)</span><br><span class="line">    <span class="comment">#保存csv文件</span></span><br><span class="line">    header = [<span class="string">&#x27;colname&#x27;</span>,<span class="string">&#x27;colname&#x27;</span>]</span><br><span class="line">    content = [(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">3</span>)]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data-text.csv&#x27;</span>,<span class="string">&#x27;w+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        csvwrite = csv.writer(f)</span><br><span class="line">        csvwrite.writerow(header)</span><br><span class="line">        csvwrite.writerows(content)</span><br></pre></td></tr></table></figure></p><ol><li>JSON数据</li></ol><p>JSON数据是数据传输最常用的格式之一。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># JSON数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">JSON</span>():</span></span><br><span class="line">    <span class="comment"># JSON数据读取</span></span><br><span class="line">    json_data = <span class="built_in">open</span>(<span class="string">&#x27;data-text.json&#x27;</span>).read()</span><br><span class="line">    data = json.loads(json_data)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> data:</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line">    <span class="comment">#JSON数据保存</span></span><br><span class="line">    datas = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data-text.json&#x27;</span>,<span class="string">&#x27;w+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        json.dump(datas,f)</span><br></pre></td></tr></table></figure></p><ol><li>XML数据</li></ol><p>XML 是一种标记语言，也就是说，它具有包含格式化数据的文档结构。<br>XML 文档本质上只是格式特殊的数据文件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#XML数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">XML</span>():</span></span><br><span class="line">    <span class="comment">#读取XML文件</span></span><br><span class="line">    <span class="keyword">from</span> xml.etree <span class="keyword">import</span> ElementTree <span class="keyword">as</span> ET</span><br><span class="line">    tree = ET.parse(<span class="string">&#x27;data-text.xml&#x27;</span>)</span><br><span class="line">    root = tree.getroot()</span><br><span class="line">    data  = root.find(<span class="string">&#x27;data&#x27;</span>)</span><br><span class="line">    all_data = []</span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> data:</span><br><span class="line">        record = &#123;&#125;</span><br><span class="line">        <span class="comment">#获取标签属性</span></span><br><span class="line">        <span class="built_in">print</span>(d.attrib.keys()[<span class="number">0</span>])</span><br><span class="line">        <span class="built_in">print</span>(d.attrib[<span class="string">&#x27;key&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><ol><li>Excel文件</li></ol><p>Python解析Excel文件使用的是xlrd库(读取Excel文件),xlwt(向Excel文件写入，并设置格式)。xlutils(一组Excel高级操作工具，需要安装xlrd和xlwt)。</p><p>Excel文件的读取，首先要确定在哪个表(sheet)。然后根据表可以获取表内的数据。</p><blockquote><p>打开Excel文件<br>book = xlrd.open_workbook()<br>获取工作表对象<br>sheet = book.sheet_by_name(表名称)<br>获取数据</p><h1 id="获取工作表的总行数"><a href="#获取工作表的总行数" class="headerlink" title="获取工作表的总行数"></a>获取工作表的总行数</h1><p>print(sheet.nrows)</p><h1 id="遍历工作表的每一行"><a href="#遍历工作表的每一行" class="headerlink" title="遍历工作表的每一行"></a>遍历工作表的每一行</h1><p>for i in range(sheet.nrows):<br>    print(sheet.row_values(i))<br>实例代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#解析Excel文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Excel</span>():</span></span><br><span class="line">    <span class="keyword">import</span> xlrd</span><br><span class="line">    <span class="keyword">import</span> xlwt</span><br><span class="line">    <span class="keyword">import</span> xlutils</span><br><span class="line">    <span class="comment">#读取xlsx数据</span></span><br><span class="line">    book = xlrd.open_workbook(<span class="string">&#x27;1.xlsx&#x27;</span>)</span><br><span class="line">    <span class="comment">#Excel工作簿可以有多个标签(tab)或工作表(sheet)</span></span><br><span class="line">    <span class="comment">#所以需要找到包含目标数据的工作表</span></span><br><span class="line">    <span class="comment">#获取工作表名称</span></span><br><span class="line">    <span class="keyword">for</span> sheet <span class="keyword">in</span> book.sheets():</span><br><span class="line">        <span class="built_in">print</span>(sheet.name)</span><br><span class="line">    <span class="comment">#根据工作表名称，获取工作表对象</span></span><br><span class="line">    sheet = book.sheet_by_name(<span class="string">&#x27;Table 9 &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(sheet)</span><br><span class="line">    <span class="comment">#获取工作表的总行数</span></span><br><span class="line">    <span class="built_in">print</span>(sheet.nrows)</span><br><span class="line">    <span class="comment">#遍历工作表的每一行</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(sheet.nrows):</span><br><span class="line">        <span class="comment">#print(sheet.row_values(i))</span></span><br><span class="line">        row = sheet.row_values(i)</span><br><span class="line">        <span class="comment">#读取列数据</span></span><br><span class="line">        <span class="keyword">for</span> cell <span class="keyword">in</span> row:</span><br><span class="line">            <span class="built_in">print</span>(cell)</span><br></pre></td></tr></table></figure></p></blockquote><ol><li>PDF文件</li></ol><p>通过PyPDF2模块进行读取pdf，但是只能够读取文本。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PDF</span>():</span></span><br><span class="line">    <span class="keyword">import</span> PyPDF2</span><br><span class="line">    <span class="comment">#读取PDF</span></span><br><span class="line">    pdffile = <span class="built_in">open</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    pdfreader = PyPDF2.PdfFileReader(pdffile)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;页数&#x27;</span>+<span class="built_in">str</span>(pdfreader.pages))</span><br><span class="line">    <span class="built_in">print</span>(pdfreader.getPage(<span class="number">0</span>))<span class="comment">#获取第一页内容</span></span><br><span class="line">    <span class="built_in">print</span>(pdfreader.getPage(<span class="number">0</span>).extractText())<span class="comment">#获取第二页内容</span></span><br><span class="line">    <span class="comment">#写入PDF </span></span><br><span class="line">    pdfwriter = PyPDF2.PdfFileWriter()</span><br><span class="line">    pdfwriter.addPage(<span class="string">&#x27;adadad&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.pdf&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> wf:</span><br><span class="line">        pdfwriter.write(wf)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;数据处理&quot;&gt;&lt;a href=&quot;#数据处理&quot; class=&quot;headerlink&quot; title=&quot;数据处理&quot;&gt;&lt;/a&gt;数据处理&lt;/h4&gt;&lt;p&gt;数据处理是指将杂乱的或未加工的数据源转换成有用的信息。先寻找原始数据源，并判断&lt;br&gt;其价值：这些数据集的数据质量有多好？它
      
    
    </summary>
    
      <category term="Python数据处理" scheme="http://example.com/categories/Python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
    
      <category term="Python" scheme="http://example.com/tags/Python/"/>
    
      <category term="数据处理" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>CV2问题集锦</title>
    <link href="http://example.com/wiki/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/BUG%E9%9B%86%E9%94%A6/python/cv2/"/>
    <id>http://example.com/wiki/程序技术/BUG集锦/python/cv2/</id>
    <published>2021-12-14T02:26:49.895Z</published>
    <updated>2021-12-14T02:29:39.514Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-关于cv2-imshow不显示，一闪而过的问题"><a href="#1-关于cv2-imshow不显示，一闪而过的问题" class="headerlink" title="1.  关于cv2.imshow不显示，一闪而过的问题"></a>1.  关于cv2.imshow不显示，一闪而过的问题</h4><p>我们在使用cv2显示图片的时候，一定要加上cv2.waitKey进行等待图片，否则会不显示。示例代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">img = cv.imread(<span class="string">&quot;1.jpg&quot;</span>)  <span class="comment"># 图像读取</span></span><br><span class="line">x,y = img.shape[:<span class="number">2</span>] <span class="comment">#获取图片的高和宽</span></span><br><span class="line"><span class="comment"># 创建一个窗口</span></span><br><span class="line">cv.namedWindow(<span class="string">&#x27;test&#x27;</span>,cv.WINDOW_NORMAL) <span class="comment"># 通过cv.WINDOW_NORMAL可以完整显示图片</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;test&#x27;</span>,img) <span class="comment"># 显示图片</span></span><br><span class="line">cv.waitKey(<span class="number">0</span>) <span class="comment"># 等待键盘输入，0表示无限等待，如果不调用waitKey窗口就会一闪而过，看不到任何图片</span></span><br><span class="line">cv.destroyAllWindows() <span class="comment"># 销毁所有串口</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-关于cv2-imshow不显示，一闪而过的问题&quot;&gt;&lt;a href=&quot;#1-关于cv2-imshow不显示，一闪而过的问题&quot; class=&quot;headerlink&quot; title=&quot;1.  关于cv2.imshow不显示，一闪而过的问题&quot;&gt;&lt;/a&gt;1.  关于cv2
      
    
    </summary>
    
      <category term="Bug" scheme="http://example.com/categories/Bug/"/>
    
    
      <category term="Bug" scheme="http://example.com/tags/Bug/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/wiki/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/BUG%E9%9B%86%E9%94%A6/vsnode/"/>
    <id>http://example.com/wiki/程序技术/BUG集锦/vsnode/</id>
    <published>2021-12-14T00:54:21.517Z</published>
    <updated>2021-12-14T00:54:21.517Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="程序技术" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/"/>
    
      <category term="BUG集锦" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/BUG%E9%9B%86%E9%94%A6/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/wiki/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/BUG%E9%9B%86%E9%94%A6/idea/"/>
    <id>http://example.com/wiki/程序技术/BUG集锦/idea/</id>
    <published>2021-12-14T00:54:13.967Z</published>
    <updated>2021-12-14T00:54:13.967Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="程序技术" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/"/>
    
      <category term="BUG集锦" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/BUG%E9%9B%86%E9%94%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>Pycharm问题集锦</title>
    <link href="http://example.com/wiki/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/BUG%E9%9B%86%E9%94%A6/python/Pycharm/"/>
    <id>http://example.com/wiki/程序技术/BUG集锦/python/Pycharm/</id>
    <published>2021-12-14T00:54:06.688Z</published>
    <updated>2021-12-14T02:26:43.462Z</updated>
    
    <content type="html"><![CDATA[<h5 id="Pycharm误删代码如何恢复"><a href="#Pycharm误删代码如何恢复" class="headerlink" title="Pycharm误删代码如何恢复"></a>Pycharm误删代码如何恢复</h5><p>在误删代码的父文件夹上，点击鼠标右键，找到Local History，点击后即可找到之前的代码，根据情况进行恢复(Revert)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;Pycharm误删代码如何恢复&quot;&gt;&lt;a href=&quot;#Pycharm误删代码如何恢复&quot; class=&quot;headerlink&quot; title=&quot;Pycharm误删代码如何恢复&quot;&gt;&lt;/a&gt;Pycharm误删代码如何恢复&lt;/h5&gt;&lt;p&gt;在误删代码的父文件夹上，点击鼠标右键
      
    
    </summary>
    
      <category term="Bug" scheme="http://example.com/categories/Bug/"/>
    
    
      <category term="Bug" scheme="http://example.com/tags/Bug/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/wiki/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/BUG%E9%9B%86%E9%94%A6/python/%E7%88%AC%E8%99%AB/"/>
    <id>http://example.com/wiki/程序技术/BUG集锦/python/爬虫/</id>
    <published>2021-12-14T00:53:54.425Z</published>
    <updated>2021-12-14T02:26:43.332Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="程序技术" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/"/>
    
      <category term="BUG集锦" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/BUG%E9%9B%86%E9%94%A6/"/>
    
      <category term="python" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/BUG%E9%9B%86%E9%94%A6/python/"/>
    
    
  </entry>
  
  <entry>
    <title>CV2的常用方法</title>
    <link href="http://example.com/wiki/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/Python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/CV2/"/>
    <id>http://example.com/wiki/程序技术/Python/图像处理/CV2/</id>
    <published>2021-12-13T07:33:05.449Z</published>
    <updated>2021-12-14T02:26:23.639Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-图片读取显示"><a href="#1-图片读取显示" class="headerlink" title="1. 图片读取显示"></a>1. 图片读取显示</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">img = cv.imread(<span class="string">&quot;1.jpg&quot;</span>)  <span class="comment"># 图像读取</span></span><br><span class="line">x,y = img.shape[:<span class="number">2</span>] <span class="comment">#获取图片的高和宽</span></span><br><span class="line"><span class="comment"># 创建一个窗口</span></span><br><span class="line">cv.namedWindow(<span class="string">&#x27;test&#x27;</span>,cv.WINDOW_NORMAL) <span class="comment"># 通过cv.WINDOW_NORMAL可以完整显示图片</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;test&#x27;</span>,img) <span class="comment"># 显示图片</span></span><br><span class="line">cv.waitKey(<span class="number">0</span>) <span class="comment"># 等待键盘输入，0表示无限等待，如果不调用waitKey窗口就会一闪而过，看不到任何图片</span></span><br><span class="line">cv.destroyAllWindows() <span class="comment"># 销毁所有串口</span></span><br></pre></td></tr></table></figure><h4 id="2-图片的操作-修改图片大小"><a href="#2-图片的操作-修改图片大小" class="headerlink" title="2. 图片的操作-修改图片大小"></a>2. 图片的操作-修改图片大小</h4><p>通过cv2.resize可以修改图片的大小，指定尺寸size（宽，高）,并且可以指定插入方式，不同插入方式得到的缩放图片的效果不一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">img = cv.imread(<span class="string">&quot;1.jpg&quot;</span>)</span><br><span class="line">x, y = img.shape[:<span class="number">2</span>]  <span class="comment"># 获取图片的高和宽</span></span><br><span class="line"><span class="comment"># 输出尺寸为(宽，高)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">cv2.resize(InputArray src, OutputArray dst, Size, fx, fy, interpolation)</span></span><br><span class="line"><span class="string">InputArray src： 输入图片</span></span><br><span class="line"><span class="string">InputArray src:  输出图片</span></span><br><span class="line"><span class="string">Size: 输出图片尺寸(宽，高)</span></span><br><span class="line"><span class="string">fx,fy:沿x轴，y轴的缩放系数</span></span><br><span class="line"><span class="string">interpolation:插入方式</span></span><br><span class="line"><span class="string">插入方式有如下几种：</span></span><br><span class="line"><span class="string">INTER_NEAREST：最近邻插值</span></span><br><span class="line"><span class="string">INTER_LINEAR：双线性插值（默认设置）</span></span><br><span class="line"><span class="string">INTER_AREA:使用像素区域关系进行重采样。</span></span><br><span class="line"><span class="string">INTER_CUBIC:4x4像素邻域的双三次插值</span></span><br><span class="line"><span class="string">INTER_LANCZOS4:8x8像素邻域的Lanczos插值</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">img1 = cv.resize(img,(<span class="built_in">int</span>(y/<span class="number">4</span>),<span class="built_in">int</span>(x/<span class="number">4</span>))) <span class="comment"># 修改图片大小，缩放为原来的1/4</span></span><br><span class="line"><span class="comment">#cv.namedWindow(&#x27;test&#x27;,cv.WINDOW_NORMAL)</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;test&#x27;</span>,img1)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br><span class="line">img2 = cv.resize(img,(<span class="number">0</span>,<span class="number">0</span>),fx=<span class="number">0.25</span>,fy=<span class="number">0.25</span>,interpolation=cv.INTER_AREA)</span><br><span class="line">cv.imshow(<span class="string">&#x27;test&#x27;</span>, img2)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-图片的操作-灰度化"><a href="#3-图片的操作-灰度化" class="headerlink" title="3. 图片的操作-灰度化"></a>3. 图片的操作-灰度化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">img = cv.imread(<span class="string">&quot;1.jpg&quot;</span>)</span><br><span class="line">img_gray = cv.cvtColor(img,cv.COLOR_BGR2GRAY) <span class="comment"># 灰度化</span></span><br><span class="line">cv.namedWindow(<span class="string">&#x27;test&#x27;</span>, cv.WINDOW_NORMAL)</span><br><span class="line">cv.imshow(<span class="string">&#x27;test&#x27;</span>, img_gray)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-图片读取显示&quot;&gt;&lt;a href=&quot;#1-图片读取显示&quot; class=&quot;headerlink&quot; title=&quot;1. 图片读取显示&quot;&gt;&lt;/a&gt;1. 图片读取显示&lt;/h4&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="Python" scheme="http://example.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://example.com/tags/Python/"/>
    
      <category term="图像处理" scheme="http://example.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>滑块验证码破解</title>
    <link href="http://example.com/wiki/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/Python/%E7%88%AC%E8%99%AB/%E6%BB%91%E5%9D%97%E7%A0%B4%E8%A7%A3/"/>
    <id>http://example.com/wiki/程序技术/Python/爬虫/滑块破解/</id>
    <published>2021-12-13T07:01:04.559Z</published>
    <updated>2021-12-14T02:05:21.794Z</updated>
    
    <content type="html"><![CDATA[<h4 id="滑块验证码破解"><a href="#滑块验证码破解" class="headerlink" title="滑块验证码破解"></a>滑块验证码破解</h4><p>最近在爬虫开发的过程中，遇到了关于滑块验证码，需要进行滑块验证码破解。这里涉及到图像方面的技术，可以借助OpenCV进行解决。</p><h4 id="通过CV2解决滑块验证"><a href="#通过CV2解决滑块验证" class="headerlink" title="通过CV2解决滑块验证"></a>通过CV2解决滑块验证</h4><p>这里通过CV2库进行滑块验证的解决。简单介绍一下滑块验证的几个步骤。</p><h5 id="1-获取图片（不带缺口的图片，带缺口的图片）"><a href="#1-获取图片（不带缺口的图片，带缺口的图片）" class="headerlink" title="1. 获取图片（不带缺口的图片，带缺口的图片）"></a>1. 获取图片（不带缺口的图片，带缺口的图片）</h5><p>根据网页，获取到滑块图片，一般来说分为两个图片，一个是缺口图，也就是缺少缺口的图片。一个是滑块图，也就是缺口图缺少的图片。假设缺口图为img1,滑块图为img2。<br>img1:<br><img src="/images/spider/s1.PNG" alt="img1"></p><p>img2:<br><img src="/images/spider/s2.PNG" alt="img2"></p><h5 id="2-识别缺口位置，计算滑动距离"><a href="#2-识别缺口位置，计算滑动距离" class="headerlink" title="2. 识别缺口位置，计算滑动距离"></a>2. 识别缺口位置，计算滑动距离</h5><p>一般而言，我们通过网页获取到的图片和实际在网页上显示的图片大小是不一致的。读者可以根据自己需要破解的滑块验证码进行校验。查看在网页中的图片大小和下载的图片大小是否一致。如果不一致，那么需要跳转下载的图片的大小。<br>读取图片，然后跳转图片的大小为网页中显示的大小。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">img1 = cv2.imread(缺口图的路径)</span><br><span class="line">img1 = cv2.resize(img1, (网页缺口图实际宽度, 网页缺口图实际高度))</span><br><span class="line">img2 = cv2.imread(缺块图的路径)</span><br><span class="line">img2 = cv2.resize(img2, (网页缺块图实际宽度, 网页缺块图实际高度))</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>如果要识别缺口位置，可以借助cv2库的matchTemplate方法来获取缺块距离缺口的位置。实现代码如下所示，一般来说这种方法识别会带有误差，也就是存在失败的情况，这个时候可以在程序中进行设置，进行多次尝试解决滑块验证(可以采用循环处理的办法，重复多次滑块验证解决流程)，以达到解决滑块问题的效果。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img1_gray = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY) # 对图片灰度化处理</span><br><span class="line">img2_gray = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)# 对图片灰度化处理</span><br><span class="line">res = cv2.matchTemplate(img1_gray, img2_gray, cv2.TM_CCOEFF_NORMED) </span><br><span class="line">value = cv2.minMaxLoc(res)  #获取缺口和缺块的距离</span><br><span class="line">value = value[3][0] #value值就是缺块距离缺口的距离</span><br></pre></td></tr></table></figure></p><h5 id="3-模拟运动"><a href="#3-模拟运动" class="headerlink" title="3. 模拟运动"></a>3. 模拟运动</h5><p>我们可以借助selenium进行模拟滑块拖动的过程，但是在模拟滑块的拖动过程中，需要模拟人的速度。人在拖动滑块的时候，正常是先快后慢的过程，这个时候我们可以设置一个先快后慢的过程（可以设置两个运动方程，一段加速度为a1,一段加速度为a2），用于模拟人拖动滑块。示例代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ditance为移动的距离，也就是上面获得的value</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTrack</span>(<span class="params">self,distance</span>):</span></span><br><span class="line">    <span class="comment">#用于存储每个过程中，拉动滑块的距离</span></span><br><span class="line">    track = []</span><br><span class="line">    <span class="comment"># 当前位移</span></span><br><span class="line">    current = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 当距离超过什么时候，进行减速</span></span><br><span class="line">    mid = distance * <span class="number">4</span> / <span class="number">5</span></span><br><span class="line">    <span class="comment"># 计算间隔</span></span><br><span class="line">    t = <span class="number">0.2</span></span><br><span class="line">    <span class="comment"># 初速度</span></span><br><span class="line">    v = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> current &lt; distance:</span><br><span class="line">        <span class="keyword">if</span> current &lt; mid:</span><br><span class="line">            <span class="comment"># 加速度为正2</span></span><br><span class="line">            a = <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 加速度为负3</span></span><br><span class="line">            a = -<span class="number">3</span></span><br><span class="line">        <span class="comment"># 初速度v0</span></span><br><span class="line">        v0 = v</span><br><span class="line">        <span class="comment"># 当前速度v = v0 + at</span></span><br><span class="line">        v = v0 + a * t</span><br><span class="line">        <span class="comment"># 移动距离x = v0t + 1/2 * a * t^2</span></span><br><span class="line">        move = v0 * t + <span class="number">1</span> / <span class="number">2</span> * a * t * t</span><br><span class="line">        <span class="comment"># 当前位移</span></span><br><span class="line">        current += move</span><br><span class="line">        <span class="comment"># 加入轨迹</span></span><br><span class="line">        track.append(<span class="built_in">round</span>(move))</span><br><span class="line">    <span class="keyword">return</span> track</span><br></pre></td></tr></table></figure><p>通过selenium模拟运动，可以借助ActionChains来拖拽滑块。首先我们需要获取到滑块元素。<br>这个我们可以通过F12来查看拖拽滑块元素的属性，然后通过driver获取到元素。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ActionChains(driver).click_and_hold(拖拽滑块的元素).perform() <span class="comment"># 点击并且不释放鼠标</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> track:     <span class="comment"># 根据轨迹，移动元素</span></span><br><span class="line">    ActionChains(driver).move_by_offset(xoffset=x, yoffset=<span class="number">0</span>).perform() <span class="comment">#移动元素</span></span><br><span class="line">time.sleep(<span class="number">0.5</span>) </span><br><span class="line">ActionChains(driver).release().perform() <span class="comment">#释放元素</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;滑块验证码破解&quot;&gt;&lt;a href=&quot;#滑块验证码破解&quot; class=&quot;headerlink&quot; title=&quot;滑块验证码破解&quot;&gt;&lt;/a&gt;滑块验证码破解&lt;/h4&gt;&lt;p&gt;最近在爬虫开发的过程中，遇到了关于滑块验证码，需要进行滑块验证码破解。这里涉及到图像方面的技术，可以
      
    
    </summary>
    
      <category term="爬虫" scheme="http://example.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="http://example.com/tags/Python/"/>
    
      <category term="爬虫" scheme="http://example.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Web项目部署</title>
    <link href="http://example.com/wiki/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/Java/JavaWeb/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    <id>http://example.com/wiki/程序技术/Java/JavaWeb/项目部署/</id>
    <published>2021-12-10T09:31:23.397Z</published>
    <updated>2021-12-13T01:22:04.658Z</updated>
    
    <content type="html"><![CDATA[<ol><li>安装Tomcat</li></ol><blockquote><ol><li>通过 tar -zxvf 解压tomcat。</li><li>修改catalina.sh，在脚本开头增加export JAVA_HOME指定jdk路径。</li></ol></blockquote><p>修改Tomcat的端口：<br>将8080，8005，8009修改其它端口即可。<br> <Connector port="8080"               maxThreads="150" minSpareThreads="25" maxSpareThreads="75"               enableLookups="false" redirectPort="8443" acceptCount="100"               connectionTimeout="20000" disableUploadTimeout="true" /></p><Server port="8005" shutdown="SHUTDOWN"><Connector port="8009" protocol="AJP/1.3" redirectPort="8443"/><ol><li>下载jdk</li></ol><p>下载jdk，然后通过tar -zxvf 进行解压jdk</p><ol><li>打包项目</li></ol><p>将项目打包war包，然后放入到tomcat的webapp目录下即可。</p><blockquote><ol><li>访问路径</li></ol></blockquote><p>将War包包放到webapp下之后，访问路径的名称就是war包的名称，假设war包为AAA.war,部署端口为8080.<br>ip地址为xxx.xxx.xxx则访问路径为：<a href="https://xxx.xxx.xxx/AAA。">https://xxx.xxx.xxx/AAA。</a></p><blockquote><ol><li>报错解决</li></ol></blockquote><h3 id="Cannot-find-usr-tomcat-tomcat9-bin-setclasspath-sh"><a href="#Cannot-find-usr-tomcat-tomcat9-bin-setclasspath-sh" class="headerlink" title="Cannot find /usr/tomcat/tomcat9/bin/setclasspath.sh"></a>Cannot find /usr/tomcat/tomcat9/bin/setclasspath.sh</h3><p>执行：unset CATALINA_HOME</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;安装Tomcat&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;通过 tar -zxvf 解压tomcat。&lt;/li&gt;
&lt;li&gt;修改catalina.sh，在脚本开头增加export JAVA_HOME指定jdk路径。&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://example.com/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://example.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>反爬技巧</title>
    <link href="http://example.com/wiki/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/Python/%E7%88%AC%E8%99%AB/%E5%8F%8D%E7%88%AC%E6%8A%80%E5%B7%A7/"/>
    <id>http://example.com/wiki/程序技术/Python/爬虫/反爬技巧/</id>
    <published>2021-12-10T08:19:06.344Z</published>
    <updated>2021-12-10T08:21:56.064Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>这里主要总结了一些爬虫开发过程中的反爬技巧。</p><blockquote><ol><li>正确设置headers</li></ol></blockquote><p>通常我们简单设置一下User-Agent就能够获取到网页内容。但是对于一些网站，通过request获取到的网页内容，通常又和正常访问网页获取到的内容不一致。这里就需要根据网页的Headers来设置request内的headers属性，用于避免被检测。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;这里主要总结了一些爬虫开发过程中的反爬技巧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;正确设置headers&lt;/li&gt;
&lt;/ol
      
    
    </summary>
    
      <category term="爬虫" scheme="http://example.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="http://example.com/tags/Python/"/>
    
      <category term="爬虫" scheme="http://example.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>debug反爬</title>
    <link href="http://example.com/wiki/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/Python/%E7%88%AC%E8%99%AB/debug%E5%8F%8D%E7%88%AC/"/>
    <id>http://example.com/wiki/程序技术/Python/爬虫/debug反爬/</id>
    <published>2021-12-10T07:01:24.965Z</published>
    <updated>2021-12-10T07:08:39.363Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关于解决-function-anonymous-debugger-的问题"><a href="#关于解决-function-anonymous-debugger-的问题" class="headerlink" title="关于解决(function anonymous() {debugger})的问题"></a>关于解决(function anonymous() {debugger})的问题</h4><h5 id="1-实现原理"><a href="#1-实现原理" class="headerlink" title="1. 实现原理"></a>1. 实现原理</h5><p>如何实现无限debugger呢？实现无限debugger就是不断的打断你，页面跳转到source页面，阻止你看内容。<br>写一个不断调用debugger即可。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="keyword">debugger</span>; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>() - a &gt; <span class="number">100</span>;&#125;())</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h5 id="2-问题解决"><a href="#2-问题解决" class="headerlink" title="2. 问题解决"></a>2. 问题解决</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;关于解决-function-anonymous-debugger-的问题&quot;&gt;&lt;a href=&quot;#关于解决-function-anonymous-debugger-的问题&quot; class=&quot;headerlink&quot; title=&quot;关于解决(function anonym
      
    
    </summary>
    
      <category term="爬虫" scheme="http://example.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="http://example.com/tags/Python/"/>
    
      <category term="爬虫" scheme="http://example.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫-Scrapy进阶</title>
    <link href="http://example.com/wiki/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/Python/%E7%88%AC%E8%99%AB/Python%E7%88%AC%E8%99%AB-Scrapy%E8%BF%9B%E9%98%B6/"/>
    <id>http://example.com/wiki/程序技术/Python/爬虫/Python爬虫-Scrapy进阶/</id>
    <published>2021-12-09T09:00:55.657Z</published>
    <updated>2021-12-14T08:49:51.577Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Spider模块"><a href="#1-Spider模块" class="headerlink" title="1.Spider模块"></a><a href="#one">1.Spider模块</a></h3><h3 id="2-Item-Loader"><a href="#2-Item-Loader" class="headerlink" title="2.Item Loader"></a><a href="#two">2.Item Loader</a></h3><h3 id="3-请求与响应"><a href="#3-请求与响应" class="headerlink" title="3.请求与响应"></a><a href="#three">3.请求与响应</a></h3><h2 id="深入Scrapy爬虫框架"><a href="#深入Scrapy爬虫框架" class="headerlink" title="深入Scrapy爬虫框架"></a>深入Scrapy爬虫框架</h2><h3 id="1-Spider模块-1"><a href="#1-Spider模块-1" class="headerlink" title="1. Spider模块"></a><a id="one"></a>1. Spider模块</h3><p>Spider模块是定义爬虫的动作及分析网页结构的地方，我们容易看出，在这里给出了解析网页获取元素，并进行是否继续爬取下一个网页的操作(也就是爬虫的动作)。Spider的执行流程</p><blockquote><ol><li><p>从入口URL初始化Request并设置回调函数。这个Reuquest下载完毕返回Response，并作为参数传送给回调函数，Spider初始的Request是通过调用start_requests()方法获取。start_requests()读取start_urls中的URL，并以parse为回调函数生成Request。也就是说初始的URL，只需要在start_urls加入，系统会自动的获取response，并以parse()为解析函数。</p></li><li><p>在回调函数分析Response，返回Item对象，dict,ruquest或者一个包括三者的可迭代容器。其中返回的Request对象会经过Scrapy处理，下载相应内容，并调用设置相应的解析函数。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request = scrapy.Request(url=url,callback=self.parse_body) <span class="comment">#调用Request方法，并设置解析函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在解析函数内，可以使用页面解析技术，对页面元素进行解析，可以用BeautifuleSoup等等技术。通过response可以获取到响应的内容。将分析的数据生成item</p></li><li><p>由spider返回item,可以经过Item Pipeline被存到数据库或使用Feed exports存入到文件中。</p></li></ol></blockquote><h5 id="Spider类的成员变量"><a href="#Spider类的成员变量" class="headerlink" title="Spider类的成员变量"></a>Spider类的成员变量</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"> @:param name 定义spider名字的字符串，名字必须唯一。可以生成多个相同的spider实例</span></span><br><span class="line"><span class="string"> 通常可以用网站域名命名spider</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> @:param allowed_domains: 包含了spder允许爬取的域名列表。</span></span><br><span class="line"><span class="string"> 当OffsiteMiddleware组件启用时，域名不在列表中的URL不会被跟进。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> @:param statr_urls:URL列表，当没有配置statr_requests9）f方法的时候，spider会从该列表开始进行爬取。也就是说爬虫开始爬取的</span></span><br><span class="line"><span class="string"> URL就是从start_urls中获取。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> @:param custom_setting：该设置是一个dict,当启动spider时，该设置将会覆盖项目级的设置。也就是</span></span><br><span class="line"><span class="string"> 说可以在这里对spider单独定义。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> @:param crawler 该属性在初始化class后，由类方法from_crawler()设置。并且链接了</span></span><br><span class="line"><span class="string"> 本spider实例羽Crawler对象。</span></span><br><span class="line"><span class="string"> &#x27;&#x27;&#x27;</span></span><br><span class="line"> name = <span class="string">&#x27;myspider&#x27;</span></span><br><span class="line"> allowed_domains = [<span class="string">&quot;www.baidu.com&quot;</span>]</span><br><span class="line"> start_urls = [</span><br><span class="line">     <span class="string">&quot;https://www.baidu.com&quot;</span></span><br><span class="line"> ]</span><br><span class="line"> custom_settings = &#123;&#125;</span><br><span class="line"> crawler = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Spider类的方法"><a href="#Spider类的方法" class="headerlink" title="Spider类的方法"></a>Spider类的方法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常用的Spider方法</span></span><br><span class="line"><span class="comment"># 该方法必须返回一个可迭代对象，对象包含spider用于爬虫的第一个request。</span></span><br><span class="line"><span class="comment"># 也就是说 start_requests是项目启动的开始，是根据start_url作为项目启动URL</span></span><br><span class="line"><span class="comment"># 如果没有设置start_requests方法，就会默认从start_urls的url生成Request。</span></span><br><span class="line"><span class="comment"># 如果需要定制最初爬取的Request对象，可以重写方法。</span></span><br><span class="line"><span class="comment"># 例如通过POST登录</span></span><br><span class="line"><span class="comment"># 总结来说：strt_request就是整个程序的入口，如果不指定就是直接从start_ruls中获取url，以parse()为回调函数进行解析。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_requests</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [scrapy.FormRequest(<span class="string">&quot;http://www.example.com/login&quot;</span>,formdata=&#123;</span><br><span class="line">        <span class="string">&#x27;user&#x27;</span>:<span class="string">&#x27;john&#x27;</span>,<span class="string">&#x27;pass&#x27;</span>:<span class="string">&#x27;secret&#x27;</span></span><br><span class="line">    &#125;,callback=self.login)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># start_requests对url请求后的响应，会通过login进行处理</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">self,response</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_requests_from_url</span>(<span class="params">self, url</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    接受一个URL并返回用于爬取的Request对象</span></span><br><span class="line"><span class="string">    :param url:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response, **kwargs</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    用于解析网页内容，一般作为初始URL解析的回调函数</span></span><br><span class="line"><span class="string">    :param response:</span></span><br><span class="line"><span class="string">    :param kwargs:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">spider, reason</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    当Spider关闭时，该函数被调用。可以用来在spider关闭时，释放占用的资源。</span></span><br><span class="line"><span class="string">    :param reason:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>Scrapy除了Spider类作为基类进行扩展，还提供了CrawlSpider，XMLFeedSpider,CSVFeedSpider和SitemapSpider等类来实现不同的爬虫任务。</p><h6 id="CrawlSpider"><a href="#CrawlSpider" class="headerlink" title="CrawlSpider"></a>CrawlSpider</h6><p>CrawlSpider类常用于爬取一般的网站。其中定义了一些规则(rule)来提供跟进链接功能。<br>CrawlSpider提供了新的属性rules。rules包含一个或多个Rule对象的集合。每个Rule对爬取网站的动作定义了特定的规则。如果多个Rule匹配相同的链接，则先定义的被调用。<br>CrawlSpider提供的初始URL解析方法，parse_start_url(response)。该方法返回一个Item对象或者一个Request对象或者包含二者的对象。使用示例如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCrawlSpider</span>(<span class="params">CrawlSpider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;crawlSpider&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&quot;cnblogs.com&quot;</span>]<span class="comment">#域名</span></span><br><span class="line">    start_urls = [</span><br><span class="line">        <span class="string">&quot;http://www.cnblogs.com/qiyeboy/default.html?page=1&quot;</span></span><br><span class="line">    ]</span><br><span class="line">    <span class="comment"># Rule原型</span></span><br><span class="line">    <span class="comment"># scrapy.contrib.spiders.Rule(link_exactor,callback=None,cb_kwargs=None,</span></span><br><span class="line">    <span class="comment"># follow=None,process_links=None,process_request=None)</span></span><br><span class="line">    rules = (</span><br><span class="line">        Rule(LinkExtractor(allow=(<span class="string">&quot;/qiyeboy/default.html\?page=\d&#123;1,&#125;&quot;</span>,)),</span><br><span class="line">                    follow=<span class="literal">True</span>,</span><br><span class="line">                    callback=<span class="string">&#x27;parse_item&#x27;</span></span><br><span class="line">                           ),</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># LinkExtractor对象的构造</span></span><br><span class="line">    <span class="comment"># allow: 用于匹配满足正则表达式的链接</span></span><br><span class="line">    <span class="comment"># deny: 排除正则表达式匹配的链接，优先级高于allow</span></span><br><span class="line">    <span class="comment"># allow_domains：允许的域名，可以是list或str</span></span><br><span class="line">    <span class="comment"># deny_domains:排除的域名</span></span><br><span class="line">    <span class="comment"># restrict_xpaths:提取满足Xpath选择条件的链接。</span></span><br><span class="line">    <span class="comment"># restrict_css:xxxCSSxxx的链接</span></span><br><span class="line">    <span class="comment"># tags: 提取指定标签下的链接。</span></span><br><span class="line">    <span class="comment"># unique:链接是否去重</span></span><br><span class="line">    <span class="comment"># process_value:值处理函数。</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response, **kwargs</span>):</span></span><br><span class="line">        papers = response.xpath(<span class="string">&quot;.//*[@class=&#x27;day&#x27;]&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> paper <span class="keyword">in</span> papers:</span><br><span class="line">            url = paper.xpath(<span class="string">&quot;.//*[@class=&#x27;postTitle&#x27;]/a/@href&quot;</span>).extract()[<span class="number">0</span>]</span><br><span class="line">            title = paper.xpath(<span class="string">&quot;.//*[@class=&#x27;postTitle&#x27;]/a/text()&quot;</span>).extract()[<span class="number">0</span>]</span><br><span class="line">            time = paper.xpath(<span class="string">&quot;.//*[@class=&#x27;dayTitle&#x27;]/a/text()&quot;</span>).extract()[<span class="number">0</span>]</span><br><span class="line">            content = paper.xpath(<span class="string">&quot;.//*[@class=&#x27;postTitle&#x27;]/a/text()&quot;</span>).extract()[<span class="number">0</span>]</span><br><span class="line">            item = MyCrawlSpider(url=url, title=title, time=time, content=content)</span><br><span class="line">            request = scrapy.Request(url=url, callback=self.parse_body)  <span class="comment"># 调用Request方法，并设置解析函数</span></span><br><span class="line">            request.meta[<span class="string">&#x27;item&#x27;</span>] = item  <span class="comment"># 将item暂存</span></span><br><span class="line">        <span class="keyword">yield</span> request</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_body</span>(<span class="params">self,response</span>):</span></span><br><span class="line">        item = response.meta[<span class="string">&#x27;item&#x27;</span>]</span><br><span class="line">        body = response.xpath(<span class="string">&quot;.//*[@class=&#x27;postBody&#x27;]&quot;</span>)</span><br><span class="line">        item[<span class="string">&#x27;cimage_urls&#x27;</span>] = body.xpath(<span class="string">&#x27;.//img//@src&#x27;</span>).extract()<span class="comment"># 提取图片链接</span></span><br><span class="line">        <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure><h6 id="XMLFeedSpider"><a href="#XMLFeedSpider" class="headerlink" title="XMLFeedSpider"></a>XMLFeedSpider</h6><p>XMLFeedSpider被设计用于通过迭代各个节点来分析XML源。迭代器可以从Iternodes,XML,HTML中选择。在XMLFeedSpider中，需要定义下列类属性来设置迭代器及标记名称。</p><ol><li>iterator</li></ol><p>用于确定使用哪个迭代器string,默认为iternodes，可选项有(1. iternodes, 2. html , 3. html)</p><ol><li><p>itertag</p><p>itertag为一个包含开始迭代的节点名string</p></li><li><p>namespaces</p><p> 称为命名空间，由(prefix,url),元组(tuple)所组成的list。这里定义了在文档中会被spider处理可用的namespace,prefix和url会被自动调用。由register_namespace()方法生成namespace。</p></li></ol><p>示例代码如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyXMLFeedSpider</span>(<span class="params">XMLFeedSpider</span>):</span></span><br><span class="line"></span><br><span class="line">    name = <span class="string">&quot;myxmlfeed&quot;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;cnblogs.com&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&quot;https://feed.cnblogs.com/blog/u/269038/rss&quot;</span>]</span><br><span class="line">    namespaces = [&#123;<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;http://www.sitemaps.org/schemas/sitemap/0.9&#x27;</span>&#125;]</span><br><span class="line">    iterator = <span class="string">&#x27;html&#x27;</span> <span class="comment"># 用于定义解析方式</span></span><br><span class="line">    itertag = <span class="string">&#x27;entry&#x27;</span></span><br><span class="line">    <span class="comment">#XMLFeedSpider方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adapt_response</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        这个方法在页面解析前和页面下载后之间被调用。可以用于修改Response内容，并再返回。</span></span><br><span class="line"><span class="string">        :param response:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span>  response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_node</span>(<span class="params">self, response, selector</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            当节点符合itertag时，该方法被调用。接收到的response以及相对应的Selector作为参数传递给该方法。</span></span><br><span class="line"><span class="string">            需要返回一个Item对象或Request对象，或包含二者的可迭代对象</span></span><br><span class="line"><span class="string">        :param response:</span></span><br><span class="line"><span class="string">        :param selector:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(selector.xpath(<span class="string">&#x27;id/text()&#x27;</span>).extract()[<span class="number">0</span>])</span><br><span class="line">        <span class="built_in">print</span>(selector.xpath(<span class="string">&#x27;title/text()&#x27;</span>).extract()[<span class="number">0</span>])</span><br><span class="line">        <span class="built_in">print</span>(selector.xpath(<span class="string">&#x27;summary/text()&#x27;</span>).extract()[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_results</span>(<span class="params">self, response, results</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        在页面解析后，数据返回前进行处理。主要是对返回数据的最后处理。修改Item的内容</span></span><br><span class="line"><span class="string">        :param response:</span></span><br><span class="line"><span class="string">        :param results:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [response,results]</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="2-Item-Loader模块"><a href="#2-Item-Loader模块" class="headerlink" title="2. Item Loader模块"></a><a id="two"></a>2. Item Loader模块</h3><blockquote><h5 id="Item-Loader是什么？"><a href="#Item-Loader是什么？" class="headerlink" title="Item Loader是什么？"></a>Item Loader是什么？</h5></blockquote><p>Item Loader提供了一种边界的方式填充抓到的Items。Item Loader可以直接对Item分析，并提取出想要的数据保存到容器中，而Item则是机械的根据键值对对应，返回数据。所以Item Loader更加灵活，高效。</p><p>Item Loader负责数据的收集，处理和填充。Item Loader包含两个重要的组件：输入处理器(input processors)和输出处理器(output processors)。</p><ol><li>Item Loader的每个字段都包含了一个输入处理器和输出处理器。</li><li>输入处理器接收到response后，通过add_xpath,add_css,add_value等方法提取数据，并将数据保存到Item Loader中。</li><li>收集完成数据之后，通过ItemLoader.load_item()方法来填充并返回Item对象。load_item()方法内部先调用输出处理器来处理收集到的数据，结果保存到最终的Item中。</li></ol><blockquote><h5 id="Item-Loader使用方法"><a href="#Item-Loader使用方法" class="headerlink" title="Item Loader使用方法"></a>Item Loader使用方法</h5></blockquote><p>在Item中声明输入输出处理器<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在Item中声明输入和输出处理器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter_price</span>(<span class="params">value</span>):</span></span><br><span class="line">    <span class="keyword">if</span> value.isdigit():</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span>(<span class="params">scrapy.Item</span>):</span></span><br><span class="line"></span><br><span class="line">    name = scrapy.Field(</span><br><span class="line">        input_processor=MapCompose(remove_tags),</span><br><span class="line">        output_processor=Join(),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    price = scrapy.Field(</span><br><span class="line">        input_processor=MapCompose(remove_tags,filter_price),</span><br><span class="line">        output_processor=TakeFirst(),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    stock = scrapy.Field()</span><br><span class="line">    last_updated = scrapy.Field(serializer=<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure></p><p>在Item Loader类中声明类似field_in和field_out的属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ItemLoader</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductLoadr</span>(<span class="params">ItemLoader</span>):</span></span><br><span class="line">    default_output_processor = TakeFirst()</span><br><span class="line">    <span class="comment"># 声明输入输出处理器</span></span><br><span class="line">    <span class="comment">#输入处理器</span></span><br><span class="line">    name_in = MapCompose(unicode.title)</span><br><span class="line">    <span class="comment">#输出处理器</span></span><br><span class="line">    name_out = Join()</span><br><span class="line">    price_in =  MapCompose(unicode.price)</span><br><span class="line">    price_out = Join()</span><br><span class="line">    stock_in = MapCompose(unicode.stock)</span><br><span class="line">    stock_out = Join()</span><br><span class="line">    last_updated_in = MapCompose(unicode.last_updated)</span><br><span class="line">    last_updated_out = Join()</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h5 id="Item-Loader-Context"><a href="#Item-Loader-Context" class="headerlink" title="Item Loader Context"></a>Item Loader Context</h5></blockquote><p>Item Loader Context是一个任意的键值对字典。能够被Item Loader中的输入输出处理器所共享。<br>可以用于调整输入输出处理器的行为。<br>使用Item Loader Context就是为了能够提高代码复用，便于扩展。如下代码所示，可以在原有的Item Loader基础上，对属性进行解析。如果对于不同的解析，只需要设置解析方法即可，增加了可复用性。就不需要再单独设置一个Loader ，可以复用Loader。</p><p>对于输入处理器，我们可以借助方法进行扩展。对于输出处理器，通常是再Item字段元数据进行声明。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Item Loader Context</span></span><br><span class="line"><span class="comment"># 通过接收loader_context,能告诉Item loader自己能够接收Item Loader context ,</span></span><br><span class="line"><span class="comment"># 所以方法被调用的时候能将当前的active Context传递给该方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_length</span>(<span class="params">text, loader_context</span>):</span></span><br><span class="line">    unit = loader_context.get(<span class="string">&#x27;unit&#x27;</span>, <span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">    <span class="comment"># 获取长度</span></span><br><span class="line">    parsed_length = <span class="built_in">len</span>(unit)</span><br><span class="line">    <span class="keyword">return</span> parsed_length</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductLoadr</span>(<span class="params">ProductLoader</span>):</span></span><br><span class="line">    <span class="comment"># 定义修改context</span></span><br><span class="line">    length_out = MapCompose(parse_length, unit=<span class="string">&#x27;cm&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h5 id="Item-Loader-内置的处理器"><a href="#Item-Loader-内置的处理器" class="headerlink" title="Item Loader 内置的处理器"></a>Item Loader 内置的处理器</h5></blockquote><h5 id="1-MapCompose"><a href="#1-MapCompose" class="headerlink" title="1. MapCompose"></a>1. MapCompose</h5><p>输入处理器，将多个方法的执行结果按顺序组合产出最终的输出。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#MapCompose</span></span><br><span class="line"><span class="comment">#和Compose类似，但是这个方法对输入是：每个元素单独传入第一个函数处理，然后将结果又作为</span></span><br><span class="line"><span class="comment">#整个迭代对象传入到后面的函数进行处理。</span></span><br><span class="line"><span class="comment">#如果输入是None会被自动忽略</span></span><br><span class="line"><span class="comment">#相当于这个方法会对每个元素单独处理</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter_world</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span> <span class="keyword">if</span> x ==<span class="string">&#x27;world&#x27;</span> <span class="keyword">else</span> x</span><br><span class="line">proc = MapCompose(filter_world,unicode.upper)</span><br><span class="line"><span class="built_in">print</span>(proc([<span class="string">u&#x27;hello&#x27;</span>,<span class="string">u&#x27;world&#x27;</span>,<span class="string">u&#x27;this&#x27;</span>,<span class="string">u&#x27;is&#x27;</span>,<span class="string">u&#x27;scrapy&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h5 id="2-Identity"><a href="#2-Identity" class="headerlink" title="2. Identity"></a>2. Identity</h5><p>最简单的处理器，不做任何处理，直接返回原来的数据，无参数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Identity ：简单的处理器，不做任何处理，直接返回原来的数据</span></span><br><span class="line">identity = Identity()</span><br><span class="line"><span class="built_in">print</span>(identity([<span class="string">&quot;1231&quot;</span>,<span class="string">&quot;321&quot;</span>]))</span><br></pre></td></tr></table></figure></p><h5 id="3-TakeFirst"><a href="#3-TakeFirst" class="headerlink" title="3. TakeFirst"></a>3. TakeFirst</h5><p>返回第一个非空值，常用于单值字段的输出处理器，无参数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TakeFirst:输出处理器</span></span><br><span class="line"><span class="comment"># TakeFirst用于返回第一个非空值，常用于单值字段的输出处理。</span></span><br><span class="line">proc = TakeFirst()</span><br><span class="line"><span class="built_in">print</span>(proc([<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]))</span><br></pre></td></tr></table></figure></p><h5 id="4-Compose"><a href="#4-Compose" class="headerlink" title="4. Compose"></a>4. Compose</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Compose</span></span><br><span class="line"><span class="comment">#用于将给定的多个方法的组合构造处理器</span></span><br><span class="line"><span class="comment">#每个输入值传递到第一个方法，然后将结果传递到第二个方法以此类推，最后一个方法的返回值作为输出</span></span><br><span class="line"><span class="comment">#如果需要当遇到None值时候停止处理，可以通过传递stop_on_one=False设定。</span></span><br><span class="line">proc = Compose(<span class="keyword">lambda</span> v:v[<span class="number">0</span>],<span class="built_in">str</span>.upper)</span><br><span class="line"><span class="built_in">print</span>(proc([<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>]))</span><br></pre></td></tr></table></figure><h5 id="5-Join"><a href="#5-Join" class="headerlink" title="5. Join"></a>5. Join</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Join</span></span><br><span class="line"><span class="comment">#返回用分隔符separator连接后的值，separator默认为空格，不接受loader contexts/</span></span><br><span class="line">proc = Join()</span><br><span class="line"><span class="built_in">print</span>(proc([<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;three&#x27;</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="6-SelectJmes"><a href="#6-SelectJmes" class="headerlink" title="6.SelectJmes"></a>6.SelectJmes</h5><p>指定json_path查询并返回值，需要jmespath的支持，每次只接收一个输入。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#SelectJmes</span></span><br><span class="line"><span class="comment">#指定json_path查询并返回值，需要jmespath的支持</span></span><br><span class="line">proc = SelectJmes(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(proc(&#123;<span class="string">&#x27;foo&#x27;</span>:<span class="string">&#x27;bar&#x27;</span>&#125;))</span><br></pre></td></tr></table></figure></p><blockquote><h4 id="3-Item-Pipeline模块"><a href="#3-Item-Pipeline模块" class="headerlink" title="3.Item Pipeline模块"></a><a id="two"></a>3.Item Pipeline模块</h4><p>完整的Item Pipeline的demo:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 完整的Item Pipeline</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoPipeline</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    coolection_name = <span class="string">&#x27;scrapy_items&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,mongo_uri,mongo_db</span>):</span></span><br><span class="line">        self.mongo_uri = mongo_uri</span><br><span class="line">        self.mongo_db = mongo_db</span><br><span class="line"></span><br><span class="line">    <span class="comment">#crawler是一个Crawler对象</span></span><br><span class="line">    <span class="comment">#从Crawl属性中，创建一个pipeline示例，Crawler对象能够接触所有Scrapy的核心组件如seetings，singnals。</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span>(<span class="params">cls,crawler</span>):</span></span><br><span class="line">        <span class="keyword">return</span> cls(</span><br><span class="line">            mongo_uri=crawler.settings.get(<span class="string">&#x27;MONGO_URI&#x27;</span>),</span><br><span class="line">            mongo_db=crawler.settings.get(<span class="string">&#x27;MONGO_DATABASE&#x27;</span>,<span class="string">&#x27;items&#x27;</span>)</span><br><span class="line">        )</span><br><span class="line">    <span class="comment"># 参数spider表示一个Spider对象，表示被开启的Spider</span></span><br><span class="line">    <span class="comment"># 当spider被开启的时候，这个方法会被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span>(<span class="params">self,spider</span>):</span></span><br><span class="line">        self.client = pymongo.MongoClient(self.mongo_uri)</span><br><span class="line">        self.db = self.client[self.mongo_db]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#当spider被关闭的时候，这个方法会被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span>(<span class="params">self,spider</span>):</span></span><br><span class="line">        self.client.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span>(<span class="params">self,item,spider</span>):</span></span><br><span class="line">        self.db[self.coolection_name].insert(<span class="built_in">dict</span>(item))</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></blockquote><h3 id="3-请求与响应-1"><a href="#3-请求与响应-1" class="headerlink" title="3. 请求与响应"></a><a id="three"></a>3. 请求与响应</h3><blockquote><h4 id="1-Request对象"><a href="#1-Request对象" class="headerlink" title="1. Request对象"></a>1. Request对象</h4></blockquote><ol><li>Request对象</li></ol><p>Request对象相当于一个HTTP请求。通常在Spider产生，传递给下载器，最后返回一个响应。<br>Request(url[,callback,method=’GET’,headers,body,cookies,meta,encoding=’utf-8’,priority=0,dont_filter=False,errback])。<br>url:请求链接。callback:指定用于解析请求响应的方法，如果没有指定，默认使用spider的parse方法。<br>method:HTTP请求方式。body:请求的body。headers:请求头。cookies（dict or list）：请求的cookie信息。<br>encoding:请求的编码。priority:请求的优先级，默认为0。dont_filter:标明该请求不应由调度器过滤，适用于多次执行相同请求。<br>errback:如果请求出现异常，该方法将被调用。<br>meta的参数如下所示：<br><img src="/images/spider/request-meta.PNG" alt="31"><br>示例代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">request_with_cookies = scrapy.Request(url=<span class="string">&#x27;http://www.example.com&#x27;</span>,</span><br><span class="line">                                              cookies=&#123;<span class="string">&#x27;currency&#x27;</span>:<span class="string">&#x27;USD&#x27;</span>,<span class="string">&#x27;country&#x27;</span>:<span class="string">&#x27;UY&#x27;</span>&#125;)</span><br><span class="line"><span class="comment">#使用字典列表发送</span></span><br><span class="line">request_with_cookies = scrapy.Request(url=<span class="string">&#x27;http://www.example.com&#x27;</span>,</span><br><span class="line">                                     cookies=[&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;currency&#x27;</span>,<span class="string">&#x27;value&#x27;</span>:<span class="string">&#x27;USD&#x27;</span>,</span><br><span class="line">                                               <span class="string">&#x27;domain&#x27;</span>:<span class="string">&#x27;example.com&#x27;</span>,<span class="string">&#x27;path&#x27;</span>:<span class="string">&#x27;/currency&#x27;</span>&#125;])</span><br><span class="line"><span class="comment">#meta(dont_merge_cookies属性)可以用于当请求发送后，不将返回的cookie信息和现有cookie合并</span></span><br><span class="line"></span><br><span class="line">request_with_cookies = scrapy.Request(url=<span class="string">&#x27;http://www.example.com&#x27;</span>,</span><br><span class="line">                                     cookies=[&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;currency&#x27;</span>, <span class="string">&#x27;value&#x27;</span>: <span class="string">&#x27;USD&#x27;</span>,</span><br><span class="line">                                               <span class="string">&#x27;domain&#x27;</span>: <span class="string">&#x27;example.com&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/currency&#x27;</span>&#125;],</span><br><span class="line">                                     meta=&#123;<span class="string">&#x27;dont_merge_cookies&#x27;</span>:<span class="literal">True</span>&#125;)</span><br></pre></td></tr></table></figure></p><ol><li>FormRequest</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#FromRequest提供了一个类方法from_response</span></span><br><span class="line"><span class="comment">#from_response(response[,formname=None,formnumber=0,formdata=None,formxpath=None,</span></span><br><span class="line"><span class="comment"># clickdata=None,dont_click=False])</span></span><br><span class="line"><span class="comment"># response: 一个包含HTML表单的响应页面，formname:表单的name属性，formnumber:用于指定第几个表单</span></span><br><span class="line"><span class="comment"># formdata(dict):用于填充表单中属性的值</span></span><br><span class="line"><span class="comment"># formxpath:通过xpath定位表单，第一个匹配的将会被操作</span></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">scrapy.FormRequest.from_response(</span><br><span class="line">   response,</span><br><span class="line">   formdata=&#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;john&#x27;</span>, <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;secret&#x27;</span>&#125;,</span><br><span class="line">   callback=self.after_login</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>使用实例如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;example.com&#x27;</span></span><br><span class="line">    start_url = [<span class="string">&#x27;http://www.example.com/users/login.php&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">return</span> scrapy.FormRequest.from_response(</span><br><span class="line">            response,</span><br><span class="line">            formdata=&#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;john&#x27;</span>,<span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;secret&#x27;</span>&#125;,</span><br><span class="line">            callback=self.after_login</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">after_login</span>(<span class="params">self,response</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;authentication failed&quot;</span> <span class="keyword">in</span> response.body:</span><br><span class="line">            self.logger.error(<span class="string">&quot;Login failed&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><ol><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Spider模块&quot;&gt;&lt;a href=&quot;#1-Spider模块&quot; class=&quot;headerlink&quot; title=&quot;1.Spider模块&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#one&quot;&gt;1.Spider模块&lt;/a&gt;&lt;/h3&gt;&lt;h3 id=&quot;2-Item-Loader&quot;
      
    
    </summary>
    
      <category term="爬虫" scheme="http://example.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="http://example.com/tags/Python/"/>
    
      <category term="爬虫" scheme="http://example.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python常见问题</title>
    <link href="http://example.com/wiki/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/Python/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/wiki/程序技术/Python/常见问题/</id>
    <published>2021-12-08T06:36:41.000Z</published>
    <updated>2021-12-08T06:41:02.235Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Python：常遇见的字符编码问题-TypeError-a-bytes-like-object-is-required-not-‘str’"><a href="#Python：常遇见的字符编码问题-TypeError-a-bytes-like-object-is-required-not-‘str’" class="headerlink" title="Python：常遇见的字符编码问题 TypeError: a bytes-like object is required, not ‘str’"></a>Python：常遇见的字符编码问题 TypeError: a bytes-like object is required, not ‘str’</h3><p>需要将写入的数据进行编码转换(通过encode转化)。例如:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.write(line.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Python：常遇见的字符编码问题-TypeError-a-bytes-like-object-is-required-not-‘str’&quot;&gt;&lt;a href=&quot;#Python：常遇见的字符编码问题-TypeError-a-bytes-like-object-is-
      
    
    </summary>
    
      <category term="Python" scheme="http://example.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb后端数据导出</title>
    <link href="http://example.com/wiki/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/Java/JavaWeb/%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%87%BA/"/>
    <id>http://example.com/wiki/程序技术/Java/JavaWeb/数据导出/</id>
    <published>2021-12-06T07:07:34.071Z</published>
    <updated>2021-12-06T09:11:19.936Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>我们在进行页面开发的过程中，经常需要获取数据，以及下载数据。通常从页面下载数据有多种方式，可以生成PDF下载，可以生成Excel表格下载。<br>这里介绍这几种数据下载方式。</p><h6 id="PDF下载"><a href="#PDF下载" class="headerlink" title="PDF下载"></a>PDF下载</h6><h6 id="Excel下载"><a href="#Excel下载" class="headerlink" title="Excel下载"></a>Excel下载</h6><p>Java比较常用的Excel导入和导出技术有两种，Jakarta POI和Java Excel。Jakarta POI 是一套用于访问微软格式文档的Java API。Jakarta POI有不少组件组成，其中有用于操做Excel格式文件的HSSF和用于操做Word的HWPF，在各类组件中目前只有用于操做Excel的HSSF相对成熟。官方主页<a href="http://poi.apache.org/index.html，API文档http://poi.apache.org/apidocs/index.htmlapi。这里主要介绍Jakarta">http://poi.apache.org/index.html，API文档http://poi.apache.org/apidocs/index.htmlapi。这里主要介绍Jakarta</a> POI的用法。</p><p>首先是maven依赖<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;poi&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.17</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.17</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;我们在进行页面开发的过程中，经常需要获取数据，以及下载数据。通常从页面下载数据有多种方式，可以生成PDF下载，可以生成Excel表格下载。&lt;
      
    
    </summary>
    
      <category term="JavaEE" scheme="http://example.com/categories/JavaEE/"/>
    
    
      <category term="Java" scheme="http://example.com/tags/Java/"/>
    
      <category term="JavaWeb" scheme="http://example.com/tags/JavaWeb/"/>
    
  </entry>
  
</feed>
