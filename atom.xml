<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-04-06T03:51:58.701Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>ZZC</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>环境配置-Pytorch</title>
    <link href="http://example.com/wiki/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/python/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/wiki/软件配置/python/机器学习相关/</id>
    <published>2022-04-06T03:19:12.009Z</published>
    <updated>2022-04-06T03:51:58.701Z</updated>
    
    <content type="html"><![CDATA[<h4 id="如何下载PyTorch"><a href="#如何下载PyTorch" class="headerlink" title="如何下载PyTorch"></a>如何下载PyTorch</h4><p>可以在<a href="https://download.pytorch.org/whl/cu100/torch/">https://download.pytorch.org/whl/cu100/torch/</a>网站，找到对应的whl文件，然后到下载目录，运行pip install命令，即可完成下载。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;如何下载PyTorch&quot;&gt;&lt;a href=&quot;#如何下载PyTorch&quot; class=&quot;headerlink&quot; title=&quot;如何下载PyTorch&quot;&gt;&lt;/a&gt;如何下载PyTorch&lt;/h4&gt;&lt;p&gt;可以在&lt;a href=&quot;https://download.pytor
      
    
    </summary>
    
      <category term="软件配置" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Pytorch" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/Pytorch/"/>
    
    
      <category term="Pytorch" scheme="http://example.com/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>Anaconda配置</title>
    <link href="http://example.com/wiki/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/python/Anaconda/"/>
    <id>http://example.com/wiki/软件配置/python/Anaconda/</id>
    <published>2022-04-06T03:19:12.008Z</published>
    <updated>2022-04-06T03:52:57.553Z</updated>
    
    <content type="html"><![CDATA[<p>Anaconda下载地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/ </a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Anaconda下载地址：&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/&quot;&gt;https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/ &lt;/a&gt;
      
    
    </summary>
    
      <category term="软件配置" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    
      <category term="python配置" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/python%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="环境配置" scheme="http://example.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>hexo使用问题</title>
    <link href="http://example.com/wiki/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/hexo/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>http://example.com/wiki/软件配置/hexo/问题解决/</id>
    <published>2022-04-06T03:19:12.006Z</published>
    <updated>2022-04-06T03:19:12.006Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何解决wiki中图片显示不全"><a href="#如何解决wiki中图片显示不全" class="headerlink" title="如何解决wiki中图片显示不全"></a>如何解决wiki中图片显示不全</h3><p>只需要把图片放在images文件夹下， 然后通过/images/xxx.xx进行引用即可，这是通过绝对路径进行引用。如果要通过相对路径引用则每个md需要创建相应的文件夹存放图片，较为麻烦。</p><h3 id="如何解决wiki中mermaid流程图无法显示的问题"><a href="#如何解决wiki中mermaid流程图无法显示的问题" class="headerlink" title="如何解决wiki中mermaid流程图无法显示的问题"></a>如何解决wiki中mermaid流程图无法显示的问题</h3><ol><li>修改 /theme/Wikitten下的config.yml文件</li></ol><p>讲下列代码粘贴到文件末尾<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mermaid: <span class="comment">## mermaid url https://github.com/knsv/mermaid</span></span><br><span class="line">enable: true  </span><br><span class="line"><span class="comment"># default true</span></span><br><span class="line">version: <span class="string">&quot;7.1.2&quot;</span></span><br><span class="line"><span class="comment"># default v7.1.2</span></span><br><span class="line">options:  </span><br></pre></td></tr></table></figure></p><ol><li>下载mermaid</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-filter-mermaid-diagrams</span><br></pre></td></tr></table></figure><ol><li>找到Wikitten下layout下 common/footer.ejs ,替换如下代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;footer id=<span class="string">&quot;footer&quot;</span>&gt;</span><br><span class="line">    &lt;% <span class="keyword">if</span> (theme.mermaid.enable) &#123; %&gt;</span><br><span class="line">        &lt;script src=<span class="string">&#x27;https://unpkg.com/mermaid@&lt;%= theme.mermaid.version %&gt;/dist/mermaid.min.js&#x27;</span>&gt;&lt;/script&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            <span class="keyword">if</span> (window.mermaid) &#123;</span><br><span class="line">                mermaid.initialize(&#123;</span><br><span class="line">                    theme: <span class="string">&#x27;forest&#x27;</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">        &lt;% &#125; %&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;outer&quot;</span>&gt;</span><br><span class="line">                &lt;div id=<span class="string">&quot;footer-info&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;inner&quot;</span>&gt;</span><br><span class="line">                    &lt;%= config.author || config.title %&gt; &amp;copy;</span><br><span class="line">                        &lt;%= date(<span class="keyword">new</span> Date(), <span class="string">&#x27;YYYY&#x27;</span>) %&gt;</span><br><span class="line">                            &lt;a rel=<span class="string">&quot;license&quot;</span> href=<span class="string">&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot;</span>&gt;&lt;img alt=<span class="string">&quot;Creative Commons License&quot;</span> style=<span class="string">&quot;border-width:0&quot;</span> src=<span class="string">&quot;https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png&quot;</span> /&gt;&lt;/a&gt;</span><br><span class="line">                            &lt;br&gt; Powered by &lt;a href=<span class="string">&quot;http://hexo.io/&quot;</span> target=<span class="string">&quot;_blank&quot;</span>&gt;Hexo&lt;/a&gt;. Theme - &lt;a href=<span class="string">&quot;https://github.com/zthxxx/hexo-theme-Wikitten&quot;</span>&gt;wikitten&lt;/a&gt;</span><br><span class="line">                            &lt;% <span class="keyword">if</span> (theme.plugins.busuanzi_count) &#123; %&gt;</span><br><span class="line">                                &lt;br&gt;</span><br><span class="line">                                &lt;span id=<span class="string">&quot;busuanzi_container_site_pv&quot;</span>&gt;&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;fa fa-eye&quot;</span>&gt;&lt;/i&gt; &lt;span id=<span class="string">&quot;busuanzi_value_site_pv&quot;</span>&gt;&lt;/span&gt;&lt;/span&gt;</span><br><span class="line">                                &amp;nbsp;|&amp;nbsp;</span><br><span class="line">                                &lt;span id=<span class="string">&quot;busuanzi_container_site_pv&quot;</span>&gt;&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;fa fa-user&quot;</span>&gt;&lt;/i&gt; &lt;span id=<span class="string">&quot;busuanzi_value_site_uv&quot;</span>&gt;&lt;/span&gt;&lt;/span&gt;</span><br><span class="line">                                &lt;% &#125; %&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">&lt;/footer&gt;</span><br></pre></td></tr></table></figure><h3 id="解决Wiki无法渲染数学公式的问题"><a href="#解决Wiki无法渲染数学公式的问题" class="headerlink" title="解决Wiki无法渲染数学公式的问题"></a>解决Wiki无法渲染数学公式的问题</h3><ol><li>执行下列指令</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><ol><li>找到../node_modules/kramed/lib/rules/inline.js</li></ol><p>修改如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,      第11行，将其修改为</span></span><br><span class="line">escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,</span><br><span class="line"><span class="comment">//em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,    第20行，将其修改为</span></span><br><span class="line">em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br></pre></td></tr></table></figure></p><ol><li>对需要使用MathJax公式的文章，修改文章标签,增加mathjax: true</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">mathjax: <span class="keyword">true</span></span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;如何解决wiki中图片显示不全&quot;&gt;&lt;a href=&quot;#如何解决wiki中图片显示不全&quot; class=&quot;headerlink&quot; title=&quot;如何解决wiki中图片显示不全&quot;&gt;&lt;/a&gt;如何解决wiki中图片显示不全&lt;/h3&gt;&lt;p&gt;只需要把图片放在images文件夹下
      
    
    </summary>
    
      <category term="软件配置" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    
      <category term="hexo" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/hexo/"/>
    
    
      <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
      <category term="bug" scheme="http://example.com/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>环境配置-卸载VS</title>
    <link href="http://example.com/wiki/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/Visual_studio/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%8D%B8%E8%BD%BDVisualStudio/"/>
    <id>http://example.com/wiki/软件配置/Visual_studio/如何正确卸载VisualStudio/</id>
    <published>2022-04-06T03:19:12.005Z</published>
    <updated>2022-04-06T03:52:41.170Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="第一步-借助VS自带卸载工具卸载"><a href="#第一步-借助VS自带卸载工具卸载" class="headerlink" title="第一步. 借助VS自带卸载工具卸载"></a>第一步. 借助VS自带卸载工具卸载</h4></blockquote><p>找到vs_ultimate.exe或者vs_professional.exe，运行卸载程序然后卸载。</p><blockquote><h4 id="第二步-下载Miscsoft工具进一步清理"><a href="#第二步-下载Miscsoft工具进一步清理" class="headerlink" title="第二步. 下载Miscsoft工具进一步清理"></a>第二步. 下载Miscsoft工具进一步清理</h4></blockquote><p>从Github地址<a href="https://github.com/microsoft/VisualStudioUninstaller/releases/tag/v1.4">https://github.com/microsoft/VisualStudioUninstaller/releases/tag/v1.4</a>下载相应的卸载工具，然后运行Setup.ForcedUninstall.exe。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h4 id=&quot;第一步-借助VS自带卸载工具卸载&quot;&gt;&lt;a href=&quot;#第一步-借助VS自带卸载工具卸载&quot; class=&quot;headerlink&quot; title=&quot;第一步. 借助VS自带卸载工具卸载&quot;&gt;&lt;/a&gt;第一步. 借助VS自带卸载工具卸载&lt;/h4&gt;&lt;/
      
    
    </summary>
    
      <category term="软件配置" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    
      <category term="卸载VS" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/%E5%8D%B8%E8%BD%BDVS/"/>
    
    
      <category term="环境配置" scheme="http://example.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>环境配置-Ngnix</title>
    <link href="http://example.com/wiki/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/Nginx/nginx%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/wiki/软件配置/Nginx/nginx配置/</id>
    <published>2022-04-06T03:19:11.998Z</published>
    <updated>2022-04-06T03:51:33.179Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># main 全局配置</span></span><br><span class="line"><span class="comment">#user username[groupname]</span></span><br><span class="line">user username_xyz gropname_x ;</span><br><span class="line"></span><br><span class="line"><span class="comment">#Nginx worker进程个数：其数量直接影响性能</span></span><br><span class="line"><span class="comment">#每个worker进程都是单线程的进程，他们会调用各个模块以实现多种多样的功能。</span></span><br><span class="line"><span class="comment">#如果这些模块不会出现阻塞式的调用，那么，有多少CPU内核就应该配置多少个进程，</span></span><br><span class="line"><span class="comment">#反之，有可能出现阻塞式调用，那么，需要配置稍多一些的worker进程。</span></span><br><span class="line"></span><br><span class="line">worker_processes <span class="number">1</span> ; </span><br><span class="line"></span><br><span class="line"><span class="comment">##ssl硬件加速。</span></span><br><span class="line"><span class="comment">#用户可以用OpneSSL提供的命令来查看是否有ssl硬件加速设备：openssl engine -t</span></span><br><span class="line"><span class="comment">#ssl_engine device;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##守护进程(daemon)。是脱离终端在后台允许的进程。</span></span><br><span class="line"><span class="comment">#它脱离终端是为了避免进程执行过程中的信息在任何终端上显示。</span></span><br><span class="line"><span class="comment">#这样一来，进程也不会被任何终端所产生的信息所打断。 </span></span><br><span class="line"><span class="comment">##关闭守护进程的模式，之所以提供这种模式，是为了放便跟踪调试nginx,</span></span><br><span class="line"><span class="comment">#毕竟用gdb调试进程时最繁琐的就是如何继续跟进fork出的子进程了。</span></span><br><span class="line"><span class="comment">##如果用off关闭了master_proccess方式，就不会fork出worker子进程来处理请求，</span></span><br><span class="line"><span class="comment">#而是用master进程自身来处理请求</span></span><br><span class="line"><span class="comment">#daemon off;   #查看是否以守护进程的方式运行Nginx 默认是on </span></span><br><span class="line"><span class="comment">#master_process off; #是否以master/worker方式工作 默认是on</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">##error日志的设置#</span></span><br><span class="line"><span class="comment">#语法： error_log /path/file level;</span></span><br><span class="line"><span class="comment">#默认： error_log / log/error.log error;</span></span><br><span class="line"><span class="comment">#当path/file 的值为 /dev/null时，这样就不会输出任何日志了，这也是关闭error日志的唯一手段；</span></span><br><span class="line"><span class="comment">#leve的取值范围是debug、info、notice、warn、error、crit、alert、emerg从左至右级别依次增大。</span></span><br><span class="line"><span class="comment">#当level的级别为error时，error、crit、alert、emerg级别的日志就都会输出。</span></span><br><span class="line"><span class="comment">#大于等于该级别会输出，小于该级别的不会输出。</span></span><br><span class="line"><span class="comment">#如果设定的日志级别是debug，则会输出所有的日志，这一数据量会很大，</span></span><br><span class="line"><span class="comment">#需要预先确保/path/file所在的磁盘有足够的磁盘空间。</span></span><br><span class="line"><span class="comment">#级别设定到debug，必须在configure时加入 --with-debug配置项。</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">##pid文件（master进程ID的pid文件存放路径）的路径</span></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#事件类配置 </span></span><br><span class="line">events &#123;</span><br><span class="line"> <span class="comment">#仅对指定的客户端输出debug级别的日志： 语法：debug_connection[IP|CIDR]</span></span><br><span class="line"> <span class="comment">#这个设置项实际上属于事件类配置，因此必须放在events&#123;……&#125;中才会生效。它的值可以是IP地址或者是CIRD地址。</span></span><br><span class="line"> <span class="comment">#debug_connection 10.224.66.14;  #或是debug_connection 10.224.57.0/24</span></span><br><span class="line"> <span class="comment">#这样，仅仅以上IP地址的请求才会输出debug级别的日志，其他请求仍然沿用error_log中配置的日志级别。</span></span><br><span class="line"> <span class="comment">#注意：在使用debug_connection前，需确保在执行configure时已经加入了--with-debug参数，否则不会生效。</span></span><br><span class="line">worker_connections  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">##核心转储(coredump):在Linux系统中，当进程发生错误或收到信号而终止时，</span></span><br><span class="line"><span class="comment">#系统会将进程执行时的内存内容(核心映像)写入一个文件(core文件)，</span></span><br><span class="line"><span class="comment">#以作为调试只用，这就是所谓的核心转储(coredump).</span></span><br><span class="line"> </span><br><span class="line">http &#123;</span><br><span class="line"><span class="comment">##嵌入其他配置文件 语法：include /path/file</span></span><br><span class="line"><span class="comment">#参数既可以是绝对路径也可以是相对路径（相对于Nginx的配置目录，即nginx.conf所在的目录）</span></span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">    <span class="comment">#                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">    <span class="comment">#                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line"> </span><br><span class="line">    sendfile        on;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    keepalive_timeout  <span class="number">65</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"> </span><br><span class="line">    server &#123;</span><br><span class="line"><span class="comment">##listen监听的端口</span></span><br><span class="line"><span class="comment">#语法：listen address:port [ default(deprecated in 0.8.21) | default_server | [ backlog=num | rcvbuf=size |</span></span><br><span class="line"><span class="comment"># sndbuf=size | accept_filter=filter | deferred | bind | ssl ] ]</span></span><br><span class="line"><span class="comment">#default_server: 如果没有设置这个参数，那么将会以在nginx.conf中找到的第一个server块作为默认server块</span></span><br><span class="line">listen       <span class="number">8080</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#主机名称：其后可以跟多个主机名称，开始处理一个HTTP请求时，nginx会取出header头中的Host，与每个server中的server_name进行匹配，以此决定到底由那一个server来处理这个请求。有可能一个Host与多个server块中的server_name都匹配，这时会根据匹配优先级来选择实际处理的server块。server_name与Host的匹配优先级见文末。</span></span><br><span class="line"> server_name  localhost;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">#location / &#123;</span></span><br><span class="line">        <span class="comment">#    root   html;</span></span><br><span class="line">        <span class="comment">#    index  index.html index.htm;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">##location 语法： location [=|~|~*|^~] /uri/ &#123; ... &#125;</span></span><br><span class="line"><span class="comment"># location的使用实例见文末。</span></span><br><span class="line"><span class="comment">#注意：location时有顺序的，当一个请求有可能匹配多个location时，实际上这个请求会被第一个location处理。</span></span><br><span class="line">location / &#123;</span><br><span class="line">    proxy_pass http://<span class="number">192.168</span><span class="number">.1</span><span class="number">.60</span>; <span class="comment"># 反向代理</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        error_page   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">        <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">        <span class="comment">#    root           html;</span></span><br><span class="line">        <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">        <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">        <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">        <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># deny access to .htaccess files, if Apache&#x27;s document root</span></span><br><span class="line">        <span class="comment"># concurs with nginx&#x27;s one</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">        <span class="comment">#    deny  all;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment"># another virtual host using mix of IP-, name-, and port-based configuration</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">    <span class="comment">#    listen       8000;</span></span><br><span class="line">    <span class="comment">#    listen       somename:8080;</span></span><br><span class="line">    <span class="comment">#    server_name  somename  alias  another.alias;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">#    location / &#123;</span></span><br><span class="line">    <span class="comment">#        root   html;</span></span><br><span class="line">    <span class="comment">#        index  index.html index.htm;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment"># HTTPS server</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">    <span class="comment">#    listen       443 ssl;</span></span><br><span class="line">    <span class="comment">#    server_name  localhost;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">#    ssl_certificate      cert.pem;</span></span><br><span class="line">    <span class="comment">#    ssl_certificate_key  cert.key;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">#    ssl_session_cache    shared:SSL:1m;</span></span><br><span class="line">    <span class="comment">#    ssl_session_timeout  5m;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">#    ssl_ciphers  HIGH:!aNULL:!MD5;</span></span><br><span class="line">    <span class="comment">#    ssl_prefer_server_ciphers  on;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">#    location / &#123;</span></span><br><span class="line">    <span class="comment">#        root   html;</span></span><br><span class="line">    <span class="comment">#        index  index.html index.htm;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="server-name与host的匹配优先级"><a href="#server-name与host的匹配优先级" class="headerlink" title="server_name与host的匹配优先级"></a>server_name与host的匹配优先级</h3><ol><li>首先选择字符串完全匹配的server_name</li><li>选择通配符在前面的server_name</li><li>选择通配符在后面的server_name</li><li>选择正则表达式才能够匹配的server_name</li></ol><h3 id="location-匹配示例"><a href="#location-匹配示例" class="headerlink" title="location 匹配示例"></a>location 匹配示例</h3><blockquote><h5 id="1-只有当用户请求是-时，才会使用该location下的配置"><a href="#1-只有当用户请求是-时，才会使用该location下的配置" class="headerlink" title="1. 只有当用户请求是/时，才会使用该location下的配置"></a>1. 只有当用户请求是/时，才会使用该location下的配置</h5></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location = &#123;</span><br><span class="line">    [configuration A]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="2-匹配所有的请求"><a href="#2-匹配所有的请求" class="headerlink" title="2. 匹配所有的请求"></a>2. 匹配所有的请求</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">    [configuration A]    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-匹配以-images-开头的任何查询并停止搜索（忽略字母大小写问题）"><a href="#3-匹配以-images-开头的任何查询并停止搜索（忽略字母大小写问题）" class="headerlink" title="3. 匹配以/images/开头的任何查询并停止搜索（忽略字母大小写问题）"></a>3. 匹配以/images/开头的任何查询并停止搜索（忽略字母大小写问题）</h5></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ^~ /images/ &#123;</span><br><span class="line">    [configuration C]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="4-匹配任何以gif-jpg或jpeg结尾的请求"><a href="#4-匹配任何以gif-jpg或jpeg结尾的请求" class="headerlink" title="4. 匹配任何以gif,jpg或jpeg结尾的请求"></a>4. 匹配任何以gif,jpg或jpeg结尾的请求</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~* \.(gif|jpg|jpeg)$ &#123;</span><br><span class="line">    [ configuration D ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-以root方式设置资源路径"><a href="#5-以root方式设置资源路径" class="headerlink" title="5. 以root方式设置资源路径"></a>5. 以root方式设置资源路径</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">location /download/ &#123;</span><br><span class="line">    root /opt/wab/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如有一个请求URL为 /download/index/test.html， 那么Web服务器就会返回服务器上的/opt/wab/download/index/test.html文件的内容。</p><h5 id="6-以alias方式设置资源路径"><a href="#6-以alias方式设置资源路径" class="headerlink" title="6. 以alias方式设置资源路径"></a>6. 以alias方式设置资源路径</h5><p>alias也是用来设置文件资源路径的，和root的不同点在于，alias主要是解读loacation后面的uri参数。例如如果一个请求是/conf/nginx.conf ，而用户实际想要访问的是/usr/local/nginx/conf/nginx.conf。通过root只能在请求路径前面加上路径，通过alias可以解读路径。alias会把解析的字符串丢弃，而root不会。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#alias</span></span><br><span class="line">location /conf &#123;</span><br><span class="line">    alias /usr/local/nginx/conf</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#root</span></span><br><span class="line">location /conf&#123;</span><br><span class="line">    root /usr/local/nginx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="7-以index方式访问首页"><a href="#7-以index方式访问首页" class="headerlink" title="7. 以index方式访问首页"></a>7. 以index方式访问首页</h6></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">    root path;</span><br><span class="line">    index /index.html /html/index.php /index.php</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>index后面可以跟多个文件参数，Nginx会按照顺序（从右到左的顺序）来访问文件。接收到请求后Nginx会首先尝试访问path/index.php , 如果可以访问，则结束请求。否则再尝试返回path/html/index.pho文件内容，以此类推。</p><h4 id="通用模板"><a href="#通用模板" class="headerlink" title="通用模板"></a>通用模板</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户设置任何人</span></span><br><span class="line">user nobody ; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置nginx的worker数量</span></span><br><span class="line">worker_processes <span class="number">1</span> ; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置错误日志</span></span><br><span class="line">error_log logs/error.log </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pid logs/nginx.pid ; </span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    use epoll ;</span><br><span class="line">    worker_connections <span class="number">2048</span> ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http&#123;</span><br><span class="line"></span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile on ; </span><br><span class="line">    keepalive_timeout <span class="number">65</span> ; </span><br><span class="line"></span><br><span class="line">    <span class="comment"># gzip压缩功能设置</span></span><br><span class="line">    gzip on ; </span><br><span class="line">    gzip_min_length 1k ;</span><br><span class="line">    gzip_buffers <span class="number">4</span> 16K ;</span><br><span class="line">    gzip_http_version <span class="number">1.0</span>;</span><br><span class="line">    gzip_comp_level <span class="number">6</span> ;</span><br><span class="line">    gzip_types text/html text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml;</span><br><span class="line">    gzip_vary on  ;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># http_proxy设置</span></span><br><span class="line">    client_max_body_size 10m ; </span><br><span class="line">    client_body_buffer_size 128k;</span><br><span class="line">    proxy_connect_timeout <span class="number">75</span> ;</span><br><span class="line">    proxy_send_timeout <span class="number">75</span> ;</span><br><span class="line">    proxy_read_timeout <span class="number">75</span> ;</span><br><span class="line">    proxy_buffer_size 4k ;</span><br><span class="line">    proxy_buffers <span class="number">4</span> 32k ;</span><br><span class="line">    proxy_busy_buffers_size 64k;</span><br><span class="line">    proxy_temp_file_write_size 64k ; </span><br><span class="line">    proxy_temp_path /usr/local/nginx/proxy_temp <span class="number">1</span> <span class="number">2</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置负载均衡后台服务器列表</span></span><br><span class="line">    upstream backend &#123;</span><br><span class="line">        <span class="comment"># ip_hash</span></span><br><span class="line">        server <span class="number">192.168</span><span class="number">.10</span><span class="number">.100</span>:<span class="number">8080</span> max_fails=<span class="number">2</span> fail_timeout=30s ;</span><br><span class="line">        server <span class="number">192.168</span><span class="number">.101</span>:<span class="number">8080</span> max_fails=<span class="number">2</span> fail_timeout=30s;</span><br><span class="line">        <span class="comment"># 轮询</span></span><br><span class="line">        <span class="comment">#server 127.0.0.1:8080 weight=1 ;</span></span><br><span class="line">    <span class="comment">#server 127.0.0.1:8081 weight=1 ;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 虚拟主机配置</span></span><br><span class="line">    server&#123;</span><br><span class="line">        listen <span class="number">80</span> ; </span><br><span class="line">        <span class="comment"># 主机名称， 一般是域名</span></span><br><span class="line">        server_name localhost ;</span><br><span class="line">        root /apps/oaapp</span><br><span class="line"></span><br><span class="line">        charset utf-<span class="number">8</span> ; </span><br><span class="line">        access_log logs/host.access.log main; </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对 / 所有做负载均衡和反向代理</span></span><br><span class="line">        location / &#123;</span><br><span class="line">            root /apps/oaapp</span><br><span class="line">            index index.jsp index.html index.htm</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        proxy_pass http://backend ;  <span class="comment"># 负载均衡</span></span><br><span class="line">        proxy_redirect off ; </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 后端的web服务器可以通过X-Forwarded-For获取用户的真实IP</span></span><br><span class="line">        proxy_set_header Host $host ; </span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr ; </span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forward_for</span><br><span class="line">        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504 ; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 静态文件， nginx服务器处理，不需要通过backend请求tomcat</span></span><br><span class="line">    location ~* /download/&#123;</span><br><span class="line">        root /apps/oa/fs ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~.*\.(gif|jpg|jpeg|bmp|png|ico|txt|js|css)$&#123;</span><br><span class="line">        root /apps/oaapp</span><br><span class="line">        expires 7d; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /nginx_status &#123;</span><br><span class="line">        stub_status on ; </span><br><span class="line">        access_log off ;</span><br><span class="line">        allow <span class="number">192.168</span><span class="number">.10</span><span class="number">.0</span>/<span class="number">24</span> ;</span><br><span class="line">        deny <span class="built_in">all</span> ; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ ^/(WEB-INF)/&#123;</span><br><span class="line">        deny <span class="built_in">all</span> ; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置error_page </span></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    error_page <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html</span><br><span class="line">    location = /50x.html&#123;</span><br><span class="line">        root html ; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="main全局配置"><a href="#main全局配置" class="headerlink" title="main全局配置"></a>main全局配置</h4><p>nginx在运行时与具体业务功能（比如http服务或者email服务代理）无关的一些参数，比如工作进程数，运行的身份等。</p><blockquote><p>woker_processes 2</p><p>在配置文件的顶级main部分，worker角色的工作进程的个数，master进程是接收并分配请求给worker处理。这个数值简单一点可以设置为cpu的核数grep ^processor /proc/cpuinfo | wc -l，也是 auto 值，如果开启了ssl和gzip更应该设置成与逻辑CPU数量一样甚至为2倍，可以减少I/O操作。如果nginx服务器还有其它服务，可以考虑适当减少。</p><p>worker_cpu_affinity</p></blockquote><p>也是写在main部分。在高并发情况下，通过设置cpu粘性来降低由于多CPU核切换造成的寄存器等现场重建带来的性能损耗。如worker_cpu_affinity 0001 0010 0100 1000; （四核）。</p><blockquote><p>worker_connections 2048</p></blockquote><p>写在events部分。每一个worker进程能并发处理（发起）的最大连接数（包含与客户端或后端被代理服务器间等所有连接数）。nginx作为反向代理服务器，计算公式 最大连接数 = worker_processes * worker_connections/4，所以这里客户端最大连接数是1024，这个可以增到到8192都没关系，看情况而定，但不能超过后面的worker_rlimit_nofile。当nginx作为http服务器时，计算公式里面是除以2。</p><blockquote><p>worker_rlimit_nofile 10240</p></blockquote><p>写在main部分。默认是没有设置，可以限制为操作系统最大的限制65535</p><blockquote><p>use epoll</p></blockquote><p>写在events部分。在Linux操作系统下，nginx默认使用epoll事件模型，得益于此，nginx在Linux操作系统下效率相当高。同时Nginx在OpenBSD或FreeBSD操作系统上采用类似于epoll的高效事件模型kqueue。在操作系统不支持这些高效模型时才使用select。</p><h4 id="http服务器"><a href="#http服务器" class="headerlink" title="http服务器"></a>http服务器</h4><p>与提供http服务相关的一些配置参数。例如：是否使用keepalive啊，是否使用gzip进行压缩等。</p><blockquote><p>sendfile on</p></blockquote><p>开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，减少用户空间到内核空间的上下文切换。对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。</p><blockquote><p>keepalive_timeout 65 </p></blockquote><p>长连接超时时间，单位是秒，这个参数很敏感，涉及浏览器的种类、后端服务器的超时设置、操作系统的设置，可以另外起一片文章了。长连接请求大量小文件的时候，可以减少重建连接的开销，但假如有大文件上传，65s内没上传完成会导致失败。如果设置时间过长，用户又多，长时间保持连接会占用大量资源。</p><blockquote><p>send_timeout </p></blockquote><p>用于指定响应客户端的超时时间。这个超时仅限于两个连接活动之间的时间，如果超过这个时间，客户端没有任何活动，Nginx将会关闭连接。</p><blockquote><p>client_max_body_size 10m</p></blockquote><p>允许客户端请求的最大单文件字节数。如果有上传较大文件，请设置它的限制值</p><blockquote><p>client_body_buffer_size 128k</p></blockquote><p>缓冲区代理缓冲用户端请求的最大字节数</p><h4 id="http-proxy"><a href="#http-proxy" class="headerlink" title="http_proxy"></a>http_proxy</h4><blockquote><p>proxy_connect_timeout 60</p></blockquote><p>nginx跟后端服务器连接超时时间(代理连接超时)</p><blockquote><p>proxy_read_timeout 60</p></blockquote><p>连接成功后，与后端服务器两个成功的响应操作之间超时时间(代理接收超时)</p><blockquote><p>proxy_buffer_size 4k</p></blockquote><p>设置代理服务器（nginx）从后端realserver读取并保存用户头信息的缓冲区大小，默认与proxy_buffers大小相同，其实可以将这个指令值设的小一点</p><blockquote><p>proxy_buffers 4 32k</p></blockquote><p>proxy_buffers缓冲区，nginx针对单个连接缓存来自后端realserver的响应，网页平均在32k以下的话，这样设置</p><blockquote><p>proxy_busy_buffers_size 64k</p></blockquote><p>高负荷下缓冲大小（proxy_buffers*2）</p><blockquote><p>proxy_max_temp_file_size</p></blockquote><p>当 proxy_buffers 放不下后端服务器的响应内容时，会将一部分保存到硬盘的临时文件中，这个值用来设置最大临时文件大小，默认1024M，它与 proxy_cache 没有关系。大于这个值，将从upstream服务器传回。设置为0禁用。</p><blockquote><p>proxy_temp_file_write_size 64k</p></blockquote><p>当缓存被代理的服务器响应到临时文件时，这个选项限制每次写临时文件的大小。</p><blockquote><p>proxy_temp_path<br>（可以在编译的时候）指定写到哪那个目录。</p></blockquote><h4 id="http-gzip"><a href="#http-gzip" class="headerlink" title="http_gzip"></a>http_gzip</h4><blockquote><p>gzip on </p></blockquote><p>开启gzip压缩输出，减少网络传输。</p><blockquote><p>gzip_min_length 1k</p></blockquote><p>设置允许压缩的页面最小字节数，页面字节数从header头得content-length中进行获取。默认值是20。建议设置成大于1k的字节数，小于1k可能会越压越大。</p><blockquote><p>gzip_buffers 4 16k</p></blockquote><p>设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。4 16k代表以16k为单位，安装原始数据大小以16k为单位的4倍申请内存。</p><blockquote><p>gzip_http_version 1.0 </p></blockquote><p>用于识别 http 协议的版本，早期的浏览器不支持 Gzip 压缩，用户就会看到乱码，所以为了支持前期版本加上了这个选项，如果你用了 Nginx 的反向代理并期望也启用 Gzip 压缩的话，由于末端通信是 http/1.0，故请设置为 1.0。</p><blockquote><p>gzip_comp_level 6 </p></blockquote><p>gzip压缩比，1压缩比最小处理速度最快，9压缩比最大但处理速度最慢(传输快但比较消耗cpu)</p><blockquote><p>gzip_types </p></blockquote><p>匹配mime类型进行压缩，无论是否指定,”text/html”类型总是会被压缩的。</p><blockquote><p>gzip_proxied any </p></blockquote><p>Nginx作为反向代理的时候启用，决定开启或者关闭后端服务器返回的结果是否压缩，匹配的前提是后端服务器必须要返回包含”Via”的 header头。</p><blockquote><p>gzip_vary on </p></blockquote><p>和http头有关系，会在响应头加个 Vary: Accept-Encoding ，可以让前端的缓存服务器缓存经过gzip压缩的页面，例如，用Squid缓存经过Nginx压缩的数据。。</p><h4 id="server-虚拟机"><a href="#server-虚拟机" class="headerlink" title="server 虚拟机"></a>server 虚拟机</h4><p>http服务上支持若干虚拟主机。每个虚拟主机一个对应的server配置项，配置项里面包含该虚拟主机相关的配置。在提供mail服务的代理时，也可以建立若干server。每个server通过监听地址或端口来区分。</p><blockquote><p>listen</p></blockquote><p>监听端口，默认80，小于1024的要以root启动。可以为listen *:80、listen 127.0.0.1:80等形式。</p><blockquote><p>server_name</p></blockquote><p>服务器名，如localhost、www.example.com，可以通过正则匹配。</p><h4 id="http-stream"><a href="#http-stream" class="headerlink" title="http_stream"></a>http_stream</h4><p>这个模块通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡，upstream后接负载均衡器的名字，后端realserver以 host:port options; 方式组织在 {} 中。如果后端被代理的只有一台，也可以直接写在 proxy_pass 。</p><h4 id="loaction"><a href="#loaction" class="headerlink" title="loaction"></a>loaction</h4><blockquote><p>root /var/www/html</p></blockquote><p>定义服务器的默认网站根目录位置。如果locationURL匹配的是子目录或文件，root没什么作用，一般放在server指令里面或/下。</p><blockquote><p>index index.jsp index.html index.htm</p></blockquote><p>定义路径下默认访问的文件名，一般跟着root放</p><blockquote><p>proxy_pass http:/backend</p></blockquote><p>请求转向backend定义的服务器列表，即反向代理，对应upstream负载均衡器。也可以proxy_pass <a href="http://ip:port。">http://ip:port。</a></p><p>proxy_redirect off;<br>proxy_set_header Host $host;<br>proxy_set_header X-Real-IP $remote_addr;<br>proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</p><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><p>Nginx的访问控制模块，通过allow和deny来表示。<br>可以有多个allow，deny，允许或禁止某个ip或ip段访问。<br>依次从上到下匹配，满足任何一个规则就停止往下匹配。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location /nginx-status &#123;</span><br><span class="line">    stub_status on ; </span><br><span class="line">    <span class="comment"># auth_basic &quot;NginxStatus&quot;;</span></span><br><span class="line">    <span class="comment"># auth_basic_user_file /usr/local/nginx-1.6/htpasswd;</span></span><br><span class="line">    access_log off ;</span><br><span class="line">    allow <span class="number">192.168</span><span class="number">.10</span><span class="number">.0</span>/<span class="number">24</span> ;</span><br><span class="line">     deny <span class="built_in">all</span> ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们也常用 httpd-devel 工具的 htpasswd 来为访问的路径设置登录密码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># htpasswd -c htpasswd admin</span></span><br><span class="line">New passwd:</span><br><span class="line">Re-<span class="built_in">type</span> new password:</span><br><span class="line">Adding password <span class="keyword">for</span> user admin</span><br><span class="line">  </span><br><span class="line"><span class="comment"># htpasswd htpasswd admin //修改admin密码</span></span><br><span class="line"><span class="comment"># htpasswd htpasswd sean //多添加一个认证用户</span></span><br></pre></td></tr></table></figure><p>这样就生成了默认使用CRYPT加密的密码文件。打开上面nginx-status的两行注释，重启nginx生效。</p><h4 id="列出目录-autoindex"><a href="#列出目录-autoindex" class="headerlink" title="列出目录 autoindex"></a>列出目录 autoindex</h4><p>Nginx默认是不允许列出整个目录的。如需此功能，打开nginx.conf文件，在location，server 或 http段中加入autoindex on;，另外两个参数最好也加上去:</p><p>autoindex_exact_size off; 默认为on，显示出文件的确切大小，单位是bytes。改为off后，显示出文件的大概大小，单位是kB或者MB或者GB<br>autoindex_localtime on;<br>默认为off，显示的文件时间为GMT时间。改为on后，显示的文件时间为文件的服务器时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /images &#123;</span><br><span class="line">    root /var/www/nginx-default/images;</span><br><span class="line">    autoindex on;</span><br><span class="line">    autoindex_exact_size off;</span><br><span class="line">    autoindex_localtime on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
      <category term="软件配置" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Ngnix" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/Ngnix/"/>
    
    
      <category term="Ngnix" scheme="http://example.com/tags/Ngnix/"/>
    
  </entry>
  
  <entry>
    <title>算法——经验之谈</title>
    <link href="http://example.com/wiki/%E7%AE%97%E6%B3%95/%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%B0%88/"/>
    <id>http://example.com/wiki/算法/经验之谈/</id>
    <published>2022-04-06T03:19:11.997Z</published>
    <updated>2022-04-06T03:50:47.371Z</updated>
    
    <content type="html"><![CDATA[<h4 id="如何确定重复出现数字中单独出现的数字"><a href="#如何确定重复出现数字中单独出现的数字" class="headerlink" title="如何确定重复出现数字中单独出现的数字"></a>如何确定重复出现数字中单独出现的数字</h4><p>我们可以根据异或运算的性质来解决类似的问题。对于异或运算，相同数字异或结果为0，0和任何数异或的结果都是这个数本身。根据这个就能够很快确定单独出现的数字。</p><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>我们在接近双指针问题的时候，通常都是可以分为A,B两个个体进行看待。分析A,B之间潜在的等式关系，进而得到问题的解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;如何确定重复出现数字中单独出现的数字&quot;&gt;&lt;a href=&quot;#如何确定重复出现数字中单独出现的数字&quot; class=&quot;headerlink&quot; title=&quot;如何确定重复出现数字中单独出现的数字&quot;&gt;&lt;/a&gt;如何确定重复出现数字中单独出现的数字&lt;/h4&gt;&lt;p&gt;我们可以根据
      
    
    </summary>
    
      <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口</title>
    <link href="http://example.com/wiki/%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>http://example.com/wiki/算法/滑动窗口/滑动窗口/</id>
    <published>2022-04-06T03:19:11.996Z</published>
    <updated>2022-04-06T03:48:52.031Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是滑动窗口算法"><a href="#什么是滑动窗口算法" class="headerlink" title="什么是滑动窗口算法"></a>什么是滑动窗口算法</h4><p>滑动窗口算法是在特定窗口大小的数组或字符串上执行要求的操作，通过这个操作可以将一部分问题中的嵌套循环变为单循环，可以减少时间复杂度，根据应用场景的不同可以调整窗口的大小或者固定窗口的大小。</p><h4 id="滑动窗口算法步骤"><a href="#滑动窗口算法步骤" class="headerlink" title="滑动窗口算法步骤"></a>滑动窗口算法步骤</h4><blockquote><ol><li>我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。</li><li>我们先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。</li><li>此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。</li><li>重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。</li></ol></blockquote><p>滑动窗口也就是先向右走，走到最大的窗口(也就是在条件允许范围内的最右端)，然后左端再向右走，逐步更新当前值，用来找到这个窗口范围内的最优解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是滑动窗口算法&quot;&gt;&lt;a href=&quot;#什么是滑动窗口算法&quot; class=&quot;headerlink&quot; title=&quot;什么是滑动窗口算法&quot;&gt;&lt;/a&gt;什么是滑动窗口算法&lt;/h4&gt;&lt;p&gt;滑动窗口算法是在特定窗口大小的数组或字符串上执行要求的操作，通过这个操作可以将一部分
      
    
    </summary>
    
      <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="滑动窗口" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    
      <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>区间问题-树状数组</title>
    <link href="http://example.com/wiki/%E7%AE%97%E6%B3%95/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <id>http://example.com/wiki/算法/区间问题/树状数组/</id>
    <published>2022-04-06T03:19:11.995Z</published>
    <updated>2022-04-06T03:19:11.995Z</updated>
    
    <content type="html"><![CDATA[<p>树状数组和线段树解决的问题一般都是对数据的区间操作，也就是求一段区间内的数据操作。</p><p>树状数组比较适合于单点修改的问题。线段树则使用较广。</p><h4 id="lowbit的含义"><a href="#lowbit的含义" class="headerlink" title="lowbit的含义"></a>lowbit的含义</h4><p>lowbit的定义如下所示，通过lowbit可以找到x的二进制数的最后一个1所表示的2进制。lowbit(x) = <script type="math/tex">2^k</script></p><blockquote><p>注意: x不能等于0, 否则会进入死循环, 所以树状数组通常使用的下标会执行+1操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></blockquote><h4 id="区间求和问题"><a href="#区间求和问题" class="headerlink" title="区间求和问题"></a>区间求和问题</h4><p>  区间求和可以通过计算前缀和来计算区间【l,r】的和。sum(l,r) = preSum(r) - preSum(l-1) ; 所以区间求和问题转化为求索引x的前缀和问题。</p><h4>定义树状数组</h4><p>​    通过如下图片可以了解树状数组如何存储数据。假设树状数组为sums，我们可以通过sums来计算前缀和，例如求preSum[3] = sums[4] + sums[6] + sums[7].</p><p>​     很容易定义sums的计算公式sums[i] =$\sum_{j=i-lowbit(i)+1}^{n=i}a[j]$，</p><p><img src="/images/algorithm/image-20220404232156224.png" alt="image-20220404232156224"></p>   <h4>更新\查询树状数组</h4><pre><code>  更新树状数组的时候，通过x+=lowbit(x)来寻找被影响的数组下标。（规律在于+1，+10，+100依次类推，通过这个规律可以看见其中的一些规律）。</code></pre><p><img src="/images/algorithm/image-20220404234254953.png" alt="image-20220404234254953"></p><p>​    查询树状数组的时候，使用x-=lowBit(x)来寻找小于x的下一区间。也就是查询前缀数组和的时候，通过x -= lowBit(x)。由于sums[i] = $\sum_{j=i-lowbit(i)+1}^{n=i}a[j]$,则可以看出，对于当前x,sums[x]计算的是，a[x-lowbit(i)+1] -&gt; a[x] 的和。如果要计算a[0] -&gt;a[x]区间内的和。那么还需要计算a[0]-&gt;a[x-lowbit(i)]的值。而$sums[x-lowbtt(i)] = \sum_{j=i-lowbit(x-lowbit)+1}^{n=i}a[j]$,不断重复这个操作，就可以找到所有的前缀和。直到x&lt;1则查询完毕。</p><p><img src="/images/algorithm/image-20220404235223429.png" alt="image-20220404235223429"></p><h4>实现代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NmArray</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] sums ; <span class="comment">//累加和</span></span><br><span class="line">    <span class="keyword">int</span>[] nums ;<span class="comment">//更新后的数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">//原数组长度+1,避免因为x=0,lowbit(x)进入死循环。</span></span><br><span class="line">    sums = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">this</span>.nums = nums ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length ; i++)&#123;</span><br><span class="line">            <span class="comment">//初始化，累加数组</span></span><br><span class="line">            insert(i,nums[i]) ; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    lowBit用于返回最后一位1所在的位置。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    用于初始化树状数组，很简单的方法，只需要找到所有的 x ,更新值即可。</span></span><br><span class="line"><span class="comment">    x = x + lowbit(x)进行更新。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i , <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="comment">//一直寻找 x += lowbit(i) </span></span><br><span class="line">        <span class="keyword">int</span> x = i + <span class="number">1</span> ; <span class="comment">//新数组从1开始</span></span><br><span class="line">      <span class="keyword">while</span>(x &lt; sums.length)&#123;</span><br><span class="line">            sums[x] = sums[x] + val ;</span><br><span class="line">            x += lowBit(x) ; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//更新数组以及累加和</span></span><br><span class="line">    <span class="comment">//只需要在插入的基础上，进行修改即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index , <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> change = <span class="keyword">this</span>.nums[index] - val ; </span><br><span class="line">        <span class="keyword">int</span> x = index + <span class="number">1</span> ; </span><br><span class="line">        <span class="keyword">while</span>(x &lt; sums.length)&#123;</span><br><span class="line">            sums[x] = sums[x] - change ; </span><br><span class="line">            x = x + lowBit(x) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算[left,right]的和</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left , <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> query(right+<span class="number">1</span>) - query(left) ; <span class="comment">//pre[right]-pre[left-1]计算的是[left,right]的区间和</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*查询树状数组*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="comment">//查询只需要向前计算各个位置的和即可</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span>(x &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            sum += sums[x] ; </span><br><span class="line">            x = x - lowBit(x) ; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;树状数组和线段树解决的问题一般都是对数据的区间操作，也就是求一段区间内的数据操作。&lt;/p&gt;
&lt;p&gt;树状数组比较适合于单点修改的问题。线段树则使用较广。&lt;/p&gt;
&lt;h4 id=&quot;lowbit的含义&quot;&gt;&lt;a href=&quot;#lowbit的含义&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="区间问题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/"/>
    
      <category term="树状数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>区间问题-线段树</title>
    <link href="http://example.com/wiki/%E7%AE%97%E6%B3%95/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://example.com/wiki/算法/区间问题/线段树/</id>
    <published>2022-04-06T03:19:11.995Z</published>
    <updated>2022-04-06T03:19:11.995Z</updated>
    
    <content type="html"><![CDATA[<h4>线段树</h4><p>​    线段树常用于维护区间信息，可以在O（lon N ）的时间复杂度内实现单点修改，区间修改，区间查询(区间求和，求区间最大值，求区间最小值)等操作。</p><h4>线段树的基本结构与建树</h4><p>​    线段树将每个长度不为1 的区间划分成左右两个区间递归求解，把整个线段划分为一个树形结构，通过合并左右两区间信息来求得该区间的信息。这种数据结构可以方便的进行大部分的区间操作。</p><p>​    以数组a={10,11,12,13,14}为例，转化为线段树，做法如下所示：设线段树的根节点编号为 1，用数组 $d$来保存我们的线段树$d_i$， 用来保存线段树上编号为$i$ 的节点的值（这里每个节点所维护的值就是这个节点所表示的区间总和）。</p><p>​    从下图可以看出，线段树实际上类似于一个数组二叉树，即根节点表示[l,r]的区间和，左孩子表示[l,mid]的区间和，右孩子表示[mid+1,right]的区间和。不断重复上述操作，就可以构成一个线段树。并且对于$d_i$的左孩子等于$d_{2i}$，右孩子等于$d_{2i+1}$。</p><p>​    假设$d_i$表示的区间是[s,t]，则左孩子表示的区间是[s,$\frac{s+t}{2}$]，右孩子表示的区间是[$\frac{s+t}{2}$+1,t]</p><p><img src="/images/algorithm/image-20220405121030619.png" alt="image-20220404232156224"></p><h5>建树方法</h5><p>​    设当前的根节点为 p，如果根节点管辖的区间长度已经是1 ，则可以直接根据a数组上相应位置的值初始化该节点。否则我们将该区间从中点处分割为两个子区间，分别进入左右子节点递归建树，最后合并两个子节点的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t , <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == t)&#123;</span><br><span class="line">        d[p] = a[s] ; <span class="comment">//如果s==t,则直接是该位置的值</span></span><br><span class="line">    <span class="keyword">return</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = s + ((t-s) &gt;&gt; <span class="number">1</span>) ; <span class="comment">//计算中间坐标</span></span><br><span class="line">    <span class="comment">//构建左右树 , 根据前面的性质，根节点和左右孩子坐标的关系是两倍的关系</span></span><br><span class="line">    build(s,mid,<span class="number">2</span>*p) ;</span><br><span class="line">    build(mid+<span class="number">1</span>,t,<span class="number">2</span>*p+<span class="number">1</span>) ; </span><br><span class="line">    d[p] = d[<span class="number">2</span> * p] + d[<span class="number">2</span> * p + <span class="number">1</span>]  ;<span class="comment">//通过左右孩子，确定根节点</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>查询方法</h4><p>区间查询，比如求区间[l,r]的总和、求区间最大值/最小值等操作。</p><p>![<a href="/images/algorithm/image-20220405205229810.png">image-20220405205229810</a></p><p>查询区间和的关键在于，确定有哪几个参与运算。例如求[1-5]，只需要返回d[1]即可，而求d[2-5]则需要返回d[9]+d[5]+d[3] ,最多可以拆分成log(n)个极大区间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//l和r代表需要求的区间</span></span><br><span class="line"><span class="comment">//s和t代表d[p]所表示的区间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> s , <span class="keyword">int</span> t , <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="comment">//如果[s,t]的区间在[l,r]之间的话，则返回dp[i]</span></span><br><span class="line"><span class="keyword">if</span>(s &gt;= l &amp;&amp; t &lt;= r)&#123;</span><br><span class="line"><span class="keyword">return</span> dp[p] ; <span class="comment">//直接返回当前值</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">int</span> mid =  s + ((t-s) &gt;&gt; <span class="number">1</span>) , sum = <span class="number">0</span> ; </span><br><span class="line">    <span class="comment">//进一步缩小范围</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)&#123;</span><br><span class="line">        sum += getSum(l,r,s,mid,<span class="number">2</span>*p) ; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)&#123;</span><br><span class="line">        sum += getSum(l,r,m+<span class="number">1</span>,t,<span class="number">2</span>*p+<span class="number">1</span>) ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum ; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>线段树的区间修改和懒惰标记</h4><p>​    如果要修改区间[l,r]的元素，则需要把所有包含区间[l,r]的节点遍历一遍，修改一遍，这样做很费时间，通常我们会引入一个懒惰标记。</p><p>​    懒惰标记的作用：延迟对节点信息的修改，进而减少不必要的操作次数。我们通过懒惰标记来标明节点是否被更改，但是不更新该节点的子节点的信息，实质性的修改在下次访问带有标记的节点的时候才进行。</p><p>​    如图下所示：增加了数组t，用于作为元素的懒惰标记。</p><p>![<a href="/images/algorithm/image-20220405220242365.png">image-20220405220242365</a></p><p>​        假如给区间[3,5]的每个数都加上5，那么只需要找到[3,5]的极大区间，可以得出包含[3,5]的极大区间[3,3],[4,5] 。下面给出的是区间加上某个值的代码，如果要改成区间减去某个值，只需要把 += 改为 -= ， 如果要改成区间等于某个值，只需要把 += 改成 = 即可，以此类比。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> c , <span class="keyword">int</span> s , <span class="keyword">int</span> t, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// [l, r] 为修改区间, c 为被修改的元素的变化量, [s, t] 为当前节点包含的区间, p</span></span><br><span class="line">  <span class="comment">// 为当前节点的编号</span></span><br><span class="line">  <span class="keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) &#123;</span><br><span class="line">    d[p] += (t - s + <span class="number">1</span>) * c, b[p] += c;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;  <span class="comment">// 当前区间为修改区间的子集时直接修改当前节点的值,然后打标记,结束修改</span></span><br><span class="line">  <span class="keyword">int</span> m = s + ((t - s) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (b[p] != <span class="number">0</span>  &amp;&amp; s != t) &#123;</span><br><span class="line">    <span class="comment">// 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值</span></span><br><span class="line">    d[p * <span class="number">2</span>] += b[p] * (m - s + <span class="number">1</span>), d[p * <span class="number">2</span> + <span class="number">1</span>] += b[p] * (t - m);</span><br><span class="line">    b[p * <span class="number">2</span>] += b[p], b[p * <span class="number">2</span> + <span class="number">1</span>] += b[p];  <span class="comment">// 将标记下传给子节点</span></span><br><span class="line">    b[p] = <span class="number">0</span>;                                <span class="comment">// 清空当前节点的标记</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= m) update(l, r, c, s, m, p * <span class="number">2</span>); <span class="comment">//继续寻找极大区间间</span></span><br><span class="line">  <span class="keyword">if</span> (r &gt; m) update(l, r, c, m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">// 继续寻找极大区间</span></span><br><span class="line">  d[p] = d[p * <span class="number">2</span>] + d[p * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>区间查询(区间求和)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> s, <span class="keyword">int</span> t , <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">     <span class="comment">// 当前区间为询问区间的子集时直接返回当前区间的和</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= s &amp;&amp; r &gt;= t)&#123;</span><br><span class="line">        <span class="keyword">return</span> d[p] ; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> m = s + ((t - s) &gt;&gt; <span class="number">1</span>) ; </span><br><span class="line">    <span class="comment">//检查惰性标记</span></span><br><span class="line">    <span class="keyword">if</span>(b[p] != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//如果当前节点懒标记非空，则更新当前节点的两个子节点的值和懒惰标记</span></span><br><span class="line">        d[p * <span class="number">2</span>] += b[p] * (m - s + <span class="number">1</span>) ,d[p * <span class="number">2</span> + <span class="number">1</span>] += b[p] * (t - m) ;</span><br><span class="line">        b[p * <span class="number">2</span>] += b[p],b[p * <span class="number">2</span> + <span class="number">1</span>] += b[p] ;</span><br><span class="line">        b[p] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span>( l &lt;= m)&#123;</span><br><span class="line">        sum = getSum(l,r,s,m,p * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r &gt; m)&#123;</span><br><span class="line">        sum += getSum(l,r,m+<span class="number">1</span>,t,p * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4&gt;线段树&lt;/h4&gt;

&lt;p&gt;​    线段树常用于维护区间信息，可以在O（lon N ）的时间复杂度内实现单点修改，区间修改，区间查询(区间求和，求区间最大值，求区间最小值)等操作。&lt;/p&gt;
&lt;h4&gt;线段树的基本结构与建树&lt;/h4&gt;

&lt;p&gt;​    线段树将每个长度不为1
      
    
    </summary>
    
      <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="区间问题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/"/>
    
      <category term="线段树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    
      <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最大子序列和</title>
    <link href="http://example.com/wiki/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/"/>
    <id>http://example.com/wiki/算法/动态规划/最长子序列和/</id>
    <published>2022-04-06T03:19:11.994Z</published>
    <updated>2022-04-06T03:19:11.994Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>注：子数组 是数组中的一个连续部分。</p><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>动态规划的几个步骤:</p><blockquote><ol><li>确定状态</li><li>找到转移公式</li><li>确定初始条件以及边界条件</li><li>计算结果</li></ol><p>确定状态</p></blockquote><p>定义数组dp[n],其中dp[i]表示终点在i的子序列的最佳子序列和。</p><blockquote><p>找到转移公式</p></blockquote><p>假设dp[i]是终点在i的子序列的最佳子序列和。那么对于dp[i+1]很容易判断，如果前面的子序列和是负数，那就直接舍弃，如果不是就可以加上。dp[i+1] = max(dp[i],0) + num[i+1] 。</p><blockquote><p>确定初始条件和边界条件</p></blockquote><p>初始条件也就是dp[n]元素都为0 ，边界条件为当i=0的时候,dp[i] = num[0] .</p><p>当遍历完成之后，只需要返回数组中的最大值即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = num.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    dp[<span class="number">0</span>] = num[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        dp[i] = (dp[i - <span class="number">1</span>]&gt;=<span class="number">0</span>?dp[i-<span class="number">1</span>]:<span class="number">0</span>) + num[i];</span><br><span class="line">        max =  max&gt;dp[i]?max:dp[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;br&gt;注：子数组
      
    
    </summary>
    
      <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>前缀和-二维前缀和</title>
    <link href="http://example.com/wiki/%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <id>http://example.com/wiki/算法/前缀和/二维前缀和/</id>
    <published>2022-04-06T03:19:11.993Z</published>
    <updated>2022-04-06T03:19:11.993Z</updated>
    
    <content type="html"><![CDATA[<p>二维前缀和解决的是二维矩阵中的矩形区域求和问题。</p><p>二维前缀和数组中的每一个格子记录的是「以当前位置为区域的右下角（区域左上角恒定为原数组的左上角）的区域和」</p><p><img src="/images/二维前缀和.png" alt="二维前缀和"></p><p>简单的理解二维矩阵的前缀和，就是在一维的基础上，减去一些重复部分的矩阵。通常我们会对二维前缀和矩阵增加哨兵进行处理，这样就不用处理 i = 0 的情况。所以在计算前缀和的时候，从 i = 1 开始处理。</p><p>简单推理一下二维前缀和的计算公式。以sum(i,j)为例。sum(i,j)是计算（i,j）与(0,0)围成的区域大小。而已知的只有比(i,j)更小坐标围成区域的和，以及position(i,j)的值。如果要计算sum(i,j),可以通过绘图得出如下等式：<br>sum(i,j) = sum(i-1,j) + sum(i,j-1) - sum(i-1,j-1) + position(i,j) 。</p><p>所以在计算二维前缀和的时候，就可以根据上面的等式进行推导。</p><p>示例代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] sum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length, m = n == <span class="number">0</span> ? <span class="number">0</span> : matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 与「一维前缀和」一样，前缀和数组下标从 1 开始，因此设定矩阵形状为 [n + 1][m + 1]（模板部分）</span></span><br><span class="line">        sum = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 预处理除前缀和数组（模板部分）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                sum[i][j] = sum[i - <span class="number">1</span>][j] + sum[i][j - <span class="number">1</span>] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + matrix[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 求某一段区域和 [i, j] 的模板是 sum[x2][y2] - sum[x1 - 1][y2] - sum[x2][y1 - 1] + sum[x1 - 1][y1 - 1];（模板部分）</span></span><br><span class="line">        <span class="comment">// 但由于我们源数组下标从 0 开始，因此要在模板的基础上进行 + 1</span></span><br><span class="line">        x1++; y1++; x2++; y2++;</span><br><span class="line">        <span class="keyword">return</span> sum[x2][y2] - sum[x1 - <span class="number">1</span>][y2] - sum[x2][y1 - <span class="number">1</span>] + sum[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;二维前缀和解决的是二维矩阵中的矩形区域求和问题。&lt;/p&gt;
&lt;p&gt;二维前缀和数组中的每一个格子记录的是「以当前位置为区域的右下角（区域左上角恒定为原数组的左上角）的区域和」&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/二维前缀和.png&quot; alt=&quot;二维前缀和&quot;&gt;&lt;/p
      
    
    </summary>
    
      <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="http://example.com/wiki/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://example.com/wiki/算法/位运算/位运算/</id>
    <published>2022-04-06T03:19:11.992Z</published>
    <updated>2022-04-06T03:49:33.036Z</updated>
    
    <content type="html"><![CDATA[<h4 id="统计x中二进制为0的个数"><a href="#统计x中二进制为0的个数" class="headerlink" title="统计x中二进制为0的个数"></a>统计x中二进制为0的个数</h4><p>如果要统计x二进制为0的个数，有两种方法可以解决，一种是通过求每个位置的二进制，如果是1则加1 。另一种通过lowBit方法，只要x不为0就加1。</p><blockquote><p>方法1</p></blockquote><p>方法1的局限性在于，需要确定x的范围,这里x的位数最多32位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bitCount</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>  ; </span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">1</span> ; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">32</span> ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((x &amp; temp) != <span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp &lt;&lt; <span class="number">1</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>方法2</p></blockquote><p>lowBit函数的作用是返回x末尾为1的位置。例如 4(100),则lowBit(4)=3 ，这样只需要不断取出末尾为1，直到x为0，结束操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x) ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bitCount</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">        count++ ;</span><br><span class="line">        x = x &gt;&gt; lowBit(x) ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h4 id="如何通过位操作，建立掩码"><a href="#如何通过位操作，建立掩码" class="headerlink" title="如何通过位操作，建立掩码"></a>如何通过位操作，建立掩码</h4><p>有时候，通过位运算的性质，可以构建一个掩码来加快运算和判断。例如，如果要判定一个数是否为质数，假设该数不超过 20 。20以内的二进制有2,3,5,7,11,13,17,19。那么我们可以构建掩码来判断这个数是不是质数，假设当前数为C，通过20内的二进制，构建一个数，这个数对应质数位置为1，其余位为0，记作mask ，那么通过$2^C&amp;mask$可以快速判断这个数是不是质数，如果为0则是质数，反之不是。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;统计x中二进制为0的个数&quot;&gt;&lt;a href=&quot;#统计x中二进制为0的个数&quot; class=&quot;headerlink&quot; title=&quot;统计x中二进制为0的个数&quot;&gt;&lt;/a&gt;统计x中二进制为0的个数&lt;/h4&gt;&lt;p&gt;如果要统计x二进制为0的个数，有两种方法可以解决，一种是通过
      
    
    </summary>
    
      <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="位运算" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    
      <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>48.旋转数组</title>
    <link href="http://example.com/wiki/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/48.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <id>http://example.com/wiki/算法/Leetcode/数组/48.旋转数组/</id>
    <published>2022-04-06T03:19:11.991Z</published>
    <updated>2022-04-06T03:19:11.991Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  通过辅助数组进行实现</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[][] totataMatrix = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix.length] ;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span> , j = <span class="number">0</span> , len = matrix.length;</span><br><span class="line">      <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; len ; j++)&#123;</span><br><span class="line">              totataMatrix[j][len-i-<span class="number">1</span>] = matrix[i][j];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; len ; j++)&#123;</span><br><span class="line">              matrix[i][j] = totataMatrix[i][j];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果需要原地旋转，那就必须需要考虑数组下标之间的关系，然后进行旋转操作</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotateTwo</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span> , j = <span class="number">0</span> , len = matrix.length;</span><br><span class="line">      <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; len / <span class="number">2</span>; i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; (len+<span class="number">1</span>) /<span class="number">2</span> ; j++)&#123;</span><br><span class="line">              <span class="keyword">int</span> temp = matrix[i][j] ;</span><br><span class="line">              matrix[i][j] = matrix[len-j-<span class="number">1</span>][i] ;</span><br><span class="line">              matrix[len-j-<span class="number">1</span>][i] = matrix[len-i-<span class="number">1</span>][len-j-<span class="number">1</span>] ;</span><br><span class="line">              matrix[len-i-<span class="number">1</span>][len-j-<span class="number">1</span>] = matrix[j][len-i-<span class="number">1</span>] ;</span><br><span class="line">              matrix[j][len-i-<span class="number">1</span>] = temp ;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数组选择90度又可以转换为数组翻转问题，首先进行上下翻转，然后再根据主对角线进行翻转。</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotateThree</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span> , j = <span class="number">0</span> , len = matrix.length;</span><br><span class="line">      <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; len / <span class="number">2</span>; i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; (len+<span class="number">1</span>) /<span class="number">2</span> ; j++)&#123;</span><br><span class="line">              <span class="keyword">int</span> temp = matrix[i][j] ;</span><br><span class="line">              matrix[i][j] = matrix[len-j-<span class="number">1</span>][i] ;</span><br><span class="line">              matrix[len-j-<span class="number">1</span>][i] = matrix[len-i-<span class="number">1</span>][len-j-<span class="number">1</span>] ;</span><br><span class="line">              matrix[len-i-<span class="number">1</span>][len-j-<span class="number">1</span>] = matrix[j][len-i-<span class="number">1</span>] ;</span><br><span class="line">              matrix[j][len-i-<span class="number">1</span>] = temp ;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>48.旋转数组</title>
    <link href="http://example.com/wiki/%E7%AE%97%E6%B3%95/Leetcode/%E9%93%BE%E8%A1%A8/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>http://example.com/wiki/算法/Leetcode/链表/19.删除链表的倒数第N个结点/</id>
    <published>2022-04-06T03:19:11.991Z</published>
    <updated>2022-04-06T03:19:11.991Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。(进阶：你能尝试使用一趟扫描实现吗？)</p><blockquote><p>示例 1：</p></blockquote><pre><code>输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5]</code></pre><blockquote><p>示例 2：</p></blockquote><pre><code>输入：head = [1], n = 1输出：[]</code></pre><blockquote><p>示例 3：</p></blockquote><pre><code>输入：head = [1,2], n = 1输出：[1]</code></pre><h3 id="解法思路"><a href="#解法思路" class="headerlink" title="解法思路"></a>解法思路</h3><p>从题目分析，我们需要删除链表的倒数第N个结点，那么我们就必须知道哪个结点是倒数第N个结点。确定一个结点在列表中的位置大概有如下几种方法。</p><blockquote><p>方法一</p></blockquote><p>先确定整个列表的长度，然后就能够确定结点所在的位置(可以通过堆栈或者数组存放数据元素，通过数组有利于操作)。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;ListNode&gt; listNodes = <span class="keyword">new</span> ArrayList&lt;&gt;()  ;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span> ;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            len++ ;</span><br><span class="line">            listNodes.add(head) ;</span><br><span class="line">            head = head.next ;</span><br><span class="line">        &#125;</span><br><span class="line">        listNodes.add(head) ; </span><br><span class="line">        <span class="keyword">if</span>(len-n-<span class="number">1</span>&lt;<span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> listNodes.get(<span class="number">1</span>) ;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            listNodes.get(len-n-<span class="number">1</span>).next = listNodes.get(len-n).next ;</span><br><span class="line">            <span class="keyword">return</span> listNodes.get(<span class="number">0</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>方法二</p></blockquote><p>通过快慢指针法，让一个指针永远比当前指针快n个元素，那么当快指针到达末尾的时候，就能够确定倒数第N个元素。示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode p , q , pre ;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        p = head ; <span class="comment">// 快指针</span></span><br><span class="line">        q = head ;<span class="comment">// 慢指针</span></span><br><span class="line">        pre = q ; <span class="comment">//用于记录q的前一个元素，有利于元素的删除</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; n ; i++) <span class="comment">//让p比q快n个元素</span></span><br><span class="line">            p = p.next ;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            p = p.next ;</span><br><span class="line">            pre = q ;</span><br><span class="line">            q = q.next ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre == q)&#123;       <span class="comment">// 判断删除元素是否为头</span></span><br><span class="line">            <span class="keyword">return</span> q.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre.next = q.next ;</span><br><span class="line">            <span class="keyword">return</span> head ; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目介绍&quot;&gt;&lt;a href=&quot;#题目介绍&quot; class=&quot;headerlink&quot; title=&quot;题目介绍&quot;&gt;&lt;/a&gt;题目介绍&lt;/h3&gt;&lt;p&gt;给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。(进阶：你能尝试使用一趟扫描实现吗？)&lt;/p&gt;
&lt;bloc
      
    
    </summary>
    
      <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/Leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>36.有效数独</title>
    <link href="http://example.com/wiki/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/36.%E6%9C%89%E6%95%88%E6%95%B0%E7%8B%AC/"/>
    <id>http://example.com/wiki/算法/Leetcode/数组/36.有效数独/</id>
    <published>2022-04-06T03:19:11.990Z</published>
    <updated>2022-04-06T03:19:11.990Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public boolean <span class="function"><span class="title">isValidSudokuTwo</span>(<span class="params">char[][] board</span>)</span> &#123;</span><br><span class="line">        int i = <span class="number">0</span> , j = <span class="number">0</span> , k = <span class="number">0</span> , l = <span class="number">0</span> , idx  ;</span><br><span class="line">        HashMap&lt;Integer, HashSet&lt;Character&gt;&gt; area = <span class="keyword">new</span> HashMap&lt;Integer, HashSet&lt;Character&gt;&gt;() ;</span><br><span class="line">        <span class="comment">//判断行列是否符合数独条件</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; board.length ; i++)&#123;</span><br><span class="line">            HashMap&lt;Character, Integer&gt; row = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;() ;</span><br><span class="line">            HashMap&lt;Character, Integer&gt; col = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;() ;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; board.length ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] != <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(row.containsKey(board[i][j]))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        row.put(board[i][j],<span class="number">1</span>) ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(board[j][i] != <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(col.containsKey(board[j][i]))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        col.put(board[j][i],<span class="number">1</span>) ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                idx = (i/<span class="number">3</span>)*<span class="number">3</span> + j/<span class="number">3</span> ;</span><br><span class="line">                <span class="keyword">if</span>(!area.containsKey(idx))&#123;</span><br><span class="line">                    area.put(idx,<span class="keyword">new</span> HashSet&lt;Character&gt;()) ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(area.get(idx).contains(board[i][j]))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    area.get(idx).add(board[i][j]) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>  ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
      <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-数学</title>
    <link href="http://example.com/wiki/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E5%AD%A6/%E6%95%B0%E5%AD%A6/"/>
    <id>http://example.com/wiki/算法/Leetcode/数学/数学/</id>
    <published>2022-04-06T03:19:11.989Z</published>
    <updated>2022-04-06T03:50:30.781Z</updated>
    
    <content type="html"><![CDATA[<h4 id="判断一个数是否是质数"><a href="#判断一个数是否是质数" class="headerlink" title="判断一个数是否是质数"></a>判断一个数是否是质数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>  n = (<span class="keyword">int</span>)Math.sqrt(x)+<span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n  ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x % i == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span> ; </span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure><h4 id="奇数和偶数的性质"><a href="#奇数和偶数的性质" class="headerlink" title="奇数和偶数的性质"></a>奇数和偶数的性质</h4><p>奇数通项公式可以写成$S_n=1+2d$。<br>偶数通项公式可以写成$S_n=2d$。</p><p>由奇数通项公式和偶数通项公式可以看出，奇数和偶数之间的差距就少了1，也就是说偶数+1等于奇数。所以一个区间内的奇数和偶数个数要么是一半一半，要么是一方比另一方多1。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;判断一个数是否是质数&quot;&gt;&lt;a href=&quot;#判断一个数是否是质数&quot; class=&quot;headerlink&quot; title=&quot;判断一个数是否是质数&quot;&gt;&lt;/a&gt;判断一个数是否是质数&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr
      
    
    </summary>
    
      <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数学" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="http://example.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法</title>
    <link href="http://example.com/wiki/%E7%AE%97%E6%B3%95/Leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/KMP/"/>
    <id>http://example.com/wiki/算法/Leetcode/字符串/KMP/</id>
    <published>2022-04-06T03:19:11.987Z</published>
    <updated>2022-04-06T03:19:11.987Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#1-问题描述">1. 问题描述</a></li><li><a href="#2-解题思路">2. 解题思路</a></li></ul><h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h3><p>今天的问题很简单，就是给定两个字符串text和pattern，让你找出在text中是否存在一个序列等于pattern,如果存在就返回true,如果不存在就返回false 。</p><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h3><p>从题目描述上来看，很容易看出这题目是关于字符串匹配的问题，也就是从一段文本中，找出某个模式的全部出现位置的问题。</p><blockquote><ol><li>朴素的字符串匹配算法</li></ol></blockquote><p>用一个循环找出所有有效位移，对text每个字符进行检测，然后匹配pattern，如果匹配成功就返回下标。如果失败，就移动text下一个位置，重复操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len_h , len_s , i , j = <span class="number">0</span> ;</span><br><span class="line">        len_s = needle.length() ;</span><br><span class="line">        <span class="keyword">if</span>(len_s == <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        len_h = haystack.length() ;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt;= len_h - len_s ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(haystack.charAt(i)==needle.charAt(j))&#123;</span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;len_s;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(haystack.charAt(i+j)!=needle.charAt(j))</span><br><span class="line">                        <span class="keyword">break</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=len_s)</span><br><span class="line">                    <span class="keyword">return</span> i ;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    j = <span class="number">0</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><blockquote><ol><li>KMP算法</li></ol></blockquote><p>KMP算法的巧妙之处就是利用已经匹配字符串来确定下一次匹配开始的位置。这就是和朴素字符串匹配算法的区别，朴素字符串匹配算法每次匹配完毕之后，只是从下一个字符开始进行匹配，那么就浪费了已经匹配过字符串的有效信息，所以造成时间上的浪费。如何确定下一字符开始匹配的位置呢？假设已经匹配模式串pattern的位置为j,也就是从text的位置i开始 text[i…..,i+j] = pattern[0……,0+j]</p><blockquote><p>KMP算法的前缀函数(next)</p></blockquote><p>前缀函数 $\pi$(i)(0 $\leq$ i &lt; m)表示s 的子串 s[0:i] 的最长的相等的真前缀与真后缀的长度。特别地，如果不存在符合条件的前后缀，那么 $\pi$(i) = 0。其中真前缀与真后缀的定义为不等于自身的的前缀与后缀。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求解字符前缀函数</span></span><br><span class="line"><span class="comment"> * /</span></span><br><span class="line"><span class="comment"> public int[] getNext(String s)&#123;</span></span><br><span class="line"><span class="comment">        int len , k ,q ;</span></span><br><span class="line"><span class="comment">        len = s.length() ;</span></span><br><span class="line"><span class="comment">        int[] next = new int[len];</span></span><br><span class="line"><span class="comment">        next[0] = 0 ;</span></span><br><span class="line"><span class="comment">        for(q = 1,k=0 ; q&lt; len ; q++)&#123;  //长字符串的前缀建立在短字符前缀的匹配上。</span></span><br><span class="line"><span class="comment">            while (k&gt;0&amp;&amp;s.charAt(k)!=s.charAt(q))&#123;</span></span><br><span class="line"><span class="comment">                    k = next[k-1] ;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if(s.charAt(q) == s.charAt(k))&#123;</span></span><br><span class="line"><span class="comment">                k = k+1 ;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            next[q] = k ;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return next ;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过前缀函数进行字符串的匹配</span></span><br><span class="line"><span class="comment"> * /</span></span><br><span class="line"><span class="comment">    public int Matcher(String t , String p )&#123;</span></span><br><span class="line"><span class="comment">        int   q , i;</span></span><br><span class="line"><span class="comment">        int n = t.length(), m = p.length();</span></span><br><span class="line"><span class="comment">        if (m == 0) &#123;</span></span><br><span class="line"><span class="comment">            return 0;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        int[] next = getNext(p) ;</span></span><br><span class="line"><span class="comment">        q = 0 ;</span></span><br><span class="line"><span class="comment">        for(i = 0 ,q=0; i &lt; n ;i++)&#123;</span></span><br><span class="line"><span class="comment">            while(q&gt;0&amp;&amp;p.charAt(q)!=t.charAt(i))&#123;  //如果不匹配则移动到下一个位置</span></span><br><span class="line"><span class="comment">                q = next[q-1] ;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if(p.charAt(q) == t.charAt(i))&#123;</span></span><br><span class="line"><span class="comment">                q = q+1 ;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if(q == m)&#123;</span></span><br><span class="line"><span class="comment">                return i-m+1 ;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return -1 ;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure><blockquote><p>个人总结</p></blockquote><p>KMP算法主要在于计算前缀函数next，前缀函数的计算依据最长相同前后缀长度为依据来计算。通过next来获取到移动的位置。</p><p>对于next前缀函数的计算过程，patten(q) 和 patten(k) 不等说明了，在前一个（q-1）的最长前后缀匹配的位置，增加一个text(q)后，patten[0-&gt;next(q-1),next(q-1)+1] 和patten[(q-1)-next(q-1)-&gt;q]并不相等(因为新增的最后一个字符和前一个patten(q-1)字符串的最长前后缀并不相等)，所以需要进一步比较next[next(q-1)] 是否满足，patten[0-&gt;k+1] == patten[k-q,q] , 如果相等，则另k+1 , next[q] = k 。<br><img src="/images/时间复杂度.PNG" alt="a6"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-问题描述&quot;&gt;1. 问题描述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-解题思路&quot;&gt;2. 解题思路&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-问题描述&quot;&gt;&lt;a href=&quot;#1-问题描述&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="经典算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>SVN使用入门</title>
    <link href="http://example.com/wiki/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/SVN/%E7%AE%80%E4%BB%8B/"/>
    <id>http://example.com/wiki/程序技术/版本控制/SVN/简介/</id>
    <published>2022-04-06T03:19:11.986Z</published>
    <updated>2022-04-06T03:53:58.396Z</updated>
    
    <content type="html"><![CDATA[<h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><p>我们可以通过小乌龟来完成SVN的版本控制，小乌龟的下载地址<a href="https://tortoisesvn.net/downloads.html">https://tortoisesvn.net/downloads.html</a>,如果需要汉化版本，可以在页面下方找到汉化补丁，安装完成小乌龟后，下载汉化补丁，然后运行汉化补丁即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;如何使用&quot;&gt;&lt;a href=&quot;#如何使用&quot; class=&quot;headerlink&quot; title=&quot;如何使用&quot;&gt;&lt;/a&gt;如何使用&lt;/h4&gt;&lt;p&gt;我们可以通过小乌龟来完成SVN的版本控制，小乌龟的下载地址&lt;a href=&quot;https://tortoisesvn.net/
      
    
    </summary>
    
      <category term="程序技术" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/"/>
    
      <category term="SVN" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/SVN/"/>
    
    
      <category term="SVN" scheme="http://example.com/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>Git常见的问题及解决方案</title>
    <link href="http://example.com/wiki/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/wiki/程序技术/版本控制/Git/问题/</id>
    <published>2022-04-06T03:19:11.985Z</published>
    <updated>2022-04-06T03:19:11.985Z</updated>
    
    <content type="html"><![CDATA[<!--编写md文件的时候，需要指明文章名称title,文章分类categroies,文章标签tags--><h3 id="Git使用教程"><a href="#Git使用教程" class="headerlink" title="Git使用教程"></a>Git使用教程</h3><h2 id="Git常见问题"><a href="#Git常见问题" class="headerlink" title="Git常见问题"></a>Git常见问题</h2><h3 id="1-当能够正常运行的项目突然无法运行，出现找不到资源文件错误的时候。"><a href="#1-当能够正常运行的项目突然无法运行，出现找不到资源文件错误的时候。" class="headerlink" title="1. 当能够正常运行的项目突然无法运行，出现找不到资源文件错误的时候。"></a>1. 当能够正常运行的项目突然无法运行，出现找不到资源文件错误的时候。</h3><pre><code>首先，能运行就标明项目本身并没有问题。对于资源文件找不到，可能就和系统的缓存加载有关。</code></pre><p>所以这个时候，可以对项目的依赖文件进行重新的审查，如果没有问题，再查看依赖是否有问题。对于Maven项目的依赖问题，<br>可以重新clean被依赖的工程，再重新install被依赖的工程。重新加载资源文件。</p><h3 id="2-git提交代码到Github时候，出现fatal-unable-to-access-‘https-github-com-zzcpage-zzcpage-github-io-git-‘-OpenSSL-SSL-read-Connection-was-reset-errno-10054"><a href="#2-git提交代码到Github时候，出现fatal-unable-to-access-‘https-github-com-zzcpage-zzcpage-github-io-git-‘-OpenSSL-SSL-read-Connection-was-reset-errno-10054" class="headerlink" title="2. git提交代码到Github时候，出现fatal: unable to access ‘https://github.com/zzcpage/zzcpage.github.io.git/‘: OpenSSL SSL_read: Connection was reset, errno 10054"></a>2. git提交代码到Github时候，出现<font color="red">fatal: unable to access ‘<a href="https://github.com/zzcpage/zzcpage.github.io.git/">https://github.com/zzcpage/zzcpage.github.io.git/</a>‘: OpenSSL SSL_read: Connection was reset, errno 10054</font></h3><p>产生的原因：一般是这是因为服务器的SSL证书没有经过第三方机构的签署，所以才报错。</p><p>解决方法：解除ssl验证后，再次git即可。</p><p>通过<font color="red">git config —global http.sslVerify “false”</font>命令进行解除SSL验证，解除完之后，再次Git即可提交成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!--编写md文件的时候，需要指明文章名称title,文章分类categroies,文章标签tags--&gt;
&lt;h3 id=&quot;Git使用教程&quot;&gt;&lt;a href=&quot;#Git使用教程&quot; class=&quot;headerlink&quot; title=&quot;Git使用教程&quot;&gt;&lt;/a&gt;Git使用教程&lt;/h
      
    
    </summary>
    
      <category term="程序技术" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Git" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/Git/"/>
    
    
      <category term="Git" scheme="http://example.com/tags/Git/"/>
    
      <category term="Bug解决方案" scheme="http://example.com/tags/Bug%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>Redis初步了解</title>
    <link href="http://example.com/wiki/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/%E5%88%86%E5%B8%83%E5%BC%8F/Redis/"/>
    <id>http://example.com/wiki/程序技术/分布式/Redis/</id>
    <published>2022-04-06T03:19:11.984Z</published>
    <updated>2022-04-06T03:19:11.984Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是Redis？"><a href="#什么是Redis？" class="headerlink" title="什么是Redis？"></a>什么是Redis？</h4><p>Redis是一个开源的使用ANSI C语言编写，遵循BSD协议，支持网络，可基于内存亦可持久化的日志型,Key-Value数据库，并提供多种语言的API。</p><p>Redis具有如下特点：</p><blockquote><ol><li>支持数据的持久化：可以将内存中的数据保存在磁盘中，重启的时候再次加载进行使用。</li><li>不仅支持简单的key-value类型的数据，同时还提供list,set,sorted set,hash等数据结构的存储，因此也被称为数据结构服务器。</li><li>支持master-slave模式的数据备份。<br>Redis作为现在流行的Key-Value数据库，优势在于:</li><li>基于内存，性能极高。Redis读的速度是110000次/秒，写的速度是81000次/秒</li><li>支持丰富的数据,例如key/value,list,set,sorted set,hash等数据结构</li><li>具有丰富的特性，比如支持publish/subscribe,通知,key过期等。</li></ol></blockquote><h4 id="Redis的安装步骤"><a href="#Redis的安装步骤" class="headerlink" title="Redis的安装步骤"></a>Redis的安装步骤</h4><blockquote><ol><li><p>在官网上下载redis的安装包<br>Windows版本由Microsoft Open Tech group小组维护，GitHUb版本下载地址:<a href="https://github.caom/MSOpenTech/redis/releases">https://github.caom/MSOpenTech/redis/releases</a></p></li><li><p>启动Redis服务<br>下载安装后，运行redis-server。exe，启动Redis服务，Redis服务端的默认连接端口是6379。</p></li><li><p>Redis的配置</p></li></ol></blockquote><p>Windows下的配置文件位：redis.windows.conf,Linux下的配置文件为:redis.conf。<br>在启动redis-server的时候，可以在命令后面指定配置文件，例如:redis-server redis.conf。</p><p>Redis配置文件可用的参数如下所示:<br>|参数|功能|实例|<br>|:——:|:——:|:——:|<br>|daemonize|Redis默认不是以守护进程的方式运行，设置为yes,启用守护进程|daemonize yes<br>|pidfile|当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以使用pidfile指定路径|pidfile /var/run/redis.pid|<br>|port|指定Redis监听端口，默认端口为6379|port 6379|<br>|bind|绑定的主机地址，可以用于限制连接|bing 127.0.0.1|<br>|timeout|客户端闲置timeout时间后关闭连接，如果设置为0，则表示关闭此功能|timeout 0 |<br>|loglevel|指定日志记录级别。Redis总共支持四个级别：debug,verbose,notice,warning,默认为verbose|loglevel verbose|<br>|logfile|日志记录方式，默认为标准输出,也可以自己指定日志文件的路径，例如”xxx/xxx/xxx.txt”|logfilt stdout|<br>|databases|设置数据库的数量，默认数据库为0|databases 16|<br>|save <seconds> <changes>|指定seconds时间内，有changes次更新操作，就将数据同步到数据文件|save 900 1|<br>|rdbcompression|指定存储至本地数据库时是否压缩数据，默认为yes,Redis采用LZF压缩|rdbcompression yes|<br>|dbfilename|指定本地数据库文件名，默认值为dump.rdb|dbfilename dump.rdb|<br>|dir|数据库镜像备份的文件放置的路径|dir ./|<br>|slaveof <masterip> <masterport>| 设置改数据库为其他数据库的slvae数据库，参数为master服务的IP地址及端口，在Redis启动时，会自动从master进行数据同步|slaveof 127.0.0.1 5000|<br>|masterauth <masterpassword>|当master服务设置了密码保护时，slave服务连接master的密码|Masterauth password|<br>|requriepass|设置Redis连接密码|requirepass password|<br>|maxclients|设置同一时间最大客户端连接数，默认无限制|maxclients 128|<br>|maxmemory<bytes>|指定Redis最大内存限制，当内存满了的时候，redis会尝试剔除设置过expire信息的key，而不管改key的过期时间是否到达|Maxmemory 1024|<br>|appendonly|指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘|appendonly no|<br>|appendfilename|指定更新日志文件名，默认为appendonly.aof|appendflename appendonly.aof|<br>|appendfsync|指定更新日志条件，共有三个可选值。no:表示等操作系统进行数据缓存时同步到磁盘，最快的方式。always:表示每次更新操作后手动调用。fsync()将数据写到磁盘，安全但是有点慢。everysec：表示每秒同步一次，默认值。|appendfsync everysec|<br>|vm-enabled|指定是否启用虚拟内存机制，默认值为no|vm-enabled no|<br>|vm-swap-file|虚拟内存文件路径，默认为/tmp/redis.swap|vm-swap-file /tmp/redis.swap|<br>|vm-max-memory|将所有大于vm-max-memory的数据存入虚拟内存，当cm0max0memory设置为0的时候，将所有value都存在磁盘，默认值为0，最好不要使用默认值|vm-max-memory 0|<br>|vm-page-size|设置虚拟内存的页大小|vm-page-size 32|<br>|vm-pages|设置swap文件中的page数量|vm-pages 134217728|<br>|vm-max-threads|设置访问swap文件的线程数，最好不要超过机器的核数。默认为4|vm-max-threads 4|<br>|glueoutputbuf|设置在想客户端应答时，是否把较小的包合并为一个包发送，默认为开启|glueoutputbuf yes|<br>|hash-max-zipmap-entries|当hash中包含超过指定元素个数并且最大的元素没有超过临界时，hash将以一种特殊的编码方式来存储，可以大大减少内存使用。|hash-max-zipmap-entries 64/hash-max-zipmap-value 512|<br>|activerehashing|开启后，redis将在每100毫秒使用1毫秒CPU时间，来对redis的hash表进行重新hash,可以降低内存的使用，默认开启。|activerehashing yes|</p><h4 id="Redis的数据类型和操作"><a href="#Redis的数据类型和操作" class="headerlink" title="Redis的数据类型和操作"></a>Redis的数据类型和操作</h4><p>Redis支持五种数据类型:string(字符串),hash(哈希),list(列表),set(集合)以及sorted set（有序集合）.</p><blockquote><h4 id="1-String类型"><a href="#1-String类型" class="headerlink" title="1. String类型"></a>1. String类型</h4></blockquote><p>string是Redis最基本的类型，一个key对应一个value。string类型可以包含任何数据，比如jpg图片或序列化的对象。一个key最大能存储512M。</p><blockquote><p>set和get操作string类型</p></blockquote><p>set s1 v2<br>get s1</p><blockquote><h4 id="2-hash类型"><a href="#2-hash类型" class="headerlink" title="2. hash类型"></a>2. hash类型</h4></blockquote><p>Redis的hash类型是一个string类型的field和value的映射表，特别适合用于存储对象。<br>string类型的key,value类型，一般用于存储单独的键值对的类型，而对于hash类型则是key-file类型，一个键对应了一个对象，而对象内部可以具有多个属性。</p><blockquote><p>hset和hget操作hash类型<br>hset key s1 v1 s2 v2…</p><h4 id="3-list类型"><a href="#3-list类型" class="headerlink" title="3. list类型"></a>3. list类型</h4></blockquote><p>list类型是一个双向键表，每个子元素都是string类型，最多存储2^32-1个元素，大约40多亿。<br>可以使用lpush和lpop进行从链表头和尾添加和删除元素。操作的key可以理解为链表的名字。</p><blockquote><p>lpush和lpop操作list类型<br>lpush list_name value</p><h4 id="4-set类型"><a href="#4-set类型" class="headerlink" title="4. set类型"></a>4. set类型</h4></blockquote><p>set是string类型的无序集合，最大可以包含大约40多亿个元素。集合可以添加删除，求交并差。<br>key可以理解为集合的名字。通过sadd添加元素。</p><blockquote><p>sadd 操作set类型</p><h4 id="5-sorted-set类型"><a href="#5-sorted-set类型" class="headerlink" title="5. sorted set类型"></a>5. sorted set类型</h4></blockquote><p>sorted set不允许重复的成员，在set的基础上增加了一个顺序属性，并且每个元素可以关联一个double类型的score。<br>sorted set会根据score进行排序操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是Redis？&quot;&gt;&lt;a href=&quot;#什么是Redis？&quot; class=&quot;headerlink&quot; title=&quot;什么是Redis？&quot;&gt;&lt;/a&gt;什么是Redis？&lt;/h4&gt;&lt;p&gt;Redis是一个开源的使用ANSI C语言编写，遵循BSD协议，支持网络，可基于内存
      
    
    </summary>
    
      <category term="程序技术" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/"/>
    
      <category term="分布式" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="缓存数据库" scheme="http://example.com/tags/%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
